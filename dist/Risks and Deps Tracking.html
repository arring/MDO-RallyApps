<!-- Build: dev-rallyapps:594170ef96de02233c23500a3128587faa4de180:2016-12-31T04:32:14.732Z --><!DOCTYPE html>
<html>
<head>
    <title>Risks and Deps Tracking</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.4.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** 
	SUMMARY:
		This extends Rally.app.app. All Intel Apps should extend from this if they want to use the functionality it provides,
		as well as numerous other lib/* files that require you to extend from this.
		
		If you extend from Intel.lib.IntelRallyApp, you have to call me.configureIntelRallyApp() before anything else in your launch() 
		function. After you call me.configureIntelRallyApp, you will be able to access a lot of things, such as:
			- me.ScheduleStates: possible UserStory schedule States
			- me.PortfolioItemTypes: Ordered Array of PortfolioItem Types. e.g.: ['Feature', 'Milestone', 'Product']
			- me.ScrumGroupConfig: the scrum group portfolio location config for the workspace
			- me.HorizontalGroupingConfig: the horizontal scrum groupings by keywords
			- All the most-used Rally models, such as me.Project, me.UserStory, me.PortfolioItem, etc... 
		
	DEPENDENCIES:
		Q promise library
		
	ISSUES:
		sdk 2.0 does not work with the project function due to a bug in the sdk. use sdk 2.0rc3
	*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		ScrumGroupConfigPrefName = 'intel-config-portfolio-locations', //preference to store portfolio locations config for workspace
		HorizontalGroupingConfigPrefName = 'intel-config-horizontal-grouping',//preference to store map of keywords in project names to horizontal
		TrainTypeGroupConfigPrefName = 'intel-traintype-grouping-config',//preference to store map of train type
		EditPermissionListPrefName = 'intel-workspaceapp-permission-list',//preference to store list of people who can save changes
		LastModifiedWorkspaceAppByPrefName = 'intel-workspaceapp-modifiedby-list';//preference to save people who last modified the preferences
	
	//increase timeouts to 5 minutes since rally can be slow sometimes
	var timeout = 300000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('Intel.lib.IntelRallyApp', {
		extend: 'Rally.app.App',
		minWidth:910, //when Rally adds its own scrollbar anyways
		
		projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal',
			'PercentDoneByStoryPlanEstimate'],
		userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me.reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					User: 'User',
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadHorizontalGroupingConfig: function(){
			/** HorizontalGroupingConfig is this:
			{
				enabled: boolean,
				groups: {
					<horizontal1Name>: ['keyword1', 'keyword2'],
					<horizontal2Name>: ['keyword1', 'keyword2'],
					...
				}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				success: function(prefs) {
					var configString = prefs[HorizontalGroupingConfigPrefName], horizontalGroupingConfig;
					try{ horizontalGroupingConfig = JSON.parse(configString); }
					catch(e){ horizontalGroupingConfig = {enabled:false, groups:{}}; }
					me.HorizontalGroupingConfig = horizontalGroupingConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadTrainTypeGroupingConfig: function(){
			/** TrainTypeGroupingConfig is this:
			{
				traintypes: {['keyword1', 'keyword2']}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: TrainTypeGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[TrainTypeGroupConfigPrefName], trainTypeGroupingConfig;
					try{ trainTypeGroupingConfig = JSON.parse(configString); }
					catch(e){ trainTypeGroupingConfig = {traintypes:{}}; }
					me.TrainTypeGroupingConfig = trainTypeGroupingConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		_loadConfigEditPermissionList: function(){
			/** ConfigEditPermissionList is this:
			{
				username: {['keyword1', 'keyword2']}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: EditPermissionListPrefName,
				success: function(prefs) {
					var permissionListString = prefs[EditPermissionListPrefName], ConfigEditPermissionList;
					try{ configEditPermissionList = JSON.parse(permissionListString); }
					catch(e){ configEditPermissionList = {username:{}}; }
					me.ConfigEditPermissionList = configEditPermissionList;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadLastModifiedWorkspaceAppByPref: function(){
			/**  */
			/** me.LastModifiedWorkspaceAppBy is an array of these objects: 
				{
					KeyValueDatabase: {username:"",date:""},
					TrainTypeConfig: {username:"",date:""},
					ScrumGroupAndPortfolioConfig:{username:"",date:""},
					WorkspaceAppPermissionConfig:{username:"",date:""},
					EnableHorizontal: {username:"",date:""},
					HorizontalGroupingConfig:{username:"",date:""}
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: LastModifiedWorkspaceAppByPrefName,
				success: function(prefs) {
					var configString = prefs[LastModifiedWorkspaceAppByPrefName], lastModifiedWorkspaceAppBy;
					try{ 
						lastModifiedWorkspaceAppBy = JSON.parse(configString); 
						if(_.isEmpty(lastModifiedWorkspaceAppBy))
							lastModifiedWorkspaceAppBy = {
								KeyValueDatabase: [],
								TrainTypeConfig: [],
								ScrumGroupAndPortfolioConfig:[],
								WorkspaceAppPermissionConfig:[],
								EnableHorizontal: [],
								HorizontalGroupingConfig:[]
							};								
						}
					catch(e){ 
						lastModifiedWorkspaceAppBy = {
							KeyValueDatabase: [],
							TrainTypeConfig: [],
							ScrumGroupAndPortfolioConfig:[],
							WorkspaceAppPermissionConfig:[],
							EnableHorizontal: [],
							HorizontalGroupingConfig:[]
						}; 
					}
					me.LastModifiedWorkspaceAppBy = lastModifiedWorkspaceAppBy;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveLastModifiedWorkspaceAppBy: function(lastModifiedByObj){
			var me=this, s = {}, deferred = Q.defer();
			_.each(lastModifiedByObj,function(value,key){
				if(lastModifiedByObj[key].length > 10){
					lastModifiedByObj[key] = _.sortBy(lastModifiedByObj[key],	function(o) { return new Date(o.date); });
					lastModifiedByObj[key].splice(0, lastModifiedByObj[key].length-10);	//need to keep only 10 recent records			
				}
			});
			s[LastModifiedWorkspaceAppByPrefName] = JSON.stringify(lastModifiedByObj); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: LastModifiedWorkspaceAppByPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveConfigEditPermissionList: function(userListObj){
			var me=this, s = {}, deferred = Q.defer();
			s[EditPermissionListPrefName] = JSON.stringify(userListObj); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: EditPermissionListPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		saveHorizontalGroupingConfig: function(horizontalGroupingConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[HorizontalGroupingConfigPrefName] = JSON.stringify(horizontalGroupingConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveTrainTypeGroupingConfig: function(traintypeGroupingConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[TrainTypeGroupConfigPrefName] = JSON.stringify(traintypeGroupingConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: TrainTypeGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me.userStoryFields.push(me.PortfolioItemTypes[0]);  
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadHorizontalGroupingConfig(),
				me._loadTrainTypeGroupingConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadProject');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me.projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadUserStory');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me.userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: loadPortfolioItemByType');
			else {
				type = (type.indexOf('PortfolioItem/') === 0) ? type : ('PortfolioItem/' + type);	
				me[type].load(oid, {
					fetch: me.portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me.loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID;
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me.loadProject(parent.ObjectID).then(function(parentRecord){
							return me.projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me.loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me.reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		getScrumGroupPortfolioObjectIDs: function(){
			return _.map(me.ScrumGroupConfig, function(item){
				return item.ScrumGroupAndPortfolioLocationTheSame ? item.ScrumGroupRootProjectOID : item.PortfolioProjectOID;
			});
		},
		getPortfolioOIDForScrumGroupRootProjectRecord: function(scrumGroupRootProjectRecord){
			var configItem = _.find(this.ScrumGroupConfig, function(item){ 
				return item.ScrumGroupRootProjectOID === scrumGroupRootProjectRecord.data.ObjectID; 
			});
			return configItem.ScrumGroupAndPortfolioLocationTheSame ? configItem.ScrumGroupRootProjectOID : configItem.PortfolioProjectOID;
		},
		
		/**************************************** UserStory Funcs ************************************************/
		_getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: loadRandomUserStory');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: loadRandomUserStoryFromReleaseTimeframe');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me.userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me.reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: loadUserStoryByFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfType');
			var me = this;
			//US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
			if(type == 'Business Objective')
			{
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'PortfolioItem/' + type,
					limit: Infinity,
					disableMetaChangeEvent: true,
					remoteSort: false,
					fetch: me.portfolioItemFields,
					context: {
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp: true
					}
				});
			}
			else{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: false
						}
					});
			}
			return me.reloadStore(store);
		},		
		loadPortfolioItemsOfTypeInRelease: function(releaseRecord, portfolioProject, type){
			if(!releaseRecord || !portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfTypeInRelease');
			var me = this;
			//US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
			if(type == 'Business Objective')
			{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: true
						}
					});
			}
			else{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: false
						}
					});
			}
			return me.reloadStore(store);
		},
		loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: loadPortfolioItemsOfOrdinal');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me.loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this.getPortfolioItemTypeStateByOrdinal(this.portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap: function(portfolioItemStores){
			var portfolioItemMap = {};
			_.each(portfolioItemStores[0].getRange(), function(lowPortfolioItemRecord){ //create the portfolioItem mapping
				var ordinal = 0, 
					parentPortfolioItemRecord = lowPortfolioItemRecord,
					getParentRecord = function(child, parentList){
						return _.find(parentList, function(parent){ 
							return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID; 
						});
					};
				while(ordinal < (portfolioItemStores.length-1) && parentPortfolioItemRecord){
					parentPortfolioItemRecord = getParentRecord(parentPortfolioItemRecord, portfolioItemStores[ordinal+1].getRange());
					++ordinal;
				}
				if(ordinal === (portfolioItemStores.length-1) && parentPortfolioItemRecord) //has a mapping, so add it
					portfolioItemMap[lowPortfolioItemRecord.data.ObjectID] = parentPortfolioItemRecord.data.Name;
			});
			return portfolioItemMap;
		},
			
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		_storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},
		getPorfolioProjectFilterQuery: function(rootProjectRecord){
			//filter out porfolio as project if train and porfolio is under same project
			//rootProjectRecord is optional
			var me = this,
				deferred = Q.defer(),
				filter = [];
			me.ScrumGroupAndPortfolioConfig =  _.filter(me.ScrumGroupConfig,function(train){return train.ScrumGroupRootProjectOID === rootProjectRecord.data.ObjectID; })[0];
			if(!rootProjectRecord || me.ScrumGroupAndPortfolioConfig.ScrumGroupAndPortfolioLocationTheSame) return Q();
			if(me.ScrumGroupPortfolioProject){
				filter =  Ext.create('Rally.data.wsapi.Filter', { property: 'Parent.ObjectID',operator: '!= ', value: me.ScrumGroupPortfolioProject.data.ObjectID });
				return Q(filter);
			}else{
			return me.loadScrumGroupPortfolioProject(rootProjectRecord)
				.then(function(scrumGroupPortfolioProject){
					me.ScrumGroupPortfolioProject = scrumGroupPortfolioProject;
					filter =   Ext.create('Rally.data.wsapi.Filter', { property: 'Parent.ObjectID',operator: '!= ', value: me.ScrumGroupPortfolioProject.data.ObjectID });
					return Q(filter);
				});				
			}
		},
		loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me = this,
			leafProjects = {};
			return me.getPorfolioProjectFilterQuery(rootProjectRecord)
				.then(function(filter){
					var store = Ext.create('Rally.data.wsapi.Store', {
							model: "Project",
							fetch: me.projectFields,
							filters: filter ? [filter] : [],
							compact: false,
							limit:Infinity,
							disableMetaChangeEvent: true,
							context:{
								workspace: me.getContext().getWorkspace()._ref,
								project:null
							}
						});	
					return me.reloadStore(store).then(function(store){
						if(rootProjectRecord){
							var projTree = me._storeItemsToProjTree(store.getRange());
							me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
							return leafProjects;
						} else {
							return _.reduce(_.filter(store.getRange(),
								function(project){ return project.data.Children.Count === 0; }),
								function(map, project){
									map[project.data.ObjectID] = project;
									return map;
								}, {});
						}
					});					
				});
		},
		loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesAfterGivenDateByProjectObjID: function(projectObjectID, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},		
		loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesInTheFuture: function(projectRecord){
			return this.loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                /** 
	SUMMARY: 
		A project is used as a database. Each artifact in that project is a key-value pair. That means that all artifact of a certain type 
		created in that project are created with 'key' and 'value' fields. Multiple artifacts can have the same 'key',
		which will allow for easier filtering by other apps.
		
		Example: you want to make UserStories that represent the favorite color count for each person on each scrum. Every Story could
		represent 1 person. So for project 'scrumA', and scrum member 'jim' who likes color 'blue' we would have:
		
			UserStory: {
				c_usDbKey: 'favoriteColor-<scrumA ObjectID>-<userA ObjectID>',
				c_usDbValue: 'blue'
			}
		
		"key" field should be a unique 'string' field and "value field" should be a 'text' field.
		
		We have to keep track of which project this preference is stored in, so we create a custom field that keeps track of it.
		
		To Call the CRUD methods, you must first call initialize() method. You don't need to call initialize() before calling 
		setDatabaseProjectOID or getDatabaseProjectOID. The CRUD methods for the key value pairs will return an object or list 
		of objects of this form: 
			
			kvPair {
				key: dbKey,
				value: dbValue
				ObjectID: artifactID
			}
	
	DEPENDENCIES: 
		- kriskowal/q
		- jquery 2.X
		- lodash
		- the KEY_NAME and VALUE_NAME must be hidden custom fields on the <MODEL_NAME> artifact type you choose.
			> so, if you use the defaults in this app, you have to create hidden c_usDbKey(string) and c_usDbValue(text) fields on 
				HierarchicalRequirement in your workspace. Dont mess up the (string) and (text) part
	
	ISSUES: 
		If someone has an app open that uses this, and another person changes the projectOID, the first person will continue to 
		save key-value pairs to the old project. So make sure nobody is using apps that require this class when you are modifying the 
		project serving as the database.
		
		Ext.Ajax keeps changing the apiKey in the url for POST, PUT and DELETE requests. Could not figure out why, so using jquery instead.
		
		Also, this uses ajax, not sure what that means with regards to CORS but I think you cannot use file:/// protocol when developing
		locally.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** 
		The first 6 variables should probably just be left alone. But if you feel compelled to use Tasks or Defects as the KV storage
		medium (MODEL_NAME) or change the KEY_NAME or VALUE_NAME or PREF_NAME, knock yourself out.
		
		The next 2 variables are the max length the key and value strings can be.
		
		The last 2 variables will be modified as apps use this database
	*/
	var PREF_NAME = 'intel-key-value-database-project',
		MODEL_NAME = 'HierarchicalRequirement',
		KEY_NAME = 'c_usDbKey',
		VALUE_NAME = 'c_usDbValue',
		SECURITY_KEY = Rally.env.IoProvider.getSecurityToken(),
		BASE_URL =  Rally.environment.getServer().getBaseUrl() +  '/slm/webservice/v2.0',
		
		MAX_TEXT_LENGTH = 65536,
		MAX_STRING_LENGTH = 256,
		
		INITIALIZED = false,
		PROJECT_OID = 0;
	
	Ext.define('Intel.lib.resource.KeyValueDb', {
		singleton: true,
		
		/**
			private method for sending requests to the rally server. 
		
			method must be an HTTP method
			params must be an object
			data may be undefined or a non-null object
			
			returns Promise(httpResponseData)
		*/
		_sendRequest: function(method, params, urlExtension, data){
			var deferred = Q.defer();
			
			if(['GET', 'POST', 'PUT', 'DELETE'].indexOf(method) === -1)                     return Q.reject('invalid method');
			if(!(params instanceof Object) || params === null)                              return Q.reject('invalid params');
			if(typeof urlExtension !== 'string' || urlExtension[0] !== '/')                 return Q.reject('invalid urlExtension');
			if(typeof data !== 'undefined' && (!(data instanceof Object) || data === null)) return Q.reject('invalid data');

			data = (data === undefined ? data : JSON.stringify(data, null, '  '));
			params = _.map(Ext.merge({
				fetch: ['ObjectID', KEY_NAME, VALUE_NAME].join(','),
				project: '/project/' + PROJECT_OID,
				projectScopeUp: false,
				projectScopeDown: false,
				key: SECURITY_KEY
			}, params), function(value, key){ return key + '=' + value; }).join('&');
			
			var request = $.ajax({
				url: BASE_URL + urlExtension + '?' + params,
				method: method,
				data: data,
				dataType: 'json',
				headers: {
					'Content-Type' : 'application/json'
				},
				xhrFields: {
					withCredentials: true
				}
			});
			request.done(function(json){
				var results, errors;
				json = json.OperationResult || json.QueryResult || json.CreateResult || json[MODEL_NAME];
				errors = json.Errors;
				results = json.Results || json.Object || json;
				if(errors && errors.length) deferred.reject(errors);
				else deferred.resolve(results);
			});
			request.fail(function(jqXHR, textStatus){
				deferred.reject(textStatus);
			});
			
			return deferred.promise;
		},
		
		/** 
			You must call this before you can use it. Not using constructor because we need a promise to be returned.
			This fails if the preference does not exist or holds a bad value.
			returns Promise()
		*/
		initialize: function(){
			if(INITIALIZED) return Q();
			return this.getDatabaseProjectOID()
				.then(function(projectOID){
					projectOID = parseInt(projectOID, 10);
					if(isNaN(projectOID) || projectOID <= 0) return Q.reject('KeyValueDb not properly initialized');
					else PROJECT_OID = projectOID;
				})
				.then(function(){ INITIALIZED = true; });
		},
		
		/** 
			Sets the ObjectID for the project that will serve as a database.
			returns Promise(projectOID)
		*/
		setDatabaseProjectOID: function(projectOID){
			var settings = {}, deferred = Q.defer();
			
			projectOID = parseInt(projectOID, 10);
			if(isNaN(projectOID) || projectOID <= 0) return Q.reject('invalid projectOID');
			
			settings[PREF_NAME] = projectOID; 
			Rally.data.PreferenceManager.update({
				workspace: Rally.environment.getContext().getWorkspace()._ref,
				filterByName: PREF_NAME,
				settings: settings,
				success: function(prefs){ 
					PROJECT_OID = projectOID;
					deferred.resolve(projectOID); 
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
	
		/** 
			Gets the projectOID that serves as a database.
			returns Promise(projectOID)
		*/
		getDatabaseProjectOID: function(){
			var deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: Rally.environment.getContext().getWorkspace()._ref,
				filterByName: PREF_NAME,
				success: function(prefs){ 
					var projectOID = parseInt(prefs[PREF_NAME], 10);
					if(isNaN(projectOID) || projectOID <= 0) deferred.reject('invalid projectOID');
					else deferred.resolve(projectOID); 
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		
		/** returns Promise(kvPair || null) */
		getKeyValuePair: function(dbKey){
			if(!INITIALIZED)                      return Q.reject('not initialized');
			if(typeof dbKey !== 'string')         return Q.reject('invalid key');
			if(dbKey.length === 0)                return Q.reject('key too short');
			if(dbKey.length > MAX_STRING_LENGTH)  return Q.reject('key too long');
			
			var urlExtension = '/' + MODEL_NAME,
				params = {
					query: '(' + KEY_NAME + ' = "' + dbKey + '")',
					pagesize: 1
				};
			
			return this._sendRequest('GET', params, urlExtension).then(function(items){ 
				if(items.length){
					return {
						key: items[0][KEY_NAME],
						value: items[0][VALUE_NAME],
						ObjectID: items[0].ObjectID
					};
				}
				else return null;
			});
		},
		
		/** returns Promise( [kvPair] ) */
		queryKeyValuePairs: function(dbKeyContains){
			var me=this, allItems = [];
			
			if(!INITIALIZED)                              return Q.reject('not initialized');
			if(typeof dbKeyContains !== 'string')         return Q.reject('invalid key');
			if(dbKeyContains.length > MAX_STRING_LENGTH)  return Q.reject('key too long');
			
			var urlExtension = '/' + MODEL_NAME,
				params = {
					query: '(' + KEY_NAME + ' contains "' + dbKeyContains + '")',
					pagesize: 200,
					start: 1
				};
				
			function nextPage(){
				return me._sendRequest('GET', params, urlExtension).then(function(items){
					if(items.length){
						allItems = allItems.concat(items);
						params.start += 200;
						return nextPage();
					}
				});
			}
			return nextPage().then(function(){
				return allItems.map(function(item){
					return {
						key: item[KEY_NAME],
						value: item[VALUE_NAME],
						ObjectID: item.ObjectID
					};
				});
			});
		},
		
		/** returns Promise(kvPair) */
		createKeyValuePair: function(dbKey, dbValue){
			var me = this, jsonData = {};
			
			if(!INITIALIZED)                      return Q.reject('not initialized');
			if(typeof dbKey !== 'string')         return Q.reject('invalid key');
			if(typeof dbValue !== 'string')       return Q.reject('invalid value');
			if(dbKey.length === 0)                return Q.reject('key too short');
			if(dbKey.length > MAX_STRING_LENGTH)  return Q.reject('key too long');
			if(dbValue.length > MAX_TEXT_LENGTH)  return Q.reject('value too long');
			
			jsonData[MODEL_NAME] = {};
			jsonData[MODEL_NAME][KEY_NAME] = dbKey;
			jsonData[MODEL_NAME][VALUE_NAME] = dbValue;
			jsonData[MODEL_NAME].Name = dbKey;
			
			return me.getKeyValuePair(dbKey).then(function(kvPair){
				if(kvPair) return Q.reject('key already exists');
				else {					
					var urlExtension = '/' + MODEL_NAME + '/create';
					return me._sendRequest('PUT', {}, urlExtension, jsonData);
				}
			}).then(function(item){
				return {
					key: item[KEY_NAME],
					value: item[VALUE_NAME],
					ObjectID: item.ObjectID
				};
			});
		},
		
		/** returns Promise(kvPair) */
		updateKeyValuePair: function(dbKey, dbValue){
			var me = this, jsonData = {};
			
			if(!INITIALIZED)                      return Q.reject('not initialized');
			if(typeof dbKey !== 'string')         return Q.reject('invalid key');
			if(typeof dbValue !== 'string')       return Q.reject('invalid value');
			if(dbKey.length === 0)                return Q.reject('key too short');
			if(dbKey.length > MAX_STRING_LENGTH)  return Q.reject('key too long');
			if(dbValue.length > MAX_TEXT_LENGTH)  return Q.reject('value too long');
			
			jsonData[MODEL_NAME] = {};
			jsonData[MODEL_NAME][KEY_NAME] = dbKey;
			jsonData[MODEL_NAME][VALUE_NAME] = dbValue;
			jsonData[MODEL_NAME].Name = dbKey;

			return me.getKeyValuePair(dbKey).then(function(kvPair){
				if(!kvPair) return Q.reject('key does not exist');
				else{					
					var urlExtension = '/' + MODEL_NAME + '/' + kvPair.ObjectID;
					return me._sendRequest('POST', {}, urlExtension, jsonData);
				}
			}).then(function(item){
				return {
					key: item[KEY_NAME],
					value: item[VALUE_NAME],
					ObjectID: item.ObjectID
				};
			});
		},
		
		/** returns Promise(void) */
		deleteKeyValuePair: function(dbKey){
			var me = this;
			
			if(!INITIALIZED)                      return Q.reject('not initialized');
			if(typeof dbKey !== 'string')         return Q.reject('invalid key');
			if(dbKey.length === 0)                return Q.reject('key too short');
			if(dbKey.length > MAX_STRING_LENGTH)  return Q.reject('key too long');

			return me.getKeyValuePair(dbKey).then(function(kvPair){
				if(kvPair){
					var urlExtension = '/' + MODEL_NAME + '/' + kvPair.ObjectID;	
					return me._sendRequest('DELETE', {}, urlExtension);
				}
			});
		}
	});
}());
                /** 
	SUMMARY:
		This mixin is used if you want to listen to events in the parent window (e.g. useful for rally apps that 
		resize with browser screen vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run using fireParentWindowEvent
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		windowListeners = {};

	Ext.define('Intel.lib.mixin.WindowListener', {

		_initWindowEventListener: function(eventName){
			if(!windowListeners) windowListeners = {};
			windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		/** eventName is something like: resize, scroll, etc... */
		addWindowEventListener: function(eventName, fn){
			if(!windowListeners || !windowListeners[eventName]) 
				this._initWindowEventListener(eventName);
			windowListeners[eventName].push(fn);
		},
		
		/** eventName is something like: resize, scroll, etc... */
		fireParentWindowEvent: function(eventName){
			var me=this;
			if(!windowListeners || !windowListeners[eventName]) return;
			var listeners = windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** 
	SUMMARY:
		this mixin is used to mess with the environment outside of the iframe that the rally app is put in. 
		
	DEPENDENCIES:
		'Intel.lib.mixin.WindowListener' mixed in to app so listen for window events
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('Intel.lib.mixin.IframeResize', {
		requires: ['Intel.lib.mixin.WindowListener'],
		
		/**
			makes app as large as screen, without the padding/margin. 
			Makes it look more like a built-in rally app instead of a custom app.
			NOTE: as rally changes their interface overtime, this mixin will have to change as well to compensate for it.
			This changed once and all the classes names got changes. Thats why its commented out. 
		*/
		hideGearButtonAndCustomAppPanel: function(){
			var me = this;
			if(Ext.get(window.frameElement)){
				//hide the gear button for the first panel that has the App name
				Ext.get(window.frameElement).up('#content').down('.smb-Header').dom.querySelectorAll('.smb-HeaderGroupContainer--right')[0].style.display = 'none';
				//hides the whole custom html panel 
				Ext.get(window.frameElement).up('#content').down('.smb-Grid').down('.smb-Header').dom.style.display ='none';					
			}
		},
		_fixRallyDashboard: function(){ 
		/*	if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//remove vertical/horizontal scrolls from top window
				window.parent.document.body.insertAdjacentHTML('afterend', '<style>html, body {overflow: hidden !important; }</style>');
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 10) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING) - 10) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			} */
		},		
		initFixRallyDashboard: function(){ 
/*		var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard(); */
		},

		/** 
			hides the draggable resize handle from under the app 
		*/
		_disableResizeHandle: function(){ 
/*		var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			} */
		},	
		initDisableResizeHandle: function(){
/*		var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle(); */
		}
	});
}());
                /**  
	DESCRIPTION:
		This mixin gives a window-centered alert or confirm dialog box that isn't ugly. 
		
	ISSUES:
		Sometimes alert.setY() fails so we have to fallback to the ugly built-in alert
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.PrettyAlert', {	
		_getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_formatString: function(message){
			message = message || '';
			return (typeof message === 'string') ? 
				message : (message.message ? 
				message.message : JSON.stringify(message, null, '\t'));
		},

		/** non-ugly alert dialog */
		alert: function(title, message){
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			
			try {
				Ext.MessageBox.alert(this._formatString(title), this._formatString(message)).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ alert(this._formatString(message)); }
		},
		
		/** non-ugly confirm dialog */
		confirm: function(title, message, fn){
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			
			try {
				Ext.MessageBox.confirm(this._formatString(title), this._formatString(message), fn).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ if(confirm(this._formatString(message))) fn('yes'); else fn('no'); }
		}
	});
}());
                /** 
	intel workweek utility module. you can pass in Date objects, strings, or numbers.
	do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
**/
(function(){
	var Ext = window.Ext4 || window.Ext,
		intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('Intel.lib.mixin.IntelWorkweek', {
		/** calculates intel workweek, returns integer */
		getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		getWeekCount: function(_date){
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of Date()'s for each week start between start and end date*/
		getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this.roundDateDownToWeekStart(startDate),
				endWeekDate = this.roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		/** gets the Date() object of this ww and year */
		workweekToDate: function(ww, year){ 
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/** assumes DropDown uses Intel.lib.data.WorkweekDropdown model */
		getWorkweeksForDropdown: function(releaseStartDate, releaseEndDate){ 
			var workweeks = this.getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this.getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** 
	given named queues, only allows one function at a time in each queue to execute. 
	
	This is just a locking implementation. you call enqueue and then when its your function's turn
	you do stuff and then you call the callback passed to you so the next function can execute.
	
	It will always perfom your queued function wrapped in a setTimeout. 
	
	Mix this in to your app: call me.enqueue(function(){...}, 'queue-name') 
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		QueueOfFuncs = {};
	
	function dequeue(queueName){
		queueName = queueName || 'undefined';
		if(QueueOfFuncs[queueName]){
			QueueOfFuncs[queueName].shift();
			if(!QueueOfFuncs[queueName].length) return;
			else {
				setTimeout(function(){
					QueueOfFuncs[queueName][0].call(null, dequeue.bind(null, queueName));
				}, 0);
			}
		}
	}
	
	Ext.define('Intel.lib.mixin.AsyncQueue', {
		/**
			input callback(done): make sure you call done when you are finished
			input queueName: name of queue to use, if not specified uses default
		*/
		enqueue: function(callback, queueName){
			queueName = queueName || 'undefined';
			if(typeof callback !== 'function') throw new Error('Not a function');
			if(!QueueOfFuncs[queueName] || !QueueOfFuncs[queueName].length){
				QueueOfFuncs[queueName] = [callback];
				setTimeout(function(){
					callback.call(null, dequeue.bind(null, queueName));
				}, 0);
			}
			else QueueOfFuncs[queueName].push(callback);
		}
	});
}());
                /** 
	SUMMARY:
		Use this mixin to load stores that have lots of records. it will load them in parallel instead of serially.
		what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.
		
		The config you pass to parallelLoadLookbackStore and parallelLoadWsapiStore are the same configs you would pass
		to Rally.data.lookback.Store (or something like that) and Rally.data.wsapi.Store.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.mixin.ParallelLoader', {		
		parallelLoadWsapiStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
						pageSize:200,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.wsapi.Store', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/200>>0) + (store.totalCount%200 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		},
		parallelLoadLookbackStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
						pageSize:20000,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/20000>>0) + (store.totalCount%20000 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		}
	});
}());

                /** 
	SUMMARY: 
		This mixin is used to save user preferences per project, that can follow the user from app to app. So 
		when you call saveAppsPreference it saves it to a preference filtered by user and the value of me.userAppsPref.
		
		Different apps can share the me.userAppsPref which is useful if you have 5 apps that should all scope to the same
		Release. So if the user scopes to Release R1 on one of the apps, when she goes to any of the other apps, it should
		scope to Release R1 as well.
**/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.UserAppsPreference', {
		
		/** preference name SHOULD be overridden, unless you want all apps to share default preference-name */
		userAppsPref: 'intel-user-apps-preference',
		
		loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName: me.userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me.userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me.userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName: me.userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                //TODO: find this on a CDN and remove it from here
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var POLL_INTERVAL_MS = 10;
	
	/*!
	 * CTemplate
	 * Version 1.1
	 * Copyright(c) 2011-2013 Skirtle's Den
	 * License: http://skirtlesden.com/ux/ctemplate
	 
		MY NOTE: how this works. XTemplates use apply() to convert the template to the actual HTML. CTemplate converts XTemplate into a bunch
		of <p> tags and stores the ids of them and then immediately starts polling for them in doPolling. do POlling calls injectComponents
		after the poll interval and if injectComponents does not render all the components, it calls doPolling again.
		injectComponents calls renderComponent for each component.
		overwrite and doInsert call the XTemplate parent functions, which call CTemplate's apply, and then they call injectComponents.
		
		NOTE: everytime apply() is called, the me.ids[] is generated, and when injectComponents is finished, me.ids[] is empty!
	 */
	Ext.define('Skirtle.CTemplate',{
		extend: 'Ext.XTemplate',
		statics: { AUTO_ID: 0 },
		
		copyDepth: 10,		
		cTpl: '<p id="ctemplate-{0}-{1}"></p>',
		isCTemplate: true,

		constructor: function(){
			var me = this;
			me.callParent(arguments);
			me.id = ++me.statics().AUTO_ID;
			me.reset();
		},

		copyValues: function(values, depth){
			/* Takes a recursive copy of the values provided, switching out components for placeholder values. The component ids
			 * are recorded and injectComponents() uses the ids to find the placeholder elements in the DOM and switch in the
			 * components.
			 */
			var me = this,
				id,
				copy = {},
				copyDepth = depth || me.copyDepth;

			if(copyDepth === 1) return values;

			if(Ext.isArray(values)){
				return Ext.Array.map(values, function(value) {
					return me.copyValues(value, copyDepth - 1);
				});
			}

			if(!Ext.isObject(values)) return values;

			// This is the key sleight-of-hand that makes the whole thing work
			if(values.isComponent){
				id = values.getId();
				me.ids.push(id);
				return Ext.String.format(me.cTpl, id, me.id);
			}

			Ext.Object.each(values, function(key, value) {
				// $comp is a special value for a renderTpl that references the current component
				copy[key] = key === '$comp' ? value : me.copyValues(value, copyDepth - 1);
			});

			return copy;
		},
		doInsert: function() { // Override
			//(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
			var ret = this.callParent(arguments);	
			this.injectComponents();// There's no guarantee this will succeed so we still need polling as well
			return ret;
		},
		doPolling: function(interval) {
			var me = this;
			me.pollInterval = interval;
			if(me.pollId) clearTimeout(me.pollId);
			me.pollId = Ext.defer(me.injectComponents, interval, me);
		},
		getPlaceholderEl: function(id) {
			return Ext.get('ctemplate-' + id + '-' + this.id);
		},	
		injectComponents: function() {
			/* Attempts to substitute all placeholder elements with the real components. If a component is successfully injected
			 * or it has been destroyed then it won't be attempted again. This method is repeatedly invoked by a polling
			 * mechanism until no components remain, however relying on the polling is not advised. Instead it is preferable to
			 * call this method directly as soon as the generated HTML is inserted into the DOM.
			 */
			var me = this,
				ids = me.ids,
				index = ids.length - 1,
				id,
				cmp,
				placeholderEl;

			// Iterate backwards because we remove some elements in the loop
			for( ; index >= 0 ; --index){
				id = ids[index];
				cmp = Ext.getCmp(id);
				placeholderEl = me.getPlaceholderEl(id);
				if(me.renderComponent(cmp, placeholderEl) || !cmp){
					// Either we've successfully done the switch or the component has been destroyed
					Ext.Array.splice(ids, index, 1);
					if(placeholderEl) placeholderEl.remove();
				}
			}
			// Some components have not been injected. Polling acts both to do deferred injection and as a form of GC
			if(ids.length) me.doPolling(me.pollInterval); //originally was me.pollInterval * 1.5
		},
		overwrite: function(el){ // Override 
			//(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
			var dom,
				firstChild,
				ret;

			/* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
			 * will fail as their DOM nodes will have been torn apart. We can't defend against external updates to the DOM
			 * but we can guard against the case where all updates come through this template.
			 */
			if(Ext.isIE){
				dom = Ext.getDom(el);
				while(dom.firstChild){
					dom.removeChild(dom.firstChild);
				}
			}
			ret = this.callParent(arguments);		
			this.injectComponents(); // There's no guarantee this will succeed so we still need polling as well
			return ret;
		},
		renderComponent: function(cmp, placeholderEl){
			if(cmp && placeholderEl){
				var parent = placeholderEl.parent();
				
				// Move a component that has been rendered previously
				if(cmp.rendered) cmp.getEl().replace(placeholderEl);
				else cmp.render(parent, placeholderEl);

				// Some components (mostly form fields) reserve space but fail to show up without a repaint in IE6
				if(Ext.isIE6)	parent.repaint();
				return true;
			}
			else return false;
		},
		reset: function() {
			var me = this;	
			me.ids = [];// The ids of injected components that haven't yet been rendered
			if(me.pollId){
				clearTimeout(me.pollId);
				me.pollId = null;
			}
		}
	}, function(ctemplate) {
		var apply = function(){
			var me = this,
				args = Ext.Array.slice(arguments);
			args[0] = me.copyValues(args[0]);
			me.doPolling(POLL_INTERVAL_MS); // As we're returning an HTML string/array we can't actually complete the injection here
			return me.callParent(args);
		};
		// The main override is different depending on whether we're using ExtJS 4.0 or 4.1+
		if(ctemplate.prototype.applyOut) ctemplate.override({ applyOut: apply });// 4.1+
		else {	
			ctemplate.override({ applyTemplate: apply }); // 4.0
			ctemplate.createAlias('apply', 'applyTemplate');
		}
	});

	/*!
	 * Component Column
	 * Version 1.1
	 * Copyright(c) 2011-2013 Skirtle's Den
	 * License: http://skirtlesden.com/ux/component-column
	 */
	Ext.define('Skirtle.grid.column.Component', {
		alias: 'widget.componentcolumn',
		extend: 'Ext.grid.column.Column',
		requires: ['Skirtle.CTemplate'],

		autoWidthComponents: true, // Whether or not to automatically resize the components when the column resizes		
		componentGC: true, // Whether or not to destroy components when they are removed from the DOM
		hasCustomRenderer: true, // Override the superclass - this must always be true or odd things happen, especially in IE
		lastFrameWidth: 12, // The estimated size of the cell frame. This is updated once there is a cell where it can be measured

		/* Defer durations for updating the component width when a column resizes. Required when a component has an animated
		 * resize that causes the scrollbar to appear/disappear. Otherwise the animated component can end up the wrong size.
		 *
		 * For ExtJS 4.0 both delays are required. For 4.1 just having the 10ms delay seems to be sufficient.
		 */
		widthUpdateDelay: [10, 400],

		constructor: function(cfg) {
			var me = this;

			me.callParent(arguments);

			// Array of component ids for both component queries and GC
			me.compIds = [];

			// We need a dataIndex, even if it doesn't correspond to a real field
			me.dataIndex = me.dataIndex || Ext.id(null, 'cc-dataIndex-');
			me.tpl = me.createTemplate(me.tpl);
			me.renderer = me.createRenderer(me.renderer);
			me.registerColumnListeners();
		},
		addRefOwner: function(child) {
			var me = this,
				fn = me.refOwnerFn || (me.refOwnerFn = function() { return me; });
			if(me.extVersion < 40200) child.getBubbleTarget = fn; // Component queries for ancestors use getBubbleTarget in 4.1 ...
			else child.getRefOwner = fn; // ... and getRefOwner in 4.2+
		},
		applyTemplate: function(data, value) {
			if(Ext.isDefined(value)) data[this.dataIndex] = value;
			return this.tpl.apply(data);
		},
		beforeViewRefresh: function() {
			/* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
			 * will fail as their DOM nodes will have been torn apart. To defend against this we must remove the components
			 * from the DOM just before the grid view is refreshed.
			 */
			if (Ext.isIE) {
				var ids = this.compIds,
					index = 0,
					len = ids.length,
					item,
					el,
					parentEl;

				for ( ; index < len ; index++) {
					if ((item = Ext.getCmp(ids[index])) && (el = item.getEl()) && (el = el.dom) && (parentEl = el.parentNode)) {
						parentEl.removeChild(el);
					}
				}
			}
		},
		calculateFrameWidth: function(component) {
			var el = component.getEl(),
				parentDiv = el && el.parent(),
				// By default the TD has no padding but it is quite common to add some via a tdCls
				parentTd = parentDiv && parentDiv.parent();

			if(parentTd){
				// Cache the frame width so that it can be used as a 'best guess' in cases where we don't have the elements
				this.lastFrameWidth = parentDiv.getFrameWidth('lr') + parentTd.getFrameWidth('lr');
				return this.lastFrameWidth;
			}
		},
		createRenderer: function(renderer) {
			var me = this;
			return function(value, p, record) {
				var data = Ext.apply({}, record.data, record.getAssociatedData());
				if(renderer) value = renderer.apply(this, arguments); // Scope must be this, not me
				// Process the value even with no renderer defined as the record may contain a component config
				value = me.processValue(value);
				return me.applyTemplate(data, value);
			};
		},
		createTemplate: function(tpl) {
			return tpl && tpl.isTemplate ? tpl : Ext.create('Skirtle.CTemplate', tpl || ['{', this.dataIndex ,'}']);
		},
		destroyChild: function(child) { child.destroy(); },
		getRefItems: function(deep) {
			var items = this.callParent([deep]),
					ids = this.compIds,
					index = 0,
					len = ids.length,
					item;

			for( ; index < len ; index++){
				item = Ext.getCmp(ids[index]);
				if(item){
					items.push(item);
					if(deep && item.getRefItems) items.push.apply(items, item.getRefItems(true));
				}
			}
			return items;
		},
		onChildAfterRender: function(child){ this.resizeChild(child); },
		onChildBoxReady: function(child){
			// Pass false to avoid triggering deferred resize, the afterrender listener will already cover those cases
			this.resizeChild(child, false);
		},
		onChildDestroy: function(child){ Ext.Array.remove(this.compIds, child.getId()); },
		onChildResize: function(){ this.redoScrollbars(); },
		onColumnResize: function(column){ column.resizeAll(); },
		onColumnShow: function(column){ column.resizeAll(); },
		onColumnVisibilityChange: function(column) {
			// This is called in IE 6/7 as the components can still be seen even when a column is hidden
			var items = column.getRefItems(),
				index = 0,
				length = items.length,
				visible = !column.isHidden();

			// In practice this probably won't help but it shouldn't hurt either
			if(Ext.suspendLayouts) Ext.suspendLayouts();

			for( ; index < length ; ++index){
				items[index].setVisible(visible);
			}
			if(Ext.resumeLayouts) Ext.resumeLayouts(true);
		},
		onDestroy: function() {
				Ext.destroy(this.getRefItems());

				this.callParent();
		},
		onRender: function(){ // Override
			this.registerViewListeners();
			this.callParent(arguments);
		},
		onViewChange: function() {
			// View has changed, may be a full refresh or just a single row
			var me = this,
				tpl = me.tpl;

			// Batch the resizing of child components until after they've all been injected
			me.suspendResizing();

			if (tpl.isCTemplate) {
				// No need to wait for the polling, the sooner we inject the less painful it is
				tpl.injectComponents();
				// If the template picked up other components in the data we can just ignore them, they're not for us
				tpl.reset();
			}
			// A view change could mean scrollbar problems. Note this won't actually do anything till we call resumeResizing
			me.redoScrollbars();
			me.resumeResizing();			
			me.performGC();
		},
		performGC: function() {
			// Component GC, try to stop components leaking
			var compIds = this.compIds,
				index = compIds.length - 1,
				comp,
				el;

			for( ; index >= 0 ; --index){
				// Could just assume that the component id is the el id but that seems risky
				comp = Ext.getCmp(compIds[index]);
				el = comp && comp.getEl();

				if (!el || (this.componentGC && (!el.dom || Ext.getDom(Ext.id(el)) !== el.dom))) {
					// The component is no longer in the DOM
					if(comp && !comp.isDestroyed) comp.destroy();
				}
			}
		},
		processValue: function(value) {
			var me = this,
				compIds = me.compIds,
				id, initialWidth, dom, parent;

			if(Ext.isObject(value) && !value.isComponent && value.xtype) {
				// Do not default to a panel, not only would it be an odd default but it makes future enhancements trickier
				value = Ext.widget(value.xtype, value);
			}

			if(value && value.isComponent){
				id = value.getId();
				// When the view is refreshed the renderer could return a component that's already in the list
				if(!Ext.Array.contains(compIds, id)) compIds.push(id);
				me.addRefOwner(value);
				me.registerListeners(value);
				if(value.rendered){
					/* This is only necessary in IE because it is just another manifestation of the innerHTML problems.
					 * The problem occurs when a record value is changed and the components in that same row are being
					 * reused. The view doesn't go through a full refresh, instead it performs a quick update on just the
					 * one row. Unfortunately this nukes the existing components so we need to remove them first.
					 */
					if(Ext.isIE){
						// TODO: Should this be promoted to CTemplate?
						dom = value.el.dom;
						parent = dom.parentNode;

						if(parent){
							if(me.extVersion === 40101){
								// Workaround for the bugs in Element.syncContent - p tag matches CTemplate.cTpl
								Ext.core.DomHelper.insertBefore(dom, {tag: 'p'});
							}
							// TODO: Removing the element like this could fall foul of Element GC
							parent.removeChild(dom);
						}
					}
				}
				else if (me.autoWidthComponents) {
					/* Set the width to a 'best guess' before the component is rendered to ensure that the component's
					 * layout is using a configured width and not natural width. This avoids problems with 4.1.1 where
					 * subsequent calls to setWidth are ignored because it believes the width is already correct but only
					 * the outermost element is actually sized correctly. We could use an arbitrary width but instead we
					 * make a reasonable guess at what the actual width will be to try to avoid extra resizing.
					 */
					initialWidth = me.getWidth() - me.lastFrameWidth;

					// Impose a minimum width of 4, we really don't want negatives values or NaN slipping through
					initialWidth = initialWidth > 4 ? initialWidth : 4;

					value.setWidth(initialWidth);
				}
				// Part of the same IE 6/7 hack as onColumnVisibilityChange
				if((Ext.isIE6 || Ext.isIE7) && me.isHidden()) value.hide();
			}

			return value;
		},
		redoScrollbars: function() {
			var me = this,
				grid = me.up('tablepanel');

			if(grid){
				// The presence of a resizeQueue signifies that we are currently suspended
				if(me.resizeQueue){
					me.redoScrollbarsRequired = true;
					return;
				}

				// After components are injected the need for a grid scrollbar may need redetermining
				if(me.extVersion < 40100){ // 4.0	
					grid.invalidateScroller();
					grid.determineScrollbars();
				}
				else grid.doLayout(); // 4.1+
			}
		},
		registerColumnListeners: function() {
			var me = this;

			if(me.autoWidthComponents){
				// Need to resize children when the column resizes
				me.on('resize', me.onColumnResize);
				// Need to resize children when the column is shown as they can't be resized correctly while it is hidden
				me.on('show', me.onColumnShow);
			}
			if(Ext.isIE6 || Ext.isIE7){
				me.on({
					hide: me.onColumnVisibilityChange,
					show: me.onColumnVisibilityChange
				});
			}
		},
		registerListeners: function(component) {
			var me = this;

			// Remove the component from the child list when it is destroyed
			component.on('destroy', me.onChildDestroy, me);
			if(me.autoWidthComponents){
				// Need to resize children after render as some components (e.g. comboboxes) get it wrong otherwise
				component.on('afterrender', me.onChildAfterRender, me, {single: true});

				// With 4.1 boxready gives more reliable results than afterrender as it occurs after the initial sizing
				if(me.extVersion >= 40100) component.on('boxready', me.onChildBoxReady, me, {single: true});
			}

			// Need to redo scrollbars when a child resizes
			component.on('resize', me.onChildResize, me);
		},
		registerViewListeners: function() {
				var me = this,
					view = me.up('tablepanel').getView();
				me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
				me.mon(view, 'refresh', me.onViewChange, me);
				me.mon(view, 'itemupdate', me.onViewChange, me);
				me.mon(view, 'itemadd', me.onViewChange, me);
				me.mon(view, 'itemremove', me.onViewChange, me);
		},
		resizeAll: function() {
				var me = this;
				me.suspendResizing();
				me.resizeQueue = me.getRefItems();
				me.resumeResizing();
		},
		resizeChild: function(component, defer) {
			var me = this,
				frameWidth,
				newWidth,
				oldWidth,
				resizeQueue;

			if(me.resizingSuspended){
				resizeQueue = me.resizeQueue;
				if(!Ext.Array.contains(resizeQueue, component)) resizeQueue.push(component);
				return;
			}
			frameWidth = me.calculateFrameWidth(component);

			// TODO: Should we destroy the component here if it doesn't have a parent element? Already picked up anyway?
			if(Ext.isNumber(frameWidth)){
				newWidth = me.getWidth() - frameWidth;
				oldWidth = component.getWidth();

				// Returns true if a resize actually happened
				if(me.setChildWidth(component, newWidth, oldWidth)){
					// Avoid an infinite resizing loop, deferring will only happen once
					if(defer !== false){
						// Do the sizing again after a delay. This is because child panel collapse animations undo our sizing
						Ext.each(me.widthUpdateDelay, function(delay){
							Ext.defer(me.resizeChild, delay, me, [component, false]);
						});
					}
				}
			}
		},
		resumeResizing: function() {
			var me = this,
				index = 0,
				resizeQueue = me.resizeQueue,
				len = resizeQueue.length;

			if(!--me.resizingSuspended) {
				for ( ; index < len ; ++index){
					me.resizeChild(resizeQueue[index]);
				}
				me.resizeQueue = null;
				if (me.redoScrollbarsRequired) me.redoScrollbars();
			}
		},
		setChildWidth: function(component, newWidth, oldWidth) {
			if(oldWidth === newWidth) return false;
			component.setWidth(newWidth);
			return true;
		},
		suspendResizing: function() {
			var me = this;
			me.resizingSuspended = (me.resizingSuspended || 0) + 1;
			if(!me.resizeQueue) me.resizeQueue = [];
		}
	}, 
	function(cls){
		var proto = cls.prototype,
			version = Ext.getVersion();
		proto.extVersion = (version.getMajor() * 100 + version.getMinor()) * 100 + version.getPatch(); // ExtJS version detection
		// 4.1.1 initially reported its version as 4.1.0
		if(Ext.Element.prototype.syncContent && version.toString() === '4.1.0') proto.extVersion = 40101;
	});
}());

                /** 
	SUMMARY:
		This combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.component.ComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					change: function(a,b){
						if(!b || (b.keyCode>=37 && b.keyCode <=40)) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							var escapedValue = combo.getRawValue().replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
							return item.data[combo.displayField].match(new RegExp(escapedValue, 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                /** 
	SUMMARY:
		This combo has some built in defaults for static-comboboxes (which means you dont type into it, you just select from it)
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.FixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		editable: false,	
		allowBlank:true,
		queryMode:'local',
		matchFieldWidth: false,
		listeners: {
			change:function(combo, newval, oldval){ 
				if(newval.length===0) combo.setValue(oldval || ''); 
			},
			focus: function(combo) {
				if(combo.store.findExact(combo.valueField, combo.getValue()) === -1) combo.setValue('');
				combo.expand();
			}
		}
	});
}());
                /** 
	SUMMARY:
		This component is an easy release picker based off Intel.lib.component.FixedComboBox. You supply the 
		Release Records to it on construction.
		
		YOU MUST PASS IT 2 THINGS IN THE CONFIG
			1: releases (array of release records)
			2: currentRelease (what to show as initial value
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.ReleasePicker', {
		extend: 'Intel.lib.component.FixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                /** 
	SUMMARY:
		This component is an easy user search picker based off ComboBox. It searches all users in Rally as you type.
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.UserPicker', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.inteluserpicker'],

		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				queryMode: 'local',
				tpl: '<tpl for="."><div class="x-boundlist-item">{LastName}, {FirstName}</div></tpl>',
				displayTpl: '<tpl for="."><tpl if="LastName">{LastName}, {FirstName}</tpl></tpl>',
				allowBlank:true,
				store: Ext.create('Ext.data.Store', {
					fields: ['FirstName', 'LastName', 'UserName', 'ObjectID'],
					proxy: {
						type:'sessionstorage',
						id:'inteluserpickerproxy' + (10000*Math.random()>>0)
					},
					data: []
				}),
				listeners: {
					change: function(combo, newValue){
						if(typeof newValue !== 'string') return;
						combo.setLoading('Loading');
						var searchTerms = (newValue || '').split(',').map(function(x){ return x.trim(); });
						Ext.create('Rally.data.wsapi.Store', {
							model: 'user',
							fetch: ['FirstName', 'LastName', 'UserName', 'ObjectID'],
							pageSize: 20,
							limit:20,
							autoLoad:true,
							filters: ((!newValue.length) ? [] : [_.reduce(searchTerms, function(filter, term){
								var newFilter = 
									Ext.create('Rally.data.wsapi.Filter', {property:'FirstName', operator:'contains', value:term}).or(
									Ext.create('Rally.data.wsapi.Filter', {property:'LastName', operator:'contains', value:term}));
								if(filter) return newFilter.and(filter);
								else return newFilter;
							}, null)])
							.concat(Ext.create('Rally.data.wsapi.Filter', {property:'WorkspacePermission', operator:'!=', value:'No Access'})),
							listeners: {
								load: function(store){
									combo.setLoading(false);
									combo.store.removeAll();
									var users = _.sortBy(_.filter(_.map(store.getRange(),
										function(x){ return x.data; }),
										function(x){ return x.FirstName && x.LastName; }),
										function(x){ return x.LastName + ', ' + x.FirstName; });
									combo.store.add(users);
									combo.expand();
								}
							}
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());

                /**
	SUMMARY:
		Textarea with some defaults built into it.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.TextArea', {
		extend: 'Ext.form.field.TextArea',
		alias: ['widget.inteltextarea'],
		
		grow:true,
		growMin:20,
		growMax:160,
		maxLength:150,
		enforceMaxLength:true,
		enterIsSpecial:true
	});
}());
                /** 
	SUMMARY:
		This is used in grid column configs in the items: [] field for the column. It is a fancy grid column filter component.
		
	DEPENDENCIES:
		Intel.lib.component.FixedComboBox OR <whatever your filterXtype is>
		Intel.lib.mixin.PrettyAlert
		
		Q
		lodash
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.component.GridColumnFilter', {
		extend:'Ext.container.Container',
		cls: 'intel-grid-column-filter',
		alias: ['widget.intelgridcolumnfilter'],
		mixins: [
			'Intel.lib.mixin.PrettyAlert'
		],
		
		layout: 'hbox',
		border:0,
		flex:1,
		
		/**************************************** caller CAN override these **********************************************/
		filterXtype: 'intelfixedcombo',
		valueField: null,
		displayField: null,
		multiSelect: true,
		convertDisplayFn: function(value, field, record){ return value; },			//can return promise
		convertValueFn: function(value, field, record){ return value; },				//can return promise
		sortFn: function(valueFieldValue, displayFieldValue, record){ return valueFieldValue; },
		filterFn: function(filterValue, recordValue, valueField, record){ return filterValue === recordValue; },
		
		/**************************************** INITIALIZE/PRIVATE METHODS **********************************************/
		initComponent: function(){
			var colFilter = this;
			colFilter.filterValues = [];
			colFilter.hideClass = 'grid-column-filter-hide-' + (Math.random()*1000000>>0);
			Ext.DomHelper.append(Ext.getBody(), '<style>.' + colFilter.hideClass + ' { display: none; }</style>');
			Ext.DomHelper.append(Ext.getBody(), '<style>.intel-grid-column-filter > * { border: none !important; }</style>');
			colFilter.on('added', function(){ colFilter._initColFilter(); });
			colFilter.callParent();
		},
		
		_initColFilter: function(){
			var colFilter = this, 
				column = colFilter.ownerCt,
				valueField = colFilter.valueField || column.dataIndex,
				displayField = colFilter.displayField || valueField;
			setTimeout(function waitForGrid(){
				var grid = column.up('grid');
				if(grid){ 
					var gridStore = grid.getStore();
				
					grid.view.getRowClass = colFilter._createGetRowClassIntercepter(grid.view.getRowClass);
					colFilter._addItems(gridStore, valueField, displayField);
					gridStore.on('datachanged', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					gridStore.on('refresh', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					grid.on('edit', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					grid.on('sortchange', function(){ colFilter.applyFilters(); });
				}
				else setTimeout(waitForGrid, 20);
			}, 20);
		},
		_addItems: function(gridStore, valueField, displayField){
			var colFilter = this;
			colFilter._getStoreOptions(gridStore, valueField, displayField).then(function(storeOptions){
				colFilter.add([{
					xtype: colFilter.filterXtype,
					flex:1,
					emptyText: 'Add Filter',
					store: Ext.create('Ext.data.Store', {
						fields:[
							{name:'Display', type:'auto'}, 
							{name:'Value', type:'auto'}
						],
						data: storeOptions
					}),
					displayField: 'Display',
					valueField: 'Value',
					multiSelect: colFilter.multiSelect,
					listeners:{
						select: function(combo, selected){
							if(_.find(selected, function(s){ return s.data.Display === 'Clear'; })) colFilter.clearFilters();
							else colFilter.setFilterValues(_.map(selected, function(s){ return s.data.Value; }));
							var store = colFilter.up('grid').store;
							store.fireEvent('refresh', store);
						}
					}
				}, {xtype:'container', width:5}]);
				colFilter.doLayout();
			})
			.fail(function(reason){ colFilter.alert('ERROR', reason); })
			.done();
		},	
		_getStoreOptions: function(gridStore, valueField, displayField){
			var grid = this;
			return Q.all(_.map(gridStore.getRange(), function(record){
				return Q.all([
					Q(grid.convertDisplayFn(record.get(displayField), displayField, record)),
					Q(grid.convertValueFn(record.get(valueField), valueField, record)),
					Q(record)
				]);
			}))
			.then(function(options){	
				return [{Display:'Clear', Value: null}].concat(_.sortBy(_.unique(_.map(_.filter(options, 
					function(option){ return option[0] !== undefined && option[1] !== undefined; }),
					function(option){ return {Display: option[0], Value: option[1], Record: option[2]}; }),
					function(option){ return option.Value; }),
					function(option){ return grid.sortFn(option.Value, option.Display, option.Record); })); 
			});
		},
		_updateStoreOptions: function(gridStore, valueField, displayField){
			//this is for the select all checkbox for bulk Feature Commitment update to N/A
			//Reset the checkbox if update in store
			$('.x-row-checkbox').prop('checked',false);
			var colFilter = this;
			colFilter._getStoreOptions(gridStore, valueField, displayField).then(function(newComboOptions){
				var comboFilter = colFilter.down(colFilter.filterXtype),
					comboFilterStore = comboFilter.getStore(),
					oldFilterValues = colFilter.getFilterValues(),
					newFilterValues = _.filter(oldFilterValues, function(oldFilterValue){
						return _.find(newComboOptions, function(option){ return option.Value === oldFilterValue; });
					});
				
				comboFilter.store.removeAll();
				comboFilter.store.add(newComboOptions);
				colFilter.setFilterValues(newFilterValues);
			})
			.fail(function(reason){ colFilter.alert('ERROR', reason); })
			.done();
		},
		
		_createGetRowClassIntercepter: function(fn){
			var colFilter = this, column = colFilter.ownerCt;
			
			return function(record){
				var originalCls = (fn || function(){}).apply(null, arguments) || '',
					valueField = colFilter.valueField || column.dataIndex,
					isVisible = !colFilter.filterValues.length || _.any(colFilter.filterValues, function(filterValue){ 
						return colFilter.filterFn(filterValue, record.get(valueField), valueField, record);
					}); 
				if(!isVisible) return originalCls + ' ' + colFilter.hideClass;
				else return originalCls;
			};
		},
		
		_applyToGridView: function(grid, fn, args){
			var view = grid.getView(), lockingPartner = view.lockingPartner;
			view[fn].apply(view, args);
			if(lockingPartner) lockingPartner[fn].apply(lockingPartner, args);
		},
		
		/****************************************PUBLIC METHODS **********************************************/
		applyFilters: function(){
			var colFilter = this,
				column = colFilter.ownerCt,
				grid = colFilter.up('grid'),
				valueField = colFilter.valueField || column.dataIndex;
			_.each(grid.store.getRange(), function(record, index){
				var isVisible = !colFilter.filterValues.length || _.any(colFilter.filterValues, function(filterValue){ 
						return colFilter.filterFn(filterValue, record.get(valueField), valueField, record);
					}); 
				if(isVisible) colFilter._applyToGridView(grid, 'removeRowCls', [index, colFilter.hideClass]); 
				else colFilter._applyToGridView(grid, 'addRowCls', [index, colFilter.hideClass]); 
			});
		},
		getFilterValues: function(){
			return this.filterValues;
		},
		setFilterValues: function(values){
			var colFilter = this,
				comboFilter = colFilter.down(colFilter.filterXtype);
				
			comboFilter.setValue(values);
			colFilter.filterValues = values;
			colFilter.applyFilters();
		},
		clearFilters: function(){
			var colFilter = this,
				grid = colFilter.up('grid'),
				comboFilter = colFilter.down(colFilter.filterXtype),
				recordCount = grid.store.getCount();
				
			comboFilter.setValue();
			colFilter.filterValues = [];
			while(recordCount--) colFilter._applyToGridView(grid, 'removeRowCls', [recordCount, colFilter.hideClass]);
		}
	});
}());
	
                /**
	SUMMARY:
		This override improves performance for sessionStorage proxy mostly by removing redundant page refreshes.
		
		The regular proxy calls record.commit() and later on, datarefresh event is called. since these both cause a rerender, 
		we make the record edits SILENT, so only the datarefresh actually re-render the page
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.component.SessionStorage', {
		extend: 'Ext.data.proxy.SessionStorage',
		alias: ['proxy.intelsessionstorage'],
		constructor: function(cfg) {
			this.callParent(arguments);
		},
		
		create: function(operation, callback, scope) {
			var me = this,
				records = operation.records,
				length = records.length,
				ids = me.getIds(),
				id, record, i;

			operation.setStarted();
			if(me.isHierarchical === undefined) {
					
					
				me.isHierarchical = !!records[0].isNode;
				if(me.isHierarchical) {
					me.getStorageObject().setItem(me.getTreeKey(), true);
				}
			}
			for (i = 0; i < length; i++) {
				record = records[i];

				if (record.phantom) {
					record.phantom = false;
					id = me.getNextId();
				} else {
					id = record.getId();
				}
				
				record.beginEdit();
				me.setRecord(record, id);
				record.endEdit(true); //SILENT!!!
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!
				
				ids.push(id);
			}
			me.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();

			if (typeof callback == 'function') {
				callback.call(scope || me, operation);
			}
		},
		
		update: function(operation, callback, scope) {
			var records = operation.records,
				length = records.length,
				ids = this.getIds(),
				record, id, i;
				
			operation.setStarted();
			for (i = 0; i < length; i++) {
				record = records[i];
				this.setRecord(record);
			
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

				id = record.getId();
				if (id !== undefined && Ext.Array.indexOf(ids, id) == -1) ids.push(id);
			}
			this.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();
			if (typeof callback == 'function') callback.call(scope || this, operation);
		}
	});
}());
                /**
	SUMMARY:
		This override makes the ComponentColumn component much more performant. Edits found using Chrome profiling
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.lib.component.ComponentColumn', {
		extend: 'Skirtle.grid.column.Component',
		alias: 'widget.intelcomponentcolumn',

		autoWidthComponents: false,
		componentGC: true,
		hasCustomRenderer: true,
		lastFrameWidth: 12,		
		constructor: function(cfg) {
			var me = this;
			me.callParent(arguments);
		},
		registerViewListeners: function() {
			var me = this,
				view = me.up('tablepanel').getView();

			me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
			me.mon(view, 'refresh', me.onViewChange, me);
			//me.mon(view, 'itemupdate', me.onViewChange, me); //why are these necessary...
			//me.mon(view, 'itemadd', me.onViewChange, me);
			//me.mon(view, 'itemremove', me.onViewChange, me);
		},
		onViewChange: function() {
			var me = this, tpl = me.tpl;
			me.suspendResizing();
			if (tpl.isCTemplate) {
					tpl.injectComponents();
					tpl.reset();
			}
			//me.redoScrollbars();
			me.resumeResizing();
			me.performGC();
		},		
		resumeResizing: function(){
			var me = this,
				index = 0,
				resizeQueue = me.resizeQueue,
				len = resizeQueue.length;
			if (!--me.resizingSuspended) {
				for ( ; index < len ; ++index) me.resizeChild(resizeQueue[index]);
				me.resizeQueue = null;
				/* if (me.redoScrollbarsRequired) {
						me.redoScrollbars();
				} */
			}
		},
		onChildResize: function() {
			//this.redoScrollbars();
		}
	});
}());
                /**
	SUMMARY:
		performance optimized Ext.data.Store. Improvements found using Chrome Profiling.
		Improvements include removing redundant call to me.sync() which triggers another grid refresh
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.lib.component.Store', {
		extend: 'Ext.data.Store',
		alias: ['store.intelstore'],
		
		afterEdit: function(record, modifiedFieldNames) {
			var me = this, i, shouldSync;
			if (me.autoSync && !me.autoSyncSuspended) {
				for (i = modifiedFieldNames.length; i--;) {
					if (record.fields.get(modifiedFieldNames[i]).persist) {
						me.sync();  //all rendering changes made here
						break;
					}
				}
			}
			me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
			//me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames); //redundant with me.sync()
		}
	});
}());
                /**
	SUMMARY:
		Cell editing has redundant calls to store.afterEdit, which in turn renders the page multiple times per edit. 
		fastcellediting solves this by wrapping all the calls in beginEdit and endEdit, so store.afterEdit is called only once
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.component.CellEditing', {
		extend: 'Ext.grid.plugin.CellEditing',
		alias: ['plugin.intelcellediting'],

		triggerEvent:'cellclick',
		
		onEditComplete : function(ed, value, startValue) {
			var me = this,
				activeColumn = me.getActiveColumn(),
				context = me.context,
				record;
			if (activeColumn) {
				record = context.record;

				me.setActiveEditor(null);
				me.setActiveColumn(null);
				me.setActiveRecord(null);

				context.value = value;
				if (!me.validateEdit()) {
						me.editing = false;
						return;
				}
				record.beginEdit(); //only call store.AfterEdit at the very End 
				if (!record.isEqual(value, startValue)) 
						record.set(activeColumn.dataIndex, value); //dont call store.AfterEdit

				context.view.focusRow(context.rowIdx, 100);
				me.fireEvent('edit', me, context); //dont call store.AfterEdit if record.set() is called in here
				record.endEdit(); //now call store.AfterEdit!
				me.editing = false;
			}
		}
	});
}());
                /**
	SUMMARY:
		Overrides Ext.view.Table to make the scrollbar not jump on grid refreshes. Also it has some 
		permormance optimizations included in it (which should be commented)
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.lib.component.TableView', {
		extend: 'Ext.view.Table',		
		alias: ['widget.inteltableview'],
		
		refresh: function() {
			var me = this,
				targetEl,
				targetParent,
				oldDisplay,
				nextSibling,
				dom,
				records,
				el = me.getEl(), //edit
				scroll = el && el.getScrollTop();//edit
				
			if (!me.rendered || me.isDestroyed) return;

			if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
				targetEl = me.getTargetEl();
				records = me.getViewRange();
				dom = targetEl.dom;
				if (!me.preserveScrollOnRefresh) {
					targetParent = dom.parentNode;
					oldDisplay = dom.style.display;
					dom.style.display = 'none';
					nextSibling = dom.nextSibling;
					targetParent.removeChild(dom);
				}
				if (me.refreshCounter) me.clearViewEl();
				else {
					me.fixedNodes = targetEl.dom.childNodes.length;
					me.refreshCounter = 1;
				}
				me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));

				if (records.length < 1) {
					if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
						Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
					}
					me.all.clear();
				} else {
					me.collectNodes(targetEl.dom);
					me.updateIndexes(0);
				}
				if (me.hasFirstRefresh) {
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					} else {
						me.selModel.pruneIf();
					}
				}
				me.hasFirstRefresh = true;

				if (!me.preserveScrollOnRefresh) {
					targetParent.insertBefore(dom, nextSibling);
					dom.style.display = oldDisplay;
				}

				Ext.suspendLayouts();
				this.refreshSize();
				me.fireEvent('refresh', me);
				Ext.resumeLayouts(true);
				
				if (!me.viewReady) {
					me.viewReady = true;
					me.fireEvent('viewready', me);
				}
			}
			
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		},
		
		onRemove : function(ds, records, indexes) {
			var me = this,
				fireItemRemove = me.hasListeners.itemremove,
				i,
				record,
				index,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.all.getCount()) {
				if (me.dataSource.getCount() === 0) {
					if (fireItemRemove) {
						for (i = indexes.length - 1; i >= 0; --i) {
							me.fireEvent('itemremove', records[i], indexes[i]);
						}
					}
					//me.refresh();
				} else {
					for (i = indexes.length - 1; i >= 0; --i) {
						record = records[i];
						index = indexes[i];
						me.doRemove(record, index);
						if (fireItemRemove) {
							me.fireEvent('itemremove', record, index);
						}
					}
					me.updateIndexes(indexes[0]);
				}
				this.refreshSize();
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onUpdate : function(ds, record){
			var me = this,
				index,
				node,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.viewReady) {
				index = me.dataSource.indexOf(record);
				if (index > -1) {
					node = me.bufferRender([record], index)[0];
					if (me.getNode(record)) {
						me.all.replaceElement(index, node, true);
						me.updateIndexes(index, index);
						me.selModel.onUpdate(record);
						if (me.hasListeners.itemupdate) {
							me.fireEvent('itemupdate', record, index, node);
						}
						return node;
					}
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onAdd : function(store, records, index) {
			var me = this,
				nodes,
				el = me.getEl(),
				scroll = el && el.getScrollTop();

			if (me.rendered) {
				if (me.all.getCount() === 0) {
					me.refresh();
					nodes = me.all.slice();
				} else {
					nodes = me.doAdd(records, index);
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					}
					me.updateIndexes(index);
					//me.refreshSize(); //already being refreshed by store.sync()
				}

				if (me.hasListeners.itemadd) {
					me.fireEvent('itemadd', records, index, nodes);
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},

		scrollRowIntoView: function(row) {
			if(row===0){
				this.getEl().setScrollTop(0);
				return;
			}
			row = this.getNode(row, true);
			if (row) {
				Ext.fly(row).scrollIntoView(this.el, false);
			}
		}
	});
}());
                //TODO: move these models into their own files and name them appropriately (e.g.: Intel.SAFe.lib.model.<model name>)

(function(){
	var Ext = window.Ext4 || window.Ext;
	
	/************************* USED FOR PROGRAM-BOARD VIEW *********************************************/
	Ext.define('IntelVelocity', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Name', type: 'string'},
			{name: 'PlannedVelocity', type: 'number'},
			{name: 'RealVelocity', type:'number'}
		]
	});
	Ext.define('IntelTeamReportMiniDI', {
		extend: 'Ext.data.Model',
		fields: [
				{name: 'title', type: 'string'},
				{name: 'userStories', type: 'number'}
		]
	});	
	Ext.define('IntelTeamCommits', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemMoSCoW', type:'string'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'Commitment', type: 'string'},
			{name: 'Expected', type: 'boolean'},
			{name: 'FeatureStatus', type: 'boolean'},
			{name: 'Objective', type:'string'},
			{name: 'PortfolioItemRank', type: 'number'}
		]
	});

	Ext.define('IntelPredecessorItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PredecessorItemID',  type: 'string'}, 
			{name: 'PredecessorUserStoryObjectID', type: 'number'},
			{name: 'PredecessorProjectObjectID',  type: 'number'},
			{name: 'Supported', type: 'string'},
			{name: 'Assigned', type: 'boolean'} 
		]
	});

	Ext.define('IntelPredecessorDependency', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'UserStoryName',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Plan', type:'string'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		
		
	Ext.define('IntelSuccessorDependency', { 
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'SuccessorUserStoryObjectID', type: 'string' },
			{name: 'SuccessorProjectObjectID', type: 'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'UserStoryName', type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'Description', type: 'string'}, 
			{name: 'NeededBy', type: 'number'},
			{name: 'Supported', type: 'string'}, 
			{name: 'Assigned', type: 'boolean'},
			{name: 'Edited', type: 'boolean'}
		]
	});	

	/************************* USED FOR RISKS/DEPS AND SWIMLANE(RISKS ONLY) VIEW *********************************************/
	Ext.define('IntelPredecessorDependencyForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, 
			{name: 'UserStoryName',  type: 'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Plan', type:'string'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		

	/************************* USED FOR TEAMCOMMITS VIEW *********************************************/
	Ext.define('CommitsMatrixPortfolioItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemRank', type: 'number'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
            {name: 'MoSCoW', type: 'string'}
		]
	});

    /************************* USED FOR ART COMMIT MATRIX ONLY *********************************************/
    Ext.define('CommitsMatrixPortfolioItem2', {
        extend: 'Ext.data.Model',
        fields: [
            {name: 'PortfolioItemObjectID', type: 'number'},
            {name: 'PortfolioItemRank', type: 'number'},
            {name: 'PortfolioItemName', type: 'string'},
            {name: 'PortfolioItemFormattedID', type:'string'},
            {name: 'PortfolioItemPlannedEnd', type:'number'},
            {name: 'TopPortfolioItemName', type:'string'},
            {name: 'FeatureOwner', type:'string'}
        ]
    });
	
	/************************* USED FOR CUSTOM-FIELD EDITOR *********************************************/
	Ext.define('SAFeCustomFieldsEditorModel', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'ItemFormattedID', type:'string'},
			{name: 'ItemName', type:'string'},
			{name: 'ProjectName', type:'string'},
			{name: 'ReleaseName', type:'string'},
			{name: 'CustomFieldValue',  type: 'string'}
		]
	});
}());
                /**
	The Risk Model to be used as a base model for all SAFe Apps.
	Validation should always be handled by this model as well.
	
	This file is the source-of-truth for all things related to the schema and validation of Risks
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		RISK_KEY_PREFIX = 'risk-',
		STATUS_OPTIONS = ['Open', 'WIP', 'Materialized', 'Closed'],
		RISK_LEVEL_OPTIONS = ['High', 'Medium', 'Low'],
		INVALID_MESSAGE = 'is invalid';
	
	/*************************** Risk Custom Validators **********************************/
	Ext.data.validations.RiskIDMessage =                    INVALID_MESSAGE;
	Ext.data.validations.RiskReleaseNameMessage =           INVALID_MESSAGE;
	Ext.data.validations.RiskPortfolioItemObjectIDMessage = INVALID_MESSAGE;
	Ext.data.validations.RiskProjectObjectIDMessage =       INVALID_MESSAGE;
	Ext.data.validations.RiskDescriptionMessage =           INVALID_MESSAGE;
	Ext.data.validations.RiskImpactMessage =                INVALID_MESSAGE;
	Ext.data.validations.RiskMitigationPlanMessage =        INVALID_MESSAGE;
	Ext.data.validations.RiskStatusMessage =                INVALID_MESSAGE;
	Ext.data.validations.RiskLevelMessage =                 INVALID_MESSAGE;
	Ext.data.validations.RiskOwnerObjectIDMessage =         INVALID_MESSAGE;
	Ext.data.validations.RiskSubmitterObjectIDMessage =     INVALID_MESSAGE;
	Ext.data.validations.RiskCheckpointMessage =            INVALID_MESSAGE;
	
	Ext.data.validations.RiskID = function(config, value){
		return typeof value === 'string' && new RegExp('^' + RISK_KEY_PREFIX).test(value);
	};
	Ext.data.validations.RiskReleaseName = function(config, value){
		return typeof value === 'string' && value.length > 0;
	};
	Ext.data.validations.RiskPortfolioItemObjectID = function(config, value){
		return typeof value === 'number' && value > 0;
	};
	Ext.data.validations.RiskProjectObjectID = function(config, value){
		return value === undefined || (typeof value === 'number' && value > 0);
	};
	Ext.data.validations.RiskDescription = function(config, value){
		return typeof value === 'string' && value.length > 0;
	};
	Ext.data.validations.RiskImpact = function(config, value){
		return typeof value === 'string' && value.length > 0;
	};
	Ext.data.validations.RiskMitigationPlan = function(config, value){
		return typeof value === 'string' && value.length > 0;
	};
	Ext.data.validations.RiskStatus = function(config, value){
		return STATUS_OPTIONS.indexOf(value) > -1;
	};
	Ext.data.validations.RiskLevel = function(config, value){
		return RISK_LEVEL_OPTIONS.indexOf(value) > -1;
	};
	Ext.data.validations.RiskOwnerObjectID = function(config, value){
		return typeof value === 'number' && value > 0;
	};
	Ext.data.validations.RiskSubmitterObjectID = function(config, value){
		return typeof value === 'number' && value > 0;
	};
	Ext.data.validations.RiskCheckpoint = function(config, value){
		return typeof value === 'number' && value >= 0;
	};
	
	/*************************** Risk Model Definition **********************************/
	Ext.define('Intel.SAFe.lib.model.Risk', {
		extend: 'Ext.data.Model',
		idProperty: 'RiskID',
		fields: [
			{name: 'RiskID', type:'auto'},
			{name: 'ReleaseName', type:'auto'},
			{name: 'PortfolioItemObjectID', type: 'auto'},
			{name: 'ProjectObjectID', type:'auto', defaultValue: undefined},
			{name: 'Description', type: 'auto'},
			{name: 'Impact', type: 'auto'},	
			{name: 'MitigationPlan', type: 'auto'},
			{name: 'RiskLevel', type: 'auto'},
			{name: 'Status', type: 'auto'},
			{name: 'OwnerObjectID', type: 'auto'},
			{name: 'SubmitterObjectID', type: 'auto'},
			{name: 'Checkpoint', type: 'auto'}
		],
		validations: [
			{type: 'RiskID', field: 'RiskID'},
			{type: 'RiskReleaseName', field: 'ReleaseName'},
			{type: 'RiskPortfolioItemObjectID', field: 'PortfolioItemObjectID'},
			{type: 'RiskProjectObjectID', field: 'ProjectObjectID'},
			{type: 'RiskDescription', field: 'Description'},
			{type: 'RiskImpact', field: 'Impact'},
			{type: 'RiskMitigationPlan', field: 'MitigationPlan'},
			{type: 'RiskStatus', field: 'Status'},
			{type: 'RiskLevel', field: 'RiskLevel'},
			{type: 'RiskOwnerObjectID', field: 'OwnerObjectID'},
			{type: 'RiskSubmitterObjectID', field: 'SubmitterObjectID'},
			{type: 'RiskCheckpoint', field: 'Checkpoint'}
		],
		statics:{
			isValidRiskID: function(riskID){
				return typeof riskID === 'string' && riskID.indexOf(RISK_KEY_PREFIX) === 0;
			},
			getStatusOptions: function(){
				return STATUS_OPTIONS.slice();
			},
			getRiskLevelOptions: function(){
				return RISK_LEVEL_OPTIONS.slice(); 
			}
		}
	});
}());
                /** 
	SUMMARY: 
		CRUD API for Risks. Each Risk has a RiskID. Choose the ID carefully, as it will be very important for querying, and GET, PUT, POST, and DELETE
		all use RiskIDs as the key in the key-value storage. Recommended usage is to name the keys something like: 'risk-<release name>-<unique character hash>'
		
		The risk 'value' is obfuscated because Rally strips html characters from the text, which then breaks JSON. it is obfuscated by using:
		btoa(encodeURIComponent(JSON.stringify(riskJSON, null, '\t')))
		
		this file does not handle schema or validation things for risks -- it only handles the CRUD interface for them. It uses the RiskModel object 
		to do validation
	
	DEPENDENCIES: 
		- Intel.lib.resource.KeyValueDb
		- Intel.SAFe.lib.model.Risk
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		KeyValueDb = Intel.lib.resource.KeyValueDb,
		RiskModel = Intel.SAFe.lib.model.Risk;

	Ext.define('Intel.SAFe.lib.resource.RiskDb', {
		singleton: true,
		
		/** 
			private function. returns error if missing or invalid fields, else returns pruned riskJSON
			returns Promise(riskJSON)
		*/
		_validateRisk: function(riskJSON){
			var model = new RiskModel(riskJSON),
				errors = model.validate();
			if(errors.length) return Q.reject(_.map(errors.getRange(), function(error){ return error.field + ' ' + error.message; }));
			else return Q(model.data);
		},
		
		/** 
			You must call this before you can use it. Not using constructor because we need a promise to be returned.
			returns Promise()
		*/
		initialize: function(){
			return KeyValueDb.initialize();
		},
		
		/** returns Promise(riskJSON) */
		get: function(riskID){
			if(!RiskModel.isValidRiskID(riskID)) return Q.reject('invalid RiskID');
			return KeyValueDb.getKeyValuePair(riskID).then(function(kvPair){
				try { return kvPair ? _.merge(JSON.parse(decodeURIComponent(atob(kvPair.value))), {RiskID: kvPair.key}) : null; }
				catch(e){ return Q.reject(e); }
			});
		},
		
		/** returns Promise( [riskJSON] ) */
		query: function(riskIDContains){
			if(!RiskModel.isValidRiskID(riskIDContains)) return Q.reject('invalid RiskID');
			return KeyValueDb.queryKeyValuePairs(riskIDContains).then(function(kvPairs){
				try { 
					return _.map(kvPairs, function(kvPair){
						return _.merge(JSON.parse(decodeURIComponent(atob(kvPair.value))), {RiskID: kvPair.key});
					});
				}
				catch(e){ return Q.reject(e); }
			});
		},
		
		/** 
			validates the riskJSON and then creates risk if it is unique
			returns Promise(riskJSON) 
		*/
		create: function(riskID, riskJSON){
			if(!RiskModel.isValidRiskID(riskID)) return Q.reject('invalid RiskID');
			return this._validateRisk(_.merge(riskJSON, {RiskID: riskID})).then(function(riskJSON){
				var riskJSONString = btoa(encodeURIComponent(JSON.stringify(riskJSON, null, '\t')));		
				return KeyValueDb.createKeyValuePair(riskID, riskJSONString).then(function(kvPair){
					try { return _.merge(JSON.parse(decodeURIComponent(atob(kvPair.value))), {RiskID: kvPair.key}); }
					catch(e){ return Q.reject(e); }
				});
			});
		},
		
		/** 
			validates the riskJSON and then updates risk if it exists
			returns Promise(riskJSON) 
		*/
		update: function(riskID, riskJSON){
			if(!RiskModel.isValidRiskID(riskID)) return Q.reject('invalid RiskID');
			return this._validateRisk(_.merge(riskJSON, {RiskID: riskID})).then(function(riskJSON){
				var riskJSONString = btoa(encodeURIComponent(JSON.stringify(riskJSON, null, '\t')));	
				return KeyValueDb.updateKeyValuePair(riskID, riskJSONString).then(function(kvPair){
					try { return _.merge(JSON.parse(decodeURIComponent(atob(kvPair.value))), {RiskID: kvPair.key}); }
					catch(e){ return Q.reject(e); }
				});
			});
		},
		
		/** returns Promise(void) */
		'delete': function(riskID){
			if(!RiskModel.isValidRiskID(riskID)) return Q.reject('invalid RiskID');
			return KeyValueDb.deleteKeyValuePair(riskID);
		}
	});
}());
                /** 
	all dependencies are injected (pun intended), it assumes nothing about the app its mixed into other than it has to derive from IntelRallyApp 
	
	TODO: GETRID OF THIS FILE AND MOVE DEPENDENCIES TO DependencyDb which follows suit of RiskDb. A centralized location for dependencies. and a testable
	interface to them.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	var RALLY_MAX_STRING_SIZE = 32768;
	
	Ext.define('Intel.SAFe.lib.mixin.DependenciesLib', {
		requires: ['Intel.lib.IntelRallyApp'],
		
		getDependencies: function(userStoryRecord){
			var dependencies, dependencyString = userStoryRecord.data.c_Dependencies;
			if(dependencyString === '') dependencies = { Predecessors:{}, Successors:{} };
			else {
				try {dependencies = JSON.parse(atob(dependencyString));}
				catch(e) { dependencies = { Predecessors:{}, Successors:{} }; }
			}		
			if(!dependencies.Predecessors || dependencies.Predecessors.constructor.name != 'Object') dependencies.Predecessors = {};
			if(!dependencies.Successors || dependencies.Successors.constructor.name != 'Object') dependencies.Successors = {};
			return dependencies;
		},	
		
		_syncCollection: function(userStoryRecord, depsToAdd, depsToRemove, collectionType){
			/** this function modifies the Predecessor and Successor built in fields on UserStories in Rally to reflect the
				dependencies made in the programBoard. These fields are edited before the c_Dependencies field is saved on the UserStory */
			var me=this, syncDeferred = Q.defer();
			
			depsToAdd = _.filter(depsToAdd, function(objectID){ return !!objectID; });
			depsToRemove = _.filter(depsToRemove, function(objectID){ return !!objectID; });
				
			userStoryRecord.getCollection(collectionType).load({
				fetch:['ObjectID'],
				callback: function(){
					var promises = [],
						syncCollectionProxy = false,
						collectionStore = this,
						collectionRecords = collectionStore.getRange();
					_.each(depsToAdd, function(userStoryObjectID){
						if(!_.find(collectionRecords, function(cr){ return cr.data.ObjectID === userStoryObjectID; })){
							promises.push(me.loadUserStory(userStoryObjectID).then(function(us){
								if(us){ 
									syncCollectionProxy = true; 
									collectionStore.add(us); 
								}
							}));
						}
					});
					_.each(depsToRemove, function(userStoryObjectID){
						var realDep = _.find(collectionRecords, function(cr) { return cr.data.ObjectID === userStoryObjectID; });
						if(realDep) { 
							collectionStore.remove(realDep); 
							syncCollectionProxy = true;
						}
					});
					
					//attempt to sync collection until it passes, 5 == max attempts
					var attempts = 0;
					Q.all(promises)
						.then(function retrySync(){
							if(++attempts > 5){
								me._alert("INFO:", "Failed to modify " + collectionType + " field on " + userStoryRecord.data.FormattedID);
								syncDeferred.resolve();		
							}
							else if(syncCollectionProxy) {
								collectionStore.sync({ 
									failure:function(){ retrySync(); },
									success:function(){ syncDeferred.resolve(); }
								});
							}
							else syncDeferred.resolve();
						})
						.fail(function(reason){ syncDeferred.reject(reason); })
						.done();
				}
			});	
			return syncDeferred.promise;
		},	
		_collectionSynced: function(userStoryRecord, dependencies){
			var me=this, 
				dependenciesString = btoa(JSON.stringify(dependencies, null, '\t')),
				deferred = Q.defer();
			if(dependenciesString.length >= RALLY_MAX_STRING_SIZE) 
				deferred.reject('Dependencies field for ' + userStoryRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				userStoryRecord.set('c_Dependencies', dependenciesString);
				//attempt to save until it passes, 5 == max attempts
				var attempts = 0;
				(function retrySync(){
					if(++attempts > 5) deferred.reject('Failed to modify User Story ' + userStoryRecord.data.FormattedID);
					else {
						userStoryRecord.save({
							callback:function(record, operation, success){
								if(!success) retrySync();
								else deferred.resolve();
							}
						});
					}
				}());
			}
			return deferred.promise;
		},	
		removePredecessor: function(userStoryRecord, predecessorData, currentProjectRecord, dependenciesParsedData){
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Predecessors = dependenciesParsedData.Predecessors || [];
			
			var me=this, 
				dependencies = me.getDependencies(userStoryRecord),
				cachedPredecessors = dependenciesParsedData.Predecessors,
				depsToAdd = [], 
				depsToRemove = [], 
				dependencyID = predecessorData.DependencyID;

			depsToRemove = _.map(dependencies.Predecessors[dependencyID].PredecessorItems || [], function(item){ 
				return item.PredecessorUserStoryObjectID;
			});
			
			delete dependencies.Predecessors[dependencyID];
			
			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedPredecessors = _.filter(cachedPredecessors, function(cachedPredecessor){ 
					return cachedPredecessor.DependencyID !== dependencyID; 
				});
				dependenciesParsedData.Predecessors = cachedPredecessors;
			}
			
			_.each(dependencies.Predecessors, function(predecessor){
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					if(predecessorItem.Assigned){
						depsToRemove = _.filter(depsToRemove, function(userStoryObjectID){ 
							return userStoryObjectID != predecessorItem.PredecessorUserStoryObjectID; 
						});
						depsToAdd = _.union(depsToAdd, [predecessorItem.PredecessorUserStoryObjectID]);
					}
				});
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, depsToRemove, 'Predecessors').then(function(){ 
				return me._collectionSynced(userStoryRecord, dependencies); 
			});
		},	
		removeSuccessor: function(userStoryRecord, successorData, currentProjectRecord, dependenciesParsedData){
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Successors = dependenciesParsedData.Successors || [];
			
			var me=this, 
				dependencies = me.getDependencies(userStoryRecord),
				cachedSuccessors = dependenciesParsedData.Successors,
				depsToAdd = [],
				depsToRemove = [successorData.SuccessorUserStoryObjectID], 
				dependencyID = successorData.DependencyID;
				
			delete dependencies.Successors[dependencyID]; 
			
			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedSuccessors = _.filter(cachedSuccessors, function(cachedSuccessor){ 
					return cachedSuccessor.DependencyID !== dependencyID; 
				});
				dependenciesParsedData.Successors = cachedSuccessors;
			}

			_.each(dependencies.Successors, function(successor){
				if(successor.Assigned){
					depsToRemove = _.filter(depsToRemove, function(userStoryObjectID){ 
						return userStoryObjectID != successor.SuccessorUserStoryObjectID; 
					});
					depsToAdd = _.union(depsToAdd, [successor.SuccessorUserStoryObjectID]);
				}
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, depsToRemove, 'Successors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},
		addPredecessor: function(userStoryRecord, predecessorData, currentProjectRecord, dependenciesParsedData){ 
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Predecessors = dependenciesParsedData.Predecessors || [];
			
			var me=this, 
				dependencies = me.getDependencies(userStoryRecord),
				cachedPredecessors = dependenciesParsedData.Predecessors,
				depsToAdd = [], 
				dependencyID = predecessorData.DependencyID;
			
			predecessorData = Ext.clone(predecessorData);
			predecessorData.Edited = false;
					
			dependencies.Predecessors[dependencyID] = {
				Description: predecessorData.Description,
				NeededBy: predecessorData.NeededBy,
				Plan: predecessorData.Plan,
				Status: predecessorData.Status,
				PredecessorItems: predecessorData.PredecessorItems
			};

			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedPredecessors = _.filter(cachedPredecessors, function(cachedPredecessor){ 
					return cachedPredecessor.DependencyID !== dependencyID; 
				});
				cachedPredecessors.push(predecessorData);
				dependenciesParsedData.Predecessors = cachedPredecessors;
			}

			_.each(dependencies.Predecessors, function(predecessor){ 
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					if(predecessorItem.Assigned) depsToAdd = _.union(depsToAdd, [predecessorItem.PredecessorUserStoryObjectID]);
				});
			});
				
			return me._syncCollection(userStoryRecord, depsToAdd, [], 'Predecessors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},
		addSuccessor: function(userStoryRecord, successorData, currentProjectRecord, dependenciesParsedData){ 
			dependenciesParsedData = dependenciesParsedData || {};
			dependenciesParsedData.Successors = dependenciesParsedData.Successors || [];
			
			var me=this, 
				dependencies = me.getDependencies(userStoryRecord),
				cachedSuccessors = dependenciesParsedData.Successors,
				depsToAdd = [],
				dependencyID = successorData.DependencyID;
			
			successorData = Ext.clone(successorData);
			successorData.Edited = false;
				
			dependencies.Successors[dependencyID] = {
				SuccessorUserStoryObjectID: successorData.SuccessorUserStoryObjectID,
				SuccessorProjectObjectID: successorData.SuccessorProjectObjectID,
				Description: successorData.Description,
				NeededBy: successorData.NeededBy,
				Supported: successorData.Supported,
				Assigned: successorData.Assigned
			};

			if(!currentProjectRecord || (userStoryRecord.data.Project.ObjectID === currentProjectRecord.data.ObjectID)){
				cachedSuccessors = _.filter(cachedSuccessors, function(cachedSuccessor){ 
					return cachedSuccessor.DependencyID !== dependencyID; 
				});
				cachedSuccessors.push(successorData);
				dependenciesParsedData.Successors = cachedSuccessors;
			}

			_.each(dependencies.Successors, function(successor){ 
				depsToAdd = _.union(depsToAdd, [successor.SuccessorUserStoryObjectID]);
			});
			
			return me._syncCollection(userStoryRecord, depsToAdd, [], 'Successors').then(function(){
				return me._collectionSynced(userStoryRecord, dependencies);
			});
		},	
	
		getOldAndNewUserStoryRecords: function(dependencyData, userStoryList){
			var me = this,
				newUserStoryRecord = _.find(userStoryList, function(userStory){
					return userStory.data.FormattedID == dependencyData.UserStoryFormattedID;
				});
				
			function loadOriginalParent(){
				return Q(dependencyData.UserStoryObjectID ? me.loadUserStory(dependencyData.UserStoryObjectID) : null)
				.then(function(oldUserStoryRecord){
					newUserStoryRecord = newUserStoryRecord || oldUserStoryRecord;
					return [oldUserStoryRecord, newUserStoryRecord];
				});
			}
			
			if(newUserStoryRecord){
				return me.loadUserStory(newUserStoryRecord.data.ObjectID).then(function(userStoryRecord){
					newUserStoryRecord = userStoryRecord; 
					return loadOriginalParent();
				});
			} else {
				newUserStoryRecord = null;
				return loadOriginalParent();
			}
		},	
		getPredecessorItemArrays: function(localPredecessorData, realPredecessorData){ 
			/** returns arrays of the team dependencies from the dependency grouped on their status */
			var me=this, 
				addedItemsData = [], 
				updatedItemsData = [], 
				removedItemsData = [], 
				localPredecessorItemsData = localPredecessorData.PredecessorItems || [], 
				realPredecessorItemsData  = realPredecessorData ? (realPredecessorData.PredecessorItems || []) : [];
			if(!realPredecessorItemsData.length) addedItemsData = localPredecessorItemsData;
			else {		
				Outer:
				for(var i=0;i<localPredecessorItemsData.length;++i){
					for(var j=realPredecessorItemsData.length-1;j>=0;--j){
						if(localPredecessorItemsData[i].PredecessorItemID === realPredecessorItemsData[j].PredecessorItemID){
							updatedItemsData.push(realPredecessorItemsData.splice(j,1)[0]);
							continue Outer;
						}
					}
					addedItemsData.push(localPredecessorItemsData[i]); //teams we just added
				}
				removedItemsData = realPredecessorItemsData; //teams that we just removed	(we didn't splice them out of realPredecessorItemsData)
			}
			return {
				added: addedItemsData,
				updated: updatedItemsData,
				removed: removedItemsData
			};
		},	
		/* returns functions that add successor objects to each of the predecessorItems in the dependency */
		getAddedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap, 
				currentProjectRecord, 
				dependenciesParsedData){ 
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						return me.loadRandomUserStoryFromReleaseTimeframe(predecessorProjectRecord, me.ReleaseRecord).then(function(newUserStory){
							if(!newUserStory){
								return Q.reject('Project ' + predecessorProjectRecord.data.Name + ' has no user stories in this Release, cannot continue');
							} else {
								var newSuccessorDependency = {
									DependencyID: predecessorData.DependencyID,
									SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
									SuccessorProjectObjectID: successorProjectRecord.data.ObjectID,
									UserStoryObjectID: newUserStory.data.ObjectID,
									UserStoryFormattedID: '',
									UserStoryName: '',
									Description: predecessorData.Description,
									NeededBy: predecessorData.NeededBy,
									Supported: predecessorItemData.Supported,
									Assigned: false,
									Edited: false
								};
								predecessorItemData.PredecessorUserStoryObjectID = newUserStory.data.ObjectID;
								return me.addSuccessor(newUserStory, newSuccessorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},	
		/* returns functions that update successor objects to each of the predecessorItems in the dependency */
		getUpdatedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			/** NOTE: we dont have to worry about an updated predecessorItem being added to a different predecessor userstory because
				users cannot change the project or userstory of a predecessorItem from the 'dependencies we have on other teams' grid.
				This means we don't have to worry about cloning successor items inside this function
			*/
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						var updatedSuccessorDependency = {
							DependencyID: predecessorData.DependencyID,
							SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
							SuccessorProjectObjectID: successorProjectRecord.data.ObjectID,
							UserStoryObjectID: 0, //need to set this after _loadUserStory
							UserStoryFormattedID: '', //need to set this after _loadUserStory
							UserStoryName: '', //need to set this after _loadUserStory
							Description: predecessorData.Description,
							NeededBy: predecessorData.NeededBy,
							Supported: predecessorItemData.Supported,
							Assigned: false, //need to set this after _loadUserStory
							Edited: false
						};
						return me.loadUserStory(predecessorItemData.PredecessorUserStoryObjectID).then(function(userStory){
							if(!userStory){
								return me.loadRandomUserStoryFromReleaseTimeframe(predecessorProjectRecord, me.ReleaseRecord)
								.then(function(newUserStory){
									if(!newUserStory){
										return Q.reject('Project ' + predecessorProjectRecord.data.Name + ' has no user stories in this Release, cannot continue');
									} else {
										predecessorItemData.PredecessorUserStoryObjectID = newUserStory.data.ObjectID;
										predecessorItemData.Assigned = false;
										
										updatedSuccessorDependency.UserStoryObjectID = newUserStory.data.ObjectID;
										updatedSuccessorDependency.UserStoryFormattedID = '';
										updatedSuccessorDependency.UserStoryName = '';
										updatedSuccessorDependency.Assigned = false;						
										return me.addSuccessor(newUserStory, updatedSuccessorDependency, currentProjectRecord, dependenciesParsedData); 
									}
								});
							} else {
								updatedSuccessorDependency.UserStoryObjectID = userStory.data.ObjectID;
								updatedSuccessorDependency.UserStoryFormattedID = userStory.data.FormattedID;
								updatedSuccessorDependency.UserStoryName = userStory.data.Name;
								updatedSuccessorDependency.Assigned = predecessorItemData.Assigned;
								return me.addSuccessor(userStory, updatedSuccessorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},	
		/* returns functions that remove successor objects for each of the predecessorItems in the dependency */
		getRemovedPredecessorItemCallbacks: function(
				predecessorItemsData, 
				predecessorData, 
				successorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			var me=this, 
				permissions = me.getContext().getPermissions();
			return Q.all(_.map(predecessorItemsData, function(predecessorItemData){
				return function(){
					var predecessorProjectRecord = projectOIDmap[predecessorItemData.PredecessorProjectObjectID];
					if(!permissions.isProjectEditor(predecessorProjectRecord)) 
						return Q.reject('You lack permissions to modify project: ' + predecessorProjectRecord.data.Name);
					else {
						return me.loadUserStory(predecessorItemData.PredecessorUserStoryObjectID).then(function(userStory){
							if(userStory){
								var successorDependency = {
									DependencyID: predecessorData.DependencyID,
									SuccessorUserStoryObjectID: predecessorData.UserStoryObjectID,
									SuccessorProjectObjectID: successorProjectRecord.data.ObjectID,
									UserStoryObjectID: userStory.data.ObjectID,
									UserStoryFormattedID: '',
									UserStoryName: '',
									Description: '',
									NeededBy: 0,
									Supported: '',
									Assigned: predecessorItemData.Assigned,
									Edited: false
								};
								return me.removeSuccessor(userStory, successorDependency, currentProjectRecord, dependenciesParsedData);
							}
						});
					}
				};
			}));
		},
		/* Updates a single PredecessorItem on the successor for a dependency */
		updateSuccessor: function(
				predecessorUserStory, 
				successorData, 
				predecessorProjectRecord, 
				projectOIDmap,
				currentProjectRecord, 
				dependenciesParsedData){
			var me=this, 
				permissions = me.getContext().getPermissions(),
				successorProjectRecord = projectOIDmap[successorData.SuccessorProjectObjectID];
			if(!permissions.isProjectEditor(successorProjectRecord)){
				return Q.reject('You lack permissions to modify project: ' + successorProjectRecord.data.Name);
			} else {
				return me.loadUserStory(successorData.SuccessorUserStoryObjectID).then(function(userStory){
					if(!userStory) return Q.reject({SuccessorDeletedDependency:true, message:'Successor UserStory has been deleted.'});
					else {
						var successorsDependencies = me.getDependencies(userStory),
							successorsDependency = successorsDependencies.Predecessors[successorData.DependencyID];
						if(successorsDependency){
							var predecessorData = {
								DependencyID: successorData.DependencyID,
								UserStoryObjectID: userStory.data.ObjectID,
								UserStoryFormattedID: userStory.data.FormattedID,
								UserStoryName: userStory.data.Name,
								Description: successorsDependency.Description,
								NeededBy: successorsDependency.NeededBy,
								Plan: successorsDependency.Plan,
								Status: successorsDependency.Status,
								PredecessorItems: successorsDependency.PredecessorItems || [], 
								Edited: false
							};
							var predecessorItem = _.find(predecessorData.PredecessorItems, function(predecessorItem){
								return predecessorItem.PredecessorProjectObjectID == predecessorProjectRecord.data.ObjectID;
							});
							if(predecessorItem){
								predecessorItem.PredecessorUserStoryObjectID = predecessorUserStory.data.ObjectID;
								predecessorItem.Supported = successorData.Supported;
								predecessorItem.Assigned = successorData.Assigned;
								return me.addPredecessor(userStory, predecessorData, currentProjectRecord, dependenciesParsedData);
							}
							else return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency.'});
						}
						else return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency.'});
					} 
				});
			}
		}
	});
}());
                /** 
	SUMMARY:
		Configurable Risk Grid that extends rallygrid

	DEPENDENCIES: 
		Intel.lib.resource.KeyValueDb
		Intel.lib.mixin.IntelWorkweek
		Intel.lib.mixin.PrettyAlert
		Intel.lib.component.GridColumnFilter
		Intel.lib.component.UserPicker
		Intel.lib.component.TextArea
		Intel.lib.component.ComboBox
		Intel.lib.component.FixedComboBox
		Intel.lib.component.TableView
		Intel.lib.component.SessionStorage
		Intel.lib.component.CellEditing
		Intel.SAFe.lib.resource.RiskDb
		Intel.SAFe.lib.model.Risk
		risk-grid.css
				
		Font-Awesome
		Q
		lodash
		jquery
		
*/

(function(){
	var RiskDb = Intel.SAFe.lib.resource.RiskDb,
		RiskModel = Intel.SAFe.lib.model.Risk;
		
	Ext.define('Intel.SAFe.lib.component.RiskGrid', {
		extend:'Ext.grid.Panel',
		alias: ['widget.intelriskgrid'], 
		mixins: [
			'Intel.lib.mixin.IntelWorkweek',
			'Intel.lib.mixin.PrettyAlert'
		],
		
		/**________________________________________ DEFAULT CONFIG ________________________________________*/
		cls: 'risk-grid rally-grid',
		scroll:'vertical',
		plugins: ['intelcellediting'],
		viewConfig:{ 
			xtype:'inteltableview',
			preserveScrollOnRefresh:true
		},
		disableSelection: true,
		enableEditing:false,
		
		userCache: {pending:{}},
		risksMap: {},
		projectRecordMap: {},
		portfolioItemRecordMap: {},
		
		/**________________________________________ YOU MUST SUPPLY THESE ________________________________________*/
		releaseRecord: null,
		scrumGroupRootRecord: null,
		topPortfolioItemMap: {},
		projectRecords: [],
		portfolioItemRecords: [],
		portfolioItemType: null,
		topPortfolioItemType: null,
		risks: [],
		visibleColumns: [],
		
		/**________________________________________ INITIALIZE/PRIVATE METHODS ________________________________________*/
		initComponent: function(){
			var grid = this;
			_.each(grid.risks, function(riskJSON){ return grid.risksMap[riskJSON.RiskID] = riskJSON; });
			_.each(grid.projectRecords, function(project){ return grid.projectRecordMap[project.data.ObjectID] = project; });
			_.each(grid.portfolioItemRecords, function(pi){ return grid.portfolioItemRecordMap[pi.data.ObjectID] = pi; });
			grid.columns = grid._getColumns();
			grid.store = grid._getStore();
			grid.header = grid._getHeader();
			grid.listeners = grid._getListeners();
			grid.callParent();
		},
		
		_getColumns: function(){
			var grid = this;
			return {
				defaults: {
					text:'',
					resizable: false,
					draggable: false,
					sortable: false,
					editor: false,
					menuDisabled: true,
					renderer: function(val){ return val || '-'; },
					layout:'hbox'
				},
				items: grid.visibleColumns.map(function(colType){ 
					if(grid['_get' + colType + 'Column']) return grid['_get' + colType + 'Column'](colType); 
					else return {xtype:'displayfield', value:'Invalid: ' + colType};
				})
			};
		},
		_getStore: function(){
			var store = Ext.create('Ext.data.Store', { 
				data: _.map(_.cloneDeep(this.risks), function(risk){ return Ext.create(RiskModel, risk); }),
				model: RiskModel,
				proxy: {
					type:'intelsessionstorage',
					id:'RiskProxy-' + (Math.random()*100000>>0)
				},
				sorters: [function(r1, r2){ return r1.data.RiskID > r2.data.RiskID ? -1 : 1; }]
			});
			store.sync();
			return store;
		},
		_getHeader: function(){
			var grid = this;
			return {
				layout: 'hbox',
				items: [{
					xtype:'text',
					cls:'risk-grid-header-text',
					width:200,
					text:"RISKS"
				},{
					xtype:'container',
					flex:1000,
					layout:{
						type:'hbox',
						pack:'end'
					},
					items:[{
						xtype:'button',
						text:'+ Add New',
						cls: 'add-new-button',
						listeners:{
							click: function(){
								if(!grid.portfolioItemRecords.length) grid.alert('ERROR', 'No ' + grid._getPortfolioItemType() + 's found.');
								else {
									var model = grid._getNewRow();
									_.invoke(Ext.ComponentQuery.query('intelgridcolumnfilter', grid), 'clearFilters');
									grid.store.add(model);
									model.setDirty();
									
									grid.store.fireEvent('refresh', grid.store);
									grid.view.getEl().setScrollTop(0);
									grid._highlightRow(0);
								}
							}
						}
					},{
						xtype:'button',
						text:'Clear Filters',
						cls: 'clear-filters-button',
						listeners:{ 
							click: function(){ 
								_.invoke(Ext.ComponentQuery.query('intelgridcolumnfilter', grid), 'clearFilters'); 
								grid.store.fireEvent('refresh', grid.store);
							}
						}
					}]
				}]
			};
		},
		_getListeners: function(){
			var grid = this;
			return {
				edit: function(editor, e){			
					var grid = e.grid,
						record = e.record,
						field = e.field,
						value = e.value,
						originalValue = e.originalValue;
						
					if(value === originalValue) return; 
					else if(!value) { record.set(field, originalValue); return; }
					else if(['Description', 'Impact', 'MitigationPlan'].indexOf(field)>-1) {
						value = grid._htmlEscape(value);			
						record.set(field, value);
					}
					else if(['OwnerObjectID', 'SubmitterObjectID'].indexOf(field) > -1){
						if(typeof value === 'string') { record.set(field, originalValue); return; } 
					}
				}
			};
		},
		
		_getPortfolioItemFormattedIDColumn: function(){
			var grid = this,
				oidToFID = function(oid){ 
					return grid.portfolioItemRecordMap[oid] ? grid.portfolioItemRecordMap[oid].data.FormattedID : '-'; 
				};
			return {
				text:'#',
				dataIndex:'PortfolioItemObjectID',
				tdCls: 'intel-editor-cell',	
				width:80,
				editor:{
					xtype:'intelcombobox',
					width:80,
					store: grid._getPortfolioItemFIDStore(),
					displayField: 'FormattedID',
					valueField: 'ObjectID'
				},			
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return oidToFID(record.data.PortfolioItemObjectID); }),
				renderer: function(oid){ return oidToFID(oid); },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					sortFn: function(oid, fid){ return fid; },
					convertDisplayFn: function(oid){ return oidToFID(oid); }
				}]
			};
		},
		_getPortfolioItemNameColumn: function(){
			var grid = this,
				oidToName = function(oid){ 
					return grid.portfolioItemRecordMap[oid] ? grid.portfolioItemRecordMap[oid].data.Name : '-'; 
				};
			return {
				text: grid._getPortfolioItemType(),
				dataIndex:'PortfolioItemObjectID',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor:{
					xtype:'intelcombobox',
					flex:1,
					store: grid._getPortfolioItemNameStore(),
					displayField: 'Name',
					valueField: 'ObjectID'
				},			
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return oidToName(record.data.PortfolioItemObjectID); }),
				renderer: function(oid){ return oidToName(oid); },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					sortFn: function(oid, name){ return name; },
					convertDisplayFn: function(oid){ return oidToName(oid); }
				}]
			};
		},
		_getTopPortfolioItemNameColumn: function(){
			var grid = this,
				oidToTopPIName = function(oid){ return grid.topPortfolioItemMap[oid] || '-'; };
			return {
				text: grid._getTopPortfolioItemType(),
				dataIndex:'PortfolioItemObjectID',
				width: 100,		
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return oidToTopPIName(record.data.PortfolioItemObjectID); }),
				renderer: function(oid){ return oidToTopPIName(oid); },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					sortFn: function(topPI){ return topPI; },
					convertDisplayFn: function(oid){ return oidToTopPIName(oid); },
					convertValueFn: function(oid){ return oidToTopPIName(oid); },
					filterFn: function(topPI, oid){ return topPI === oidToTopPIName(oid); }
				}]
			};
		},
		_getOwningProjectColumn: function(){
			var grid = this,
				oidToProjectName = function(oid){ return grid.projectRecordMap[oid] ? grid.projectRecordMap[oid].data.Name : '-'; };
			return {
				text: 'Team',
				dataIndex:'ProjectObjectID',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor:{
					xtype:'intelcombobox',
					flex:1,
					store: grid._getProjectNameStore(),
					displayField: 'Name',
					valueField: 'ObjectID'
				},			
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return oidToProjectName(record.data.ProjectObjectID); }),
				renderer: function(oid){ return oidToProjectName(oid); },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					sortFn: function(oid, name){ return name; },
					convertDisplayFn: function(oid){ return oidToProjectName(oid); }
				}]
			};
		},
		_getDescriptionColumn: function(){
			return {
				text:'Risk Description (If This...)', 
				dataIndex:'Description',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: 'inteltextarea'
			};
		},
		_getImpactColumn: function(){
			return {
				text:'Impact (Then this...)', 
				dataIndex:'Impact',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: 'inteltextarea'
			};
		},
		_getMitigationPlanColumn: function(){
			return {
				text:'Mitigation/ Prevention Plan', 
				dataIndex:'MitigationPlan',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: 'inteltextarea'
			};
		},
		_getStatusColumn: function(){
			var grid = this,
				statusOptions = RiskModel.getStatusOptions();
			return {
				text:'Status',
				dataIndex:'Status',
				tdCls: 'intel-editor-cell',	
				width:100,			
				editor:{
					xtype:'intelfixedcombo',
					store: statusOptions
				},
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return statusOptions.indexOf(record.data.Status); }),
				items:[{ 
					xtype:'intelgridcolumnfilter',
					sortFn: function(status){ return statusOptions.indexOf(status); }
				}]
			};
		},
		_getRiskLevelColumn: function(){
			var grid = this,
				riskLevelOptions = RiskModel.getRiskLevelOptions(),
				displayMap = {
					High: 'High-Staff Help',
					Medium: 'Medium-CE Help',
					Low: 'Low-Team Managed'
				},
				storeOptions = _.map(riskLevelOptions, function(item){ return [item, displayMap[item]]; });
			return {
				text:'Risk Level',
				dataIndex:'RiskLevel',
				tdCls: 'intel-editor-cell',	
				width:100,			
				editor:{
					xtype:'intelfixedcombo',
					store: storeOptions
				},
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ return riskLevelOptions.indexOf(record.data.RiskLevel); }),
				renderer: function(item){ return displayMap[item]; },
				items:[{ 
					xtype:'intelgridcolumnfilter',
					convertDisplayFn: function(item){ return displayMap[item]; },
					sortFn: function(riskLevel){ return riskLevelOptions.indexOf(riskLevel); }
				}]
			};
		},
		_getCheckpointColumn: function(){
			var grid = this;
			return {
				text:'Checkpoint',	
				dataIndex:'Checkpoint',
				tdCls: 'intel-editor-cell',	
				width:90,
				editor:{
					xtype:'intelfixedcombo',
					width:80,
					store: Ext.create('Ext.data.Store', {
						fields: ['DateVal', 'Workweek'],
						data: grid._getWorkweekData()
					}),
					displayField: 'Workweek',
					valueField: 'DateVal'
				},
				sortable:true,
				renderer:function(dateVal){ return dateVal ? 'ww' + grid.getWorkweek(dateVal) : '-'; },	
				items:[{ 
					xtype:'intelgridcolumnfilter',
					convertDisplayFn: function(dateVal){ return dateVal ? 'ww' + grid.getWorkweek(dateVal) : undefined; }
				}]
			};
		},
		_getOwnerColumn: function(){
			var grid = this;
			return {
				text:'Owner', 
				dataIndex:'OwnerObjectID',
				tdCls: 'intel-editor-cell',	
				flex:1,
				editor: {
					xtype: 'inteluserpicker',
					emptyText: 'Select Owner',
					valueField: 'ObjectID'
				}, 
				renderer: function(oid){
					if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
					else {
						var id = Ext.id();
						grid._getUserByObjectID(oid)
							.then(function(user){
								var el = Ext.get(id);
								if(user && el) el.setHTML(grid._formatUserName(user)); 
							})
							.fail(function(reason){ grid.alert('ERROR', reason); })
							.done();
						return '<div id="' + id + '">?</div>';
					}
				},
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ 
					var oid = record.data.OwnerObjectID;
					if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
					else return oid;
				}),
				items:[{ 
					xtype:'intelgridcolumnfilter',
					sortFn: function(oid, name){ return name; },
					convertDisplayFn: function(oid){ 
						if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
						else return grid._getUserByObjectID(oid).then(function(user){ return grid._formatUserName(user); }); 
					}
				}]
			};
		},
		_getSubmitterColumn: function(){
			var grid = this;
			return {
				text:'Submitter', 
				dataIndex:'SubmitterObjectID',
				flex:1,
				renderer: function(oid){
					if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
					else {
						var id = Ext.id();
						grid._getUserByObjectID(oid)
							.then(function(user){ 
								var el = Ext.get(id);
								if(user && el) el.setHTML(grid._formatUserName(user)); 
							})
							.fail(function(reason){ grid.alert('ERROR', reason); })
							.done();
						return '<div id="' + id + '">?</div>';
					}
				},
				sortable:true,
				doSort: grid._makeDoSortFn(function(record){ 
					var oid = record.data.SubmitterObjectID;
					if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
					else return oid;
				}),
				items:[{ 
					xtype:'intelgridcolumnfilter',
					sortFn: function(oid, name){ return name; },
					convertDisplayFn: function(oid){
						if(grid.userCache[oid]) return grid._formatUserName(grid.userCache[oid]);
						else return grid._getUserByObjectID(oid).then(function(user){ return grid._formatUserName(user); }); 
					}
				}]
			};
		},
		_getUndoButtonColumn: function(){
			var grid = this;
			return {
				width:24,
				renderer: function(value, meta, record){
					var id = Ext.id();
					if(!grid._isRiskEdited(record)) return;
					meta.tdAttr = 'title="Undo"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el){
							el.on('click', function(){ 
								record.reject(); 
								grid.store.fireEvent('refresh', grid.store);
							});
						}
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-undo"></i></div>';
				}
			};
		},
		_getSaveButtonColumn: function(){
			var grid = this;
			return {
				width:24,
				renderer: function(value, meta, record){
					var id = Ext.id(), riskID = record.data.RiskID;
					if(!grid._isRiskEdited(record) && !grid._isRiskNew(record)) return;
					meta.tdAttr = 'title="Save Risk"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							grid.setLoading("Saving Risk");
							grid.isEditing = true;
							RiskDb.get(riskID)
								.then(function(realRiskJSON){
									if(realRiskJSON) return RiskDb.update(riskID, _.merge(realRiskJSON, record.getChanges()));
									else return RiskDb.create(riskID, record.data);
								})
								.then(function(newRiskJSON){ 
									record.commit(); 
									grid._highlightRow(grid.store.indexOf(record));
									grid.risks = _.filter(grid.risks, function(r){ return r.RiskID !== riskID; }).concat([newRiskJSON]);
									grid.risksMap[riskID] = newRiskJSON;
								})
								.fail(function(reason){ grid.alert('ERROR', reason); })
								.then(function(){ 
									grid.setLoading(false); 
									grid.isEditing = false;
								})
								.done();
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-floppy-o"></i></div>';
				}
			};
		},
		_getCopyButtonColumn: function(){
			var grid = this;
			return {
				width:24,
				renderer: function(value, meta, record){
					var id = Ext.id(), riskID = record.data.RiskID;
					meta.tdAttr = 'title="Copy Risk"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							grid.setLoading("Copying Risk");
							grid.isEditing = true;
							var currentUserOID = Rally.environment.getContext().getUser().ObjectID;
							RiskDb.create(grid._generateRiskID(), _.merge({}, record.data, {SubmitterObjectID: currentUserOID}))
								.then(function(newRiskJSON){ 
									grid.risks = _.filter(grid.risks, function(r){ return r.RiskID !== newRiskJSON.RiskID; }).concat([newRiskJSON]);
									grid.risksMap[newRiskJSON.RiskID] = newRiskJSON;
									
									var model = Ext.create(RiskModel, newRiskJSON);
									grid.store.add(model);
									model.commit();
										
									grid.store.fireEvent('refresh', grid.store);
									grid.view.getEl().setScrollTop(0);
									grid._highlightRow(0);
								})
								.fail(function(reason){ grid.alert('ERROR', reason); })
								.then(function(){ 
									grid.setLoading(false); 
									grid.isEditing = false;
								})
								.done();
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-copy"></i></div>';
				}
			};
		},
		_getDeleteButtonColumn: function(){
			var grid = this;
			return {
				width:24,
				renderer: function(value, meta, record){
					var id = Ext.id(), riskID = record.data.RiskID;
					meta.tdAttr = 'title="Delete Risk"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							grid.isEditing = true;
							grid.confirm('Delete Risk', 'Are you sure?', function(msg){
								if(msg !== 'yes'){
									grid.isEditing = false;
									return;
								}
								grid.setLoading("Deleting Risk");
								RiskDb['delete'](riskID)
									.then(function(){ 
										grid.store.remove(record);
										grid.store.fireEvent('refresh', grid.store);
										grid.risks = _.filter(grid.risks, function(r){ return r.RiskID !== riskID; });
										delete grid.risksMap[riskID];
									})
									.fail(function(reason){ grid.alert('ERROR', reason); })
									.then(function(){ 
										grid.setLoading(false); 
										grid.isEditing = false;
									})
									.done();
							});
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-trash"></i></div>';
				}
			};
		},
		
		_getNewRow: function(){
			var grid = this;
			return Ext.create(RiskModel, {
				RiskID: grid._generateRiskID(),
				ReleaseName: grid.releaseRecord.data.Name,
				PortfolioItemObjectID: 0,
				ProjectObjectID: grid.projectRecords.length === 1 ? grid.projectRecords[0].data.ObjectID : 0,
				Description: '',
				Impact: '',
				MitigationPlan: '',
				RiskLevel: '',
				Status: '',
				OwnerObjectID: 0,
				SubmitterObjectID: Rally.environment.getContext().getUser().ObjectID,
				Checkpoint: 0
			});
		},
		_makeDoSortFn: function(fn){
			var grid = this;
			return function(direction){
				grid.store.sort({
					sorterFn: function(r1, r2){
						var val1 = fn(r1), val2 = fn(r2);
						return (direction=='ASC' ? 1 : -1) * ((val1 < val2) ? -1 : (val1 === val2 ? 0 : 1));
					}
				});
			};
		},
		_getPortfolioItemType: function(){
			return this.portfolioItemType || 
				(this.portfolioItemRecords.length ? this.portfolioItemRecords[0].data._type.split('/')[1] : 'PortfolioItem');
		},
		_getTopPortfolioItemType: function(){
			return this.topPortfolioItemType || 'PortfolioItem';
		},
		_getWorkweekData: function(){
			return this.getWorkweeksForDropdown(this.releaseRecord.data.ReleaseStartDate, this.releaseRecord.data.ReleaseDate);
		},
		_getPortfolioItemFIDStore: function(){
			var grid = this;
			return  Ext.create('Ext.data.Store', {
				fields: ['FormattedID', 'ObjectID'],
				data: _.sortBy(_.map(grid.portfolioItemRecords,
					function(record){ return {FormattedID: record.data.FormattedID, ObjectID: record.data.ObjectID}; }),
					function(item){ return item.FormattedID; })
			});
		},
		_getPortfolioItemNameStore: function(){
			var grid = this;
			return Ext.create('Ext.data.Store', {
				fields: ['Name', 'ObjectID'],
				data: _.sortBy(_.map(grid.portfolioItemRecords,
					function(record){ return {Name: record.data.Name, ObjectID: record.data.ObjectID}; }),
					function(item){ return item.Name; })
			});
		},
		_getProjectNameStore: function(){
			var grid = this;
			return Ext.create('Ext.data.Store', {
				fields: ['Name', 'ObjectID'],
				data: _.sortBy(_.map(grid.projectRecords,
					function(record){ return {Name: record.data.Name, ObjectID: record.data.ObjectID}; }),
					function(item){ return item.Name; })
			});
		},
		_htmlEscape: function(str) {
			return String(str)
				//.replace(/&/g, '&amp;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&#39;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;');
		},	
		_getUserByObjectID: function(oid){
			var grid = this;
			if(grid.userCache[oid]) return Q(grid.userCache[oid]);
			else if(grid.userCache.pending[oid]) return grid.userCache.pending[oid];
			else {
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store',{
						model: 'User',
						autoLoad: true,
						fetch: ['ObjectID', 'FirstName', 'LastName', 'UserName'],
						context: Rally.environment.getContext().getDataContext(),
						filters: [{ property:'ObjectID', value:oid }],
						listeners: { 
							load: function(store){ 
								grid.userCache[oid] = store.first();
								delete grid.userCache.pending[oid];
								return deferred.resolve(grid.userCache[oid]); 
							} 
						}
					});
				grid.userCache.pending[oid] = deferred.promise;
				return deferred.promise;
			}
		},
		_formatUserName: function(userRecord){
			return userRecord ? ((userRecord.data.LastName + ', ' + userRecord.data.FirstName) || userRecord.data.UserName) : '?';
		},
		_generateRiskID: function(){
			return 'risk-' + this.releaseRecord.data.Name + '-' + 
				this.scrumGroupRootRecord.data.ObjectID + '-' + 
				(new Date()*1 + '' + (Math.random()*10000 >> 0));
		},
		_isRiskEdited: function(riskRecord){
			return this.risksMap[riskRecord.data.RiskID] && riskRecord.dirty;
		},
		_isRiskNew: function(riskRecord){
			return !this.risksMap[riskRecord.data.RiskID] && riskRecord.dirty;
		},
		_highlightRow: function(index){
			var grid = this;
			Ext.fly(this.getView().getNode(index)).highlight("8dc63f", { attr: 'backgroundColor', duration: 1500 });
		},
		
		/**________________________________________ PUBLIC METHODS ________________________________________*/
		syncRisks: function(realRisks){
			/** NOTE: this function will NOT remove any pending edits or new risks in the grid */
			var grid = this, 
				store = grid.getStore(),
				riskRecords = store.getRange(),
				realRisksMap = _.reduce(realRisks, function(map, risk){ map[risk.RiskID] = risk; return map; }, {}),
				newOrEditedRecords = [];

			if(grid.hasPendingEdits()) return;
			else {
				grid.setLoading('Updating Risks');
				grid.risks = _.cloneDeep(realRisks);
				grid.risksMap = _.cloneDeep(realRisksMap);
				
				_.each(riskRecords, function(riskRecord){
					var realRisk = realRisksMap[riskRecord.data.RiskID];
					delete realRisksMap[riskRecord.data.RiskID];
					
					if(!realRisk) store.remove(riskRecord);
					else if(_.any(realRisk, function(value, field){ return !_.isEqual(riskRecord.data[field], value); })){
						_.each(realRisk, function(value, field){ riskRecord.set(field, value); });
						newOrEditedRecords.push(riskRecord);
					}
				});
				_.each(realRisksMap, function(realRisk){ 
					var model = Ext.create(RiskModel, realRisk); 
					store.add(model);
					newOrEditedRecords.push(model);
				});
				store.sync();
				store.fireEvent('refresh', grid.store);
				
				grid.setLoading(false);
				setTimeout(function(){ 
					_.each(newOrEditedRecords, function(record){ grid._highlightRow(store.indexOf(record)); });
				}, 20);
			}
		},
		hasPendingEdits: function(){
			var grid = this;
			if(grid.isEditing || grid.editingPlugin.activeEditor) return true;
			return _.some(grid.store.getRange(), function(record){ return grid._isRiskNew(record) || grid._isRiskEdited(record); });
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext,
		RiskDb = Intel.SAFe.lib.resource.RiskDb,
		RALLY_MAX_STRING_SIZE = 32768,
		COLUMN_DEFAULTS = {
			text:'',
			resizable: false,
			draggable: false,
			sortable: false,
			editor: false,
			menuDisabled: true,
			renderer: function(val){ return val || '-'; },
			layout: 'hbox'
		};
		
	Ext.define('Intel.SAFe.RisksDepsTracking', {
		extend: 'Intel.lib.IntelRallyApp',
		mixins:[
			'Intel.lib.mixin.WindowListener',
			'Intel.lib.mixin.PrettyAlert',
			'Intel.lib.mixin.IframeResize',
			'Intel.lib.mixin.IntelWorkweek',
			'Intel.lib.mixin.AsyncQueue',
			'Intel.lib.mixin.ParallelLoader',
			'Intel.lib.mixin.UserAppsPreference',
			'Intel.SAFe.lib.mixin.DependenciesLib'
		],
		
		layout: {
			type:'vbox',
			align:'stretch',
			pack:'start'
		},
		items:[{
			xtype:'container',
			height:45,
			id:'navbox',
			layout: {
				type:'hbox',
				align:'stretch',
				pack:'start'
			},
			items:[{
				xtype:'container',
				flex:3,
				id:'navboxLeft',
				layout: {
					type:'hbox'
				}
			},{
				xtype:'container',
				flex:2,
				id:'navboxRight',
				layout: {
					type:'hbox',
					pack:'end'
				}
			}]
		}],
		minWidth:1100, 
		
		userAppsPref: 'intel-SAFe-apps-preference',
			
		/**___________________________________ DATA STORE METHODS ___________________________________*/
		loadPortfolioItems: function(){ 
			var me=this;
			return Q.all(_.map(me.PortfolioItemTypes, function(type, ordinal){
				return (ordinal ? //only load lowest portfolioItems in Release (upper porfolioItems don't need to be in a release)
					me.loadPortfolioItemsOfType(me.ScrumGroupPortfolioProject, type) : 
					me.loadPortfolioItemsOfTypeInRelease(me.ReleaseRecord, me.ScrumGroupPortfolioProject, type)
				);
			}))
			.then(function(portfolioItemStores){
				me.PortfolioItemStore = portfolioItemStores[0];
				me.PortfolioItemMap = me.createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap(portfolioItemStores);
			});
		},
		getUserStoryFilter: function(){
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0];
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.Name',
				value: me.ReleaseRecord.data.Name
			}).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
				Ext.create('Rally.data.wsapi.Filter', {
					property: lowestPortfolioItem + '.Release.Name',
					value: me.ReleaseRecord.data.Name
				}))
			);
		},
		loadUserStories: function(){	
			/** what this function should REALLY do is return the user stories that contribute to this scrum group's portfolio, regardless of project */
			var me=this, 
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				config = {
					model:'HierarchicalRequirement',
					filters: [me.getUserStoryFilter()],
					fetch:['Name', 'ObjectID', 'Project', 'Release', 'FormattedID', lowestPortfolioItem, 'c_Dependencies'],
					context: {
						project:me.ScrumGroupRootRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				};
			return me.parallelLoadWsapiStore(config).then(function(store){
				me.UserStoryStore = store;
				return store;
			});
		},
	
		/**___________________________________ RISKS STUFF___________________________________**/
		loadRisks: function(){
			var me = this;
			return RiskDb.query('risk-' + this.ReleaseRecord.data.Name + '-' + this.ScrumGroupRootRecord.data.ObjectID + '-')
				.then(function(risks){ me.Risks = risks; });
		},
		
		/**___________________________________ DEPENDENCIES STUFF ___________________________________	**/
		isUserStoryInRelease: function(userStoryRecord, releaseRecord){ 
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0];
			return ((userStoryRecord.data.Release || {}).Name === releaseRecord.data.Name) || 
				(!userStoryRecord.data.Release && ((userStoryRecord.data[lowestPortfolioItem] || {}).Release || {}).Name === releaseRecord.data.Name);
		},	
		spliceDependencyFromList: function(dependencyID, dependencyList){ 
			for(var i = 0; i<dependencyList.length; ++i){
				if(dependencyList[i].DependencyID == dependencyID) {
					return dependencyList.splice(i, 1)[0];
				}
			}
		},
		parseDependenciesFromUserStory: function(userStoryRecord){
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				dependencies = me.getDependencies(userStoryRecord), 
				inputPredecessors = dependencies.Predecessors, 
				inputSuccessors = dependencies.Successors,
				outputPredecessors = [], 
				outputSuccessors = [],
				UserStoryObjectID = userStoryRecord.data.ObjectID,
				UserStoryFormattedID = userStoryRecord.data.FormattedID,
				UserStoryName = userStoryRecord.data.Name,
				TopPortfolioItemName = me.PortfolioItemMap[(userStoryRecord.data[lowestPortfolioItem] || {}).ObjectID] || '',
				ProjectObjectID = (userStoryRecord.data.Project || {}).ObjectID || 0;

			if(me.isUserStoryInRelease(userStoryRecord, me.ReleaseRecord)){
				_.each(inputPredecessors, function(predecessorDependency, dependencyID){
					outputPredecessors.push({
						DependencyID: dependencyID,
						UserStoryObjectID: UserStoryObjectID,
						UserStoryFormattedID: UserStoryFormattedID,
						UserStoryName: UserStoryName,
						TopPortfolioItemName: TopPortfolioItemName,
						ProjectObjectID: ProjectObjectID,
						Description: predecessorDependency.Description,
						NeededBy: predecessorDependency.NeededBy,
						Plan: predecessorDependency.Plan,
						Status: predecessorDependency.Status,
						PredecessorItems: predecessorDependency.PredecessorItems || [], 
						Edited: false 
					});
				});
			}

			_.each(inputSuccessors, function(successorDependency, dependencyID) {
				if(!successorDependency.Assigned) {
					UserStoryObjectID = UserStoryName = '';
				}

				outputSuccessors.push({
					DependencyID: dependencyID,
					TeamDependsOn: userStoryRecord.data.Project.Name,
					SuccessorUserStoryObjectID: successorDependency.SuccessorUserStoryObjectID,
					SuccessorProjectObjectID: successorDependency.SuccessorProjectObjectID,
					UserStoryObjectID: UserStoryObjectID,
					UserStoryFormattedID: UserStoryFormattedID,
					UserStoryName: UserStoryName,
					Description: successorDependency.Description,
					NeededBy: successorDependency.NeededBy,
					Supported: successorDependency.Supported,
					Assigned: successorDependency.Assigned,
					Edited: false
				});
			});
			
			return {Predecessors:outputPredecessors, Successors:outputSuccessors};
		},
		parseDependenciesData: function(userStories){	
			var me=this, 
				predecessors = [], 
				successors = [],	
				predecessorProjIDs = {},
				predecessorUserStoryIDs = {};		
			
			_.each(userStories, function(userStoryRecord){
				var dependenciesData = me.parseDependenciesFromUserStory(userStoryRecord);
				predecessors = predecessors.concat(dependenciesData.Predecessors);
				successors = successors.concat(dependenciesData.Successors);
			});
			predecessorProjIDs = _.indexBy(predecessors, function(item) {
				return item.ProjectObjectID;
			});
			predecessorUserStoryIDs = _.indexBy(predecessors, function(item) {
				return item.UserStoryObjectID;
			});
			successors = _.filter(successors, function(item) {
				return predecessorProjIDs[item.SuccessorProjectObjectID] === undefined && 
						predecessorUserStoryIDs[item.SuccessorUserStoryObjectID] === undefined;
			});

			return {Predecessors:predecessors, Successors:successors};
		},		
		getRealDependencyData: function(oldUserStoryRecord, dependencyID, type){ 
			/** type is 'Predecessors' or 'Successors' */
			var me = this, realDependencyData;
			if(oldUserStoryRecord) realDependencyData = me.parseDependenciesFromUserStory(oldUserStoryRecord)[type];
			else realDependencyData = [];
			return me.spliceDependencyFromList(dependencyID, realDependencyData) || null;		
		},
		hydrateDependencyUserStories: function(dependenciesParsedData){
			var me=this, 
				storyOIDsToHydrate = [],
				dependenciesHydratedUserStories = {};

			_.each(dependenciesParsedData.Predecessors, function(predecessor){
				_.each(predecessor.PredecessorItems, function(predecessorItem){
					storyOIDsToHydrate.push(predecessorItem.PredecessorUserStoryObjectID);
				});
			});

			_.each(dependenciesParsedData.Successors, function(successor) {
				storyOIDsToHydrate.push(successor.SuccessorUserStoryObjectID);
			});
			
			return Q.all(_.map(storyOIDsToHydrate, function(storyOID){
				return me.loadUserStory(storyOID).then(function(userStory){
					if(userStory) dependenciesHydratedUserStories[storyOID] = userStory;
				});
			}))
			.then(function(){ return dependenciesHydratedUserStories; });
		},
		
		/**___________________________________ MISC HELPERS ___________________________________*/		
		htmlEscape: function(str) {
			return String(str)
				//.replace(/&/g, '&amp;')
				.replace(/"/g, '&quot;')
				.replace(/'/g, '&#39;')
				.replace(/</g, '&lt;')
				.replace(/>/g, '&gt;');
		},	
		getDirtyType: function(localRecord, realDataFromServer){ 
			/** if risk or dep record is new/edited/deleted/unchanged */
			if(!realDataFromServer)	return localRecord.data.Edited ? 'New' : 'Deleted'; //we just created the item, or it was deleted by someone else
			else return localRecord.data.Edited ? 'Edited' : 'Unchanged'; //we just edited the item, or it is unchanged
		},
		updateUserStoryColumnStores: function(){ 
			/** updates the dropdown stores with the most recent user stories in the release (in case some were added */
			var me = this, userStories = me.UserStoriesInRelease;
			if(me.UserStoryFIDStore){
				me.UserStoryFIDStore.removeAll();
				_.each(userStories, function(userStory){
					me.UserStoryFIDStore.add({'FormattedID': userStory.data.FormattedID});
				});
			}
			if(me.UserStoryNameStore){
				me.UserStoryNameStore.removeAll();
				_.each(userStories, function(userStory){
					me.UserStoryNameStore.add({'Name': userStory.data.Name});
				});
			}
		},	
		
		/**___________________________________ LOADING AND RELOADING ___________________________________*/
		isEditing: function(grid){
			if(!grid || !grid.store) return false;
			if(grid.editingPlugin && grid.editingPlugin.activeEditor) return true;
			return _.some(grid.store.getRange(), function(record){ return record.data.Edited; });
		},			
		showGrids: function(){
			var me=this;
			if(!me.RisksGrid){
				me.renderRisksGrid();
				me.renderDependenciesGrids();
			}
		},	
		checkForDuplicates: function(){ 
			/** duplicates are in a list of groups of duplicates for each type */
			var me=this,
				deferred = Q.defer(),
				duplicatePredecessors = _.filter(_.groupBy(me.DependenciesParsedData.Predecessors,
					function(dependency) { return dependency.DependencyID; }),
					function(list, dependencyID) { return list.length > 1; });
				duplicateSuccessors = _.filter(_.groupBy(me.DependenciesParsedData.Successors,
					function(dependency) { return dependency.DependencyID; }),
					function(list, dependencyID) { return list.length > 1; });
			if(duplicatePredecessors.length || duplicateSuccessors.length){
				me.renderResolveDuplicatesModal(duplicatePredecessors, duplicateSuccessors)
					.then(function(){ 
						me.clearEverything();
						me.setLoading('Loading Data');
						return me.reloadStores(); 
					})
					.then(function(){ return me.updateGrids(); })
					.then(function(){ me.setLoading(false); })
					.then(function(){ deferred.resolve(); })
					.fail(function(reason){ deferred.reject(reason); })
					.done();
			} 
			else deferred.resolve();
			
			return deferred.promise;
		},
		updateGrids: function(){
			var me=this,
				promises = [],
				isEditingDeps = me.isEditing(me.CustomPredecessorStore);
			if(me.RisksGrid && !me.RisksGrid.hasPendingEdits()) me.RisksGrid.syncRisks(me.Risks);
			if(!isEditingDeps && me.UserStoryStore && me.PortfolioItemStore){		

				me.UserStoriesInRelease = _.filter(me.UserStoryStore.getRange(), function(userStoryRecord){ 
					return me.isUserStoryInRelease(userStoryRecord, me.ReleaseRecord); 
				});
				me.DependenciesParsedData = me.parseDependenciesData(me.UserStoryStore.getRange());
				promises.push(me.hydrateDependencyUserStories(me.DependenciesParsedData).then(function(dependenciesHydratedUserStories){
					me.DependenciesHydratedUserStories = dependenciesHydratedUserStories;
					me.updateUserStoryColumnStores();
					if(me.PredecessorGrid && me.PredecessorGrid.store) me.PredecessorGrid.store.intelUpdate();
					if(me.SuccessorGrid && me.SuccessorGrid.store) me.SuccessorGrid.store.intelUpdate();
				}));
			}
			return Q.all(promises);
		},	
		reloadStores: function(){
			var me=this,
				isEditingDeps = me.isEditing(me.PredecessorGrid),
				promises = [];
			promises.push(me.loadRisks());
			promises.push(me.loadPortfolioItems());
			if(!isEditingDeps) promises.push(me.loadUserStories());
			return Q.all(promises);
		},
		clearEverything: function(){
			var me=this;
			
			me.PortfolioItemMap = {};
			
			me.UserStoryStore = undefined;
			me.PortfolioItemStore = undefined;
			
			me.PredecessorGrid = undefined;
			me.SuccessorGrid = undefined;
			me.RisksGrid = undefined;

			var toRemove = me.down('#navbox').next(), tmp;
			while(toRemove){ //delete risks and dependencies 
				tmp = toRemove.next();
				toRemove.up().remove(toRemove);
				toRemove = tmp;
			}
		},
		reloadEverything:function(){
			var me = this;
			
			me.clearEverything();
			me.setLoading('Loading Data');
			if(!me.ReleasePicker){ //draw these once, never remove them
				me.renderReleasePicker();
				me.renderManualRefreshButton();
			}		
			me.enqueue(function(unlockFunc){	
				me.reloadStores()
					.then(function(){ return me.updateGrids(); })
					//.then(function(){ return me.checkForDuplicates(); })
					.then(function(){ return me.showGrids(); })
					.fail(function(reason){	me.alert('ERROR', reason); })
					.then(function(){
						unlockFunc();
						me.setLoading(false); 
					})
					.done();
			}, 'Queue-Main');
		},
		
		/**___________________________________ REFRESHING DATA ___________________________________*/	
		setLoadingMasks: function(){
			var me=this, message = 'Refreshing Data',
				isEditingDeps = me.isEditing(me.PredecessorGrid) || me.isEditing(me.SuccessorGrid);			
			if(me.RisksGrid && !me.RisksGrid.hasPendingEdits()) me.RisksGrid.setLoading(message);
			if(me.PredecessorGrid && !isEditingDeps) me.PredecessorGrid.setLoading(message);
			if(me.SuccessorGrid && !isEditingDeps) me.SuccessorGrid.setLoading(message);
		},	
		removeLoadingMasks: function(){
			var me=this,
				isEditingDeps = me.isEditing(me.PredecessorGrid) || me.isEditing(me.SuccessorGrid);		
			if(me.RisksGrid && !me.RisksGrid.hasPendingEdits()) me.RisksGrid.setLoading(false);
			if(me.PredecessorGrid && !isEditingDeps) me.PredecessorGrid.setLoading(false);
			if(me.SuccessorGrid && !isEditingDeps) me.SuccessorGrid.setLoading(false);
		},	
		refreshDataFunc: function(){
			var me=this;
			me.setLoadingMasks();
			me.enqueue(function(unlockFunc){
				me.reloadStores()
					.then(function(){ return me.updateGrids(); })
					//.then(function(){ return me.checkForDuplicates(); })
					.then(function(){ return me.showGrids(); })
					.fail(function(reason){ me.alert('ERROR', reason); })
					.then(function(){ 
						unlockFunc();
						me.removeLoadingMasks();
					})
					.done();
			}, 'Queue-Main');
		},	

		/**___________________________________ LAUNCH ___________________________________*/
		launch: function(){
			var me=this;
			me.setLoading('Loading Configuration');
			// me.initDisableResizeHandle();
			// me.initFixRallyDashboard();
			if(!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())) { //permission check
				me.setLoading(false);
				me.alert('ERROR', 'You do not have permissions to edit this project');
				return;
			} 
			me.configureIntelRallyApp()
				.then(function(){
					var scopeProject = me.getContext().getProject();
					return me.loadProject(scopeProject.ObjectID);
				})
				.then(function(scopeProjectRecord){
					me.ProjectRecord = scopeProjectRecord;
					return Q.all([ // 3 streams
						me.loadProjectsWithTeamMembers() /********* 1 ************/
							.then(function(projectsWithTeamMembers){
								me.ProjectsWithTeamMembers = projectsWithTeamMembers;
								me.ProjectNames = _.map(projectsWithTeamMembers, function(project){ return {Name: project.data.Name}; });
							}),
						me.projectInWhichScrumGroup(me.ProjectRecord) /********* 2 ************/
							.then(function(scrumGroupRootRecord){
								if(scrumGroupRootRecord && me.ProjectRecord.data.ObjectID == scrumGroupRootRecord.data.ObjectID){
									me.ScrumGroupRootRecord = scrumGroupRootRecord;
									return me.loadScrumGroupPortfolioProject(me.ScrumGroupRootRecord)
										.then(function(scrumGroupPortfolioProject){
											me.ScrumGroupPortfolioProject = scrumGroupPortfolioProject;
										});
								} 
								else return Q.reject('You are not scoped to a valid project!');
							}),
						me.loadAppsPreference() /********* 3 ************/
							.then(function(appsPref){
								me.AppsPref = appsPref;
								var twelveWeeks = 1000*60*60*24*7*12;
								return me.loadReleasesAfterGivenDate(me.ProjectRecord, (new Date()*1 - twelveWeeks));
							})
							.then(function(releaseRecords){
								me.ReleaseRecords = releaseRecords;
								var currentRelease = me.getScopedRelease(releaseRecords, me.ProjectRecord.data.ObjectID, me.AppsPref);
								if(currentRelease){
									me.ReleaseRecord = currentRelease;
									me.WorkweekData = me.getWorkweeksForDropdown(currentRelease.data.ReleaseStartDate, currentRelease.data.ReleaseDate);
								}
								else return Q.reject('This project has no releases.');
							}),
						RiskDb.initialize()
					]);
				})
				.then(function(){ return me.reloadEverything(); })
				.fail(function(reason){
					me.setLoading(false);
					me.alert('ERROR', reason);
				})
				.done();
		},
		
		/**___________________________________ NAVIGATION AND STATE ___________________________________*/
		releasePickerSelected: function(combo, records){
			var me=this, pid = me.ProjectRecord.data.ObjectID;
			if(me.ReleaseRecord.data.Name === records[0].data.Name) return;
			me.setLoading("Saving Preference");
			me.ReleaseRecord = _.find(me.ReleaseRecords, function(rr){ return rr.data.Name == records[0].data.Name; });
			me.WorkweekData = me.getWorkweeksForDropdown(me.ReleaseRecord.data.ReleaseStartDate, me.ReleaseRecord.data.ReleaseDate);
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
			me.saveAppsPreference(me.AppsPref)
				.then(function(){ me.reloadEverything(); })
				.fail(function(reason){ me.alert('ERROR', reason); })
				.then(function(){ me.setLoading(false); })
				.done();
		},				
		renderReleasePicker: function(){
			var me=this;
			me.ReleasePicker = me.down('#navboxLeft').add({
				xtype:'intelreleasepicker',
				id: 'releasePicker',
				releases: me.ReleaseRecords,
				currentRelease: me.ReleaseRecord,
				listeners: {
					change:function(combo, newval, oldval){ if(newval.length===0) combo.setValue(oldval); },
					select: me.releasePickerSelected.bind(me)
				}
			});
		},	
		renderManualRefreshButton: function(){
			var me=this;
			me.down('#navboxRight').add({
				xtype:'button',
				id: 'manualRefreshButton',
				text:'Refresh Data',
				cls:'intel-button',
				listeners:{
					click: me.refreshDataFunc.bind(me)
				}
			});
		},
		
		/**___________________________________ RENDER RESOLVE DUPLICATES ___________________________________*/	
		renderResolveDuplicatesModal: function(duplicatePredecessors, duplicateSuccessors){
			var me=this,
				deferred = Q.defer(),	
				modal = Ext.create('Ext.window.Window', {
					modal:true,
					closable:false,
					title:'ERROR: Duplicate Dependencies!',
					cls:'duplicates-modal',
					overflowY: 'scroll',
					resizable: true,
					height:me.getHeight()*0.9>>0,
					width:Math.min(900, me.getWidth()*0.9>>0),
					y:5,
					items: [{
						xtype:'container',
						html:'<p>Use the checkboxes to select which of the duplicates you want to keep. ' + 
							'You have to keep exactly 1 of the duplicates. When you have finished, click Done.</p><br/>',
						manageHeight:false
					}].concat(duplicatePredecessors.length ? [{
							xtype:'container',
							html:'<h2 class="grid-group-header">Duplicate Predecessors</h2>',
							manageHeight:false
						}].concat(_.map(duplicatePredecessors, function(predecessorsOfOneID){
							return {
								xtype:'grid',
								cls: 'risksdeps-grid duplicate-predecessors-grid rally-grid',
								columns: [{
									text:'#', 
									dataIndex:'UserStoryFormattedID',
									width:90,
									sortable:true
								},{
									text:'UserStory', 
									dataIndex:'UserStoryName',
									flex:1,	
									sortable:true
								},{
									text:'Team', 
									dataIndex:'ProjectObjectID',
									flex:1,
									minWidth:100,
									sortable:true,
									renderer:function(projectObjectID){
										return ((me.ProjectsWithTeamMembers[projectObjectID] || {}).data || {}).Name || '?';
									}
								},{
									text:'Dependency Description', 
									dataIndex:'Description',
									flex:1	
								},{
									text:'Needed By',			
									dataIndex:'NeededBy',
									width:90,
									sortable:true,
									renderer: function(date){ return (date ? 'ww' + me.getWorkweek(date) : '-');}
								},{
									text:'Teams Depended On',
									dataIndex:'DependencyID',
									xtype:'intelcomponentcolumn',
									html:	'<div class="predecessor-items-grid-header" style="width:10px !important;"></div>' +
											'<div class="predecessor-items-grid-header" style="width:110px !important;">Team Name</div>' +
											'<div class="predecessor-items-grid-header" style="width:95px  !important;">Supported</div>' +
											'<div class="predecessor-items-grid-header" style="width:70px  !important;">#</div>' +
											'<div class="predecessor-items-grid-header" style="width:130px !important;">User Story</div>',
									width:420,
									renderer: function(dependencyID, meta, record, rowIndex){
										var swallowEventHandler = {
											element: 'el',
											fn: function(a){ a.stopPropagation(); }
										};
										var predecessorItemColumnCfgs = [{
											dataIndex:'PredecessorProjectObjectID',
											width:115,
											renderer: function(val, meta){
												var projectRecord = me.ProjectsWithTeamMembers[val];
												if(val && projectRecord) return projectRecord.data.Name;
												else return '-';
											}
										},{
											dataIndex:'Supported',
											width:80,
											renderer: function(val, meta){
												if(val == 'No') meta.tdCls = 'predecessor-item-not-supported-cell';
												else if(val == 'Yes') meta.tdCls = 'predecessor-item-supported-cell';
												return val;
											}
										},{
											dataIndex:'PredecessorUserStoryObjectID',
											width:75,
											renderer: function(userStoryObjectID, meta, predecessorItemRecord){
												if(predecessorItemRecord.data.Assigned){
													var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
													if(userStory) return userStory.data.FormattedID;
													else return '?';
												}
												else return '-';
											}
										},{
											dataIndex:'PredecessorUserStoryObjectID',
											width:140,
											renderer: function(userStoryObjectID, meta, predecessorItemRecord){
												if(predecessorItemRecord.data.Assigned){
													var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
													if(userStory) return userStory.data.Name;
													else return '?';
												}
												else return '-';
											}				
										}];
										
										return {
											xtype: 'grid',
											cls:'risksdeps-grid duplicate-predecessor-items-grid rally-grid',
											viewConfig: { stripeRows:false },
											width:420,
											manageHeight:false,
											columns: predecessorItemColumnCfgs,
											listeners: {
												mousedown: swallowEventHandler,
												mousemove: swallowEventHandler,
												mouseout: swallowEventHandler,
												mouseover: swallowEventHandler,
												mouseup: swallowEventHandler,
												mousewheel: swallowEventHandler,
												scroll: swallowEventHandler,
												click: swallowEventHandler,
												dblclick: swallowEventHandler,
												contextmenu: swallowEventHandler,
												selectionchange: function(){ this.getSelectionModel().deselectAll(); }
											},
											rowLines:false,
											disableSelection: true,
											scroll:false,
											hideHeaders:true,
											enableEditing:false,
											store: Ext.create('Rally.data.custom.Store', { data: predecessorsOfOneID[rowIndex].PredecessorItems })
										};
									}
								}],
								selModel: Ext.create('Ext.selection.CheckboxModel', {
									mode:'SINGLE',
									allowDeselect:false
								}),
								listeners:{ viewready: function(){ this.getSelectionModel().select(0); }},
								manageHeight:false,
								sortableColumns:false,
								showRowActionsColumn:false,
								showPagingToolbar:false,
								enableEditing:false,
								store:Ext.create('Rally.data.custom.Store', { data: predecessorsOfOneID })
							};
						})
					) : []).concat(duplicateSuccessors.length ? [{
						xtype: 'container',
						html: '<h2 class="grid-group-header">Duplicate Successors</h2>'
					}].concat(_.map(duplicateSuccessors, function(successorsOfOneID) {
						return {
							xtype: 'grid',
							cls: 'risksdeps-grid duplicate-successors rally-grid',
							columns: [{
								text: 'Requested By',
								dataIndex: 'SuccessorProjectObjectID',
								width: 160,
								sortable: true,
								renderer: function(projectOID){ return me.ProjectsWithTeamMembers[projectOID].data.Name; }
							}, {
								text: 'Req #',
								dataIndex: 'SuccessorUserStoryObjectID',
								width: 90,
								sortable: true,
								renderer: function(userStoryObjectID) {
									var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
									if(userStory) return userStory.data.FormattedID;
									else return '?';
								}
							}, {
								text: 'Req UserStory',
								dataIndex: 'SuccessorUserStoryObjectID',
								flex: 1,
								sortable: true,
								renderer: function(userStoryObjectID) {
									var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
									if(userStory) return userStory.data.Name;
									else return '?';
								}
							}, {
								text: 'Dependency Description',
								dataIndex: 'Description',
								flex: 1
							}, {
								text:'Needed By',
								dataIndex:'NeededBy',
								width:80,
								sortable:true,
								renderer: function(date){ return (date ? 'ww' + me.getWorkweek(date) : '-');}	
							}, {
								text:'Supported',					
								dataIndex:'Supported',
								width:90,
								renderer: function(val, meta){
									if(val == 'No') meta.tdCls = 'successor-not-supported-cell';
									else if(val == 'Yes') meta.tdCls = 'successor-supported-cell';
									return val;
								}
							}, {
								text:'Sup #', 
								dataIndex:'UserStoryFormattedID',
								width:90,
								sortable:true
							}, {
								text:'Sup UserStory', 
								dataIndex:'UserStoryName',
								flex:1,
								sortable: true
							}],
							selModel: Ext.create('Ext.selection.CheckboxModel', {
								mode:'SINGLE',
								allowDeselect:false
							}),
							listeners:{ viewready: function(){ this.getSelectionModel().select(0); }},
							manageHeight:false,
							sortableColumns:false,
							enableEditing:false,
							store:Ext.create('Rally.data.custom.Store', { data: successorsOfOneID })
						};
					})
				) : []).concat([{
						xtype:'button',
						cls:'done-button',
						text:'Done',
						handler:function(){
							var grids = Ext.ComponentQuery.query('grid', modal),
								predecessorGrids = _.filter(grids, function(grid){ return grid.hasCls('duplicate-predecessors-grid'); });
								successorGrids = _.filter(grids, function(grid) { return grid.hasCls('duplicate-successors-grid'); });
							modal.setLoading('Removing Duplicates');
							Q.all([
								Q.all(_.map(predecessorGrids, function(grid){ 
									var predecessorToKeep = grid.getSelectionModel().getSelection()[0],
										predecessorsToRemove = _.filter(grid.store.getRange(), function(item){ return item.id != predecessorToKeep.id; });
									return Q.all(_.map(predecessorsToRemove, function(predecessorRecord){			
										var deferred = Q.defer(),
											projectRecord = me.ProjectsWithTeamMembers[predecessorRecord.data.ProjectObjectID];
										me.enqueue(function(unlockFunc){
											me.getOldAndNewUserStoryRecords(predecessorRecord.data, me.UserStoriesInRelease).then(function(records){
												var oldUserStoryRecord = records[0],
													realPredecessorData = me.getRealDependencyData(oldUserStoryRecord, predecessorRecord.data.DependencyID, 'Predecessors');
												if(!realPredecessorData) return;
												return me.getRemovedPredecessorItemCallbacks(
														realPredecessorData.PredecessorItems,  
														realPredecessorData,
														projectRecord,
														me.ProjectsWithTeamMembers,
														null,
														me.DependenciesParsedData).then(function(removedCallbacks){
													var promise = Q();
													_.each(removedCallbacks, function(callback){ promise = promise.then(callback); });													
													return promise.then(function(){
														return me.removePredecessor(
															oldUserStoryRecord, realPredecessorData, null, me.DependenciesParsedData);
													});
												});											
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies'); 
										return deferred.promise;
									}))
									.then(function(){
										var deferred = Q.defer(),
											projectRecord = me.ProjectsWithTeamMembers[predecessorToKeep.data.ProjectObjectID];
										/** this is about as fine grained as I want to get with 1 queue. otherwise we might end up with deadlock */
										me.enqueue(function(unlockFunc){
											me.getOldAndNewUserStoryRecords(predecessorToKeep.data, me.UserStoriesInRelease).then(function(records){
												var oldUserStoryRecord = records[0],
													realPredecessorData = me.getRealDependencyData(oldUserStoryRecord, predecessorToKeep.data.DependencyID, 'Predecessors');
												if(!realPredecessorData) return;
												return me.getAddedPredecessorItemCallbacks(
														realPredecessorData.PredecessorItems, 
														realPredecessorData,
														projectRecord,
														me.ProjectsWithTeamMembers,
														null,
														me.DependenciesParsedData).then(function(addedCallbacks){
													var promise = Q();
													_.each(addedCallbacks, function(callback){ promise = promise.then(callback); });			
													return promise.then(function(){
														return me.addPredecessor(oldUserStoryRecord, realPredecessorData, null, me.DependenciesParsedData);
													});
												});											
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies'); 
										return deferred.promise;
									});
								})),
								Q.all(_.map(successorGrids, function(grid) {
									var successorToKeep = grid.getSelectionModel().getSelection()[0],
										successorsToDelete = _.filter(grid.store.getRange(), function(item) { return item.id != successorToKeep.id; });
									return Q.all(_.map(successorsToDelete, function(successorRecord) {
										var deffered = Q.defer();
										me.enqueue(function(unlockFunc) {
											me.getOldAndNewUserStoryRecords(successorRecord.data, me.UserStoriesInRelease).then(function(records) {
												var oldUserStoryRecord = records[0],
													realSuccessorData = me.getRealDependencyData(oldUserStoryRecord, successorRecord.data.DependencyID, 'Successors');
												if(!realSuccessorData) return;
												return me.removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData);
											})
											.then(function(){ deferred.resolve(); })
											.fail(function(reason){ deferred.reject(reason); })
											.then(function(){ unlockFunc(); })
											.done();
										}, 'Queue-Dependencies');
										return deferred.promise;
									}));
								}))
							]).then(function(){
								modal.destroy();
								deferred.resolve();
							})
							.fail(function(reason){ 
								modal.destroy();
								deferred.reject(reason); 
							})
							.done();
						}
					}])
				});
			setTimeout(function(){ modal.show(); }, 10);
			return deferred.promise;
		},
		
		/**___________________________________ RENDER GRIDS ___________________________________*/	
		renderRisksGrid: function(){
			this.RisksGrid = this.add({
				xtype: 'intelriskgrid',
				id: 'risk-grid',
				height:360,
				releaseRecord: this.ReleaseRecord,
				scrumGroupRootRecord: this.ScrumGroupRootRecord,
				projectRecords: _.map(this.ProjectsWithTeamMembers, function(p){ return p; }),
				portfolioItemRecords: this.PortfolioItemStore.getRange(),
				topPortfolioItemMap: this.PortfolioItemMap,
				topPortfolioItemType: this.PortfolioItemTypes.slice(-1)[0],
				risks: this.Risks,
				visibleColumns: [
					'PortfolioItemFormattedID',
					'PortfolioItemName',
					'TopPortfolioItemName',
					'OwningProject',
					'Description',
					'Impact',
					'MitigationPlan',
					'Status',
					'RiskLevel',
					'Checkpoint',
					'Owner',
					'Submitter',
					'UndoButton',
					'SaveButton',
					'CopyButton',
					'DeleteButton'
				]
			});
		},
		renderDependenciesGrids: function(){
			var me = this;
			
			function dependencySorter(o1, o2){ return o1.data.DependencyID > o2.data.DependencyID ? -1 : 1; } //new come first
			function predecessorItemSorter(o1, o2){ return o1.data.PredecessorItemID > o2.data.PredecessorItemID ? -1 : 1; } //new come first
			
			/****************************** STORES FOR THE DROPDOWNS  ***********************************************/	
			me.UserStoryFIDStore = Ext.create('Ext.data.Store', {
				fields: ['FormattedID'],
				data: _.map(me.UserStoriesInRelease, function(usr){ return {'FormattedID': usr.data.FormattedID}; }),
				sorters: { property: 'FormattedID' }
			});
			me.UserStoryNameStore = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(me.UserStoriesInRelease, function(usr){ return {'Name': usr.data.Name }; }),
				sorters: { property: 'Name' }
			});
			
			/****************************** PREDECESSORS STUFF ***********************************************/				
			me.PrececessorItemStores = {};
			me.PredecessorItemGrids = {};
			
			var predecessorStore = Ext.create('Intel.lib.component.Store', { 
				data: Ext.clone(me.DependenciesParsedData.Predecessors),
				autoSync:true,
				model:'IntelPredecessorDependencyForTracking',
				limit:Infinity,
				disableMetaChangeEvent: true,
				proxy: {
					type:'intelsessionstorage',
					id:'IntelPredecessorDependencyProxy' + Math.random()
				},
				sorters:[dependencySorter],
				intelUpdate: function(){ 
					var realPredecessorsData = me.DependenciesParsedData.Predecessors.slice(); 
					predecessorStore.suspendEvents(true);
					_.each(predecessorStore.getRange(), function(predecessorRecord){
						var dependencyID = predecessorRecord.data.DependencyID,
							realPredecessorData = me.spliceDependencyFromList(dependencyID, realPredecessorsData),	
							dirtyType = me.getDirtyType(predecessorRecord, realPredecessorData),
							predecessorItemStore = me.PrececessorItemStores[dependencyID],
							predecessorItemGrid = me.PredecessorItemGrids[dependencyID],
							remoteChanged = false;
						if(dirtyType === 'New' || dirtyType === 'Edited'){} //we don't want to remove any pending changes			
						else if(dirtyType == 'Deleted'){ //predecessor was deleted by someone else, and we aren't editing it
							predecessorStore.remove(predecessorRecord);
							if(predecessorItemStore) me.PrececessorItemStores[dependencyID] = undefined;
							if(predecessorItemGrid) me.PredecessorItemGrids[dependencyID] = undefined;
						} else {
							if(!_.isEqual(predecessorRecord.data.PredecessorItems, realPredecessorData.PredecessorItems)){ 
								/** faster to delete and re-add if predecessorItems are different */
								if(predecessorItemGrid) {
									me.PredecessorItemGrids[dependencyID].destroy();
									delete me.PredecessorItemGrids[dependencyID];
								}
								predecessorStore.remove(predecessorRecord);
								predecessorStore.add(Ext.create('IntelPredecessorDependencyForTracking', Ext.clone(realPredecessorData)));
								if(predecessorItemStore) predecessorItemStore.intelUpdate(); 
							}
							else {	
								_.each(realPredecessorData, function(value, field){
									if(field!=='PredecessorItems' && !_.isEqual(predecessorRecord.data[field], value)) remoteChanged = true;
								});
								if(remoteChanged){
									predecessorRecord.beginEdit();
									_.each(realPredecessorData, function(value, field){ 
										if(field!=='PredecessorItems') predecessorRecord.set(field, value); 
									});
									predecessorRecord.endEdit();
								}
							}
						}				
						if(!predecessorRecord.data.PredecessorItems.length) {
							//DO NOT SET EDITED==true, because it is already true! only new or edited will ever have preds.length==0
							predecessorRecord.set('PredecessorItems', [me.newPredecessorItem()]); 
							if(predecessorItemStore) predecessorItemStore.intelUpdate();
						}
					});
					
					_.each(realPredecessorsData, function(realPredecessorData){
						/** add all the new dependencies that other people have added since the last load */
						predecessorStore.add(Ext.create('IntelPredecessorDependencyForTracking', Ext.clone(realPredecessorData)));					
						var dependencyID = realPredecessorData.DependencyID,
							predecessorItemStore = me.PrececessorItemStores[dependencyID];
						if(predecessorItemStore) predecessorItemStore.intelUpdate(); 
					});
					predecessorStore.resumeEvents();
				}
			});
			var predecessorColumns = [{
				text:'#', 
				dataIndex:'UserStoryFormattedID',
				width:90,
				sortable:true,
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				text:'UserStory', 
				dataIndex:'UserStoryName',
				flex:1,		
				sortable:true,
				items:[{ xtype:'intelgridcolumnfilter' }]	
			},{
				text: me.PortfolioItemTypes.slice(-1).pop(), 
				dataIndex: 'TopPortfolioItemName',
				width:90,
				sortable:true,
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				text:'Owning Team', 
				dataIndex:'ProjectObjectID',
				flex:2,
				sortable:true,
				renderer: function(oid){ return ((me.ProjectsWithTeamMembers[oid] || {}).data || {}).Name || '?'; },
				items:[{ 
					xtype:'intelgridcolumnfilter',
					convertDisplayFn: function(oid){ return ((me.ProjectsWithTeamMembers[oid] || {}).data || {}).Name || '?'; }
				}]
			},{
				text:'Dependency Description', 
				dataIndex:'Description',
				flex:1
			},{
				text:'Needed By',			
				dataIndex:'NeededBy',
				width:90,
				renderer: function(date){ return (date ? 'ww' + me.getWorkweek(date) : '-');},
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(dateVal){ return dateVal ? 'ww' + me.getWorkweek(dateVal) : undefined; }
				}]
			},{
				text:'Teams Depended On',
				dataIndex:'DependencyID',
				xtype:'intelcomponentcolumn',
				html:	'<div class="predecessor-items-grid-header" style="width:10px !important;"></div>' +
						'<div class="predecessor-items-grid-header" style="width:110px !important;">Team Name</div>' +
						'<div class="predecessor-items-grid-header" style="width:95px  !important;">Supported</div>' +
						'<div class="predecessor-items-grid-header" style="width:70px  !important;">#</div>' +
						'<div class="predecessor-items-grid-header" style="width:130px !important;">User Story</div>',
				width:450,
				renderer: function(dependencyID){
					var predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
						predecessorItems = predecessorRecord.data.PredecessorItems;
					if(!me.PrececessorItemStores[dependencyID]){
						me.PrececessorItemStores[dependencyID] = Ext.create('Intel.lib.component.Store', { 
							model:'IntelPredecessorItem',
							data: predecessorItems,
							autoSync:true,
							limit:Infinity,
							disableMetaChangeEvent: true,
							proxy: {
								type:'intelsessionstorage',
								id:'PredecessorItem-' + dependencyID + '-proxy' + Math.random()
							},
							sorters:[predecessorItemSorter],
							intelUpdate: function(){
								var predecessorItemStore = me.PrececessorItemStores[dependencyID],
									predecessorItems = predecessorItemStore.getRange(),
									predecessorRecord = predecessorStore.getAt(predecessorStore.findExact('DependencyID', dependencyID)),
									realPredecessorItemsData = predecessorRecord.data.PredecessorItems.slice();
								predecessorItemStore.suspendEvents(true);
								_.each(predecessorItems, function(predecessorItem){
									var realPredecessorItemData = _.find(realPredecessorItemsData, function(realPredecessorItemData){
										return realPredecessorItemData.PredecessorItemID === predecessorItem.data.PredecessorItemID;
									});
									if(realPredecessorItemData){
										realPredecessorItemsData = _.filter(realPredecessorItemsData, function(realPredecessorItemData2){
											return realPredecessorItemData.PredecessorItemID !== realPredecessorItemData2.PredecessorItemID;
										});
										_.each(realPredecessorItemData, function(value, field){
											if(!_.isEqual(predecessorItem.data[field], value)){ 
												predecessorItemStore.remove(predecessorItem);
												predecessorItemStore.add(Ext.create('IntelPredecessorItem', Ext.clone(realPredecessorItemData)));
												return false;
											}
										});
									}
									else predecessorItemStore.remove(predecessorItem);
								});
								_.each(realPredecessorItemsData, function(realPredecessorItemData){
									predecessorItemStore.add(Ext.create('IntelPredecessorItem', realPredecessorItemData));
								});	
								
								if(predecessorItemStore.getRange().length===0) {
									var newItem = me.newPredecessorItem();
									predecessorItemStore.add(Ext.create('IntelPredecessorItem', newItem));
									predecessorRecord.data.PredecessorItems.push(newItem);
								}
								predecessorItemStore.resumeEvents();
							}
						});	
					}
					
					if(me.PredecessorItemGrids[dependencyID]) return me.PredecessorItemGrids[dependencyID];
						
					var swallowEventHandler = {
						element: 'el',
						fn: function(a){ a.stopPropagation(); }
					};
					
					var predecessorItemColumns = [{
						dataIndex:'PredecessorProjectObjectID',
						width:115,
						renderer: function(val, meta){
							var projectRecord = me.ProjectsWithTeamMembers[val];
							if(val && projectRecord) return projectRecord.data.Name;
							else return '-';
						}
					},{
						dataIndex:'Supported',
						width:80,
						renderer: function(val, meta){
							if(val == 'No') meta.tdCls = 'predecessor-item-not-supported-cell';
							else if(val == 'Yes') meta.tdCls = 'predecessor-item-supported-cell';
							return val;
						}
					},{
						dataIndex:'PredecessorUserStoryObjectID',
						width:75,
						renderer: function(userStoryObjectID, meta, predecessorItemRecord){
							if(predecessorItemRecord.data.Assigned){
								var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
								if(userStory) return userStory.data.FormattedID;
								else return '?';
							}
							else return '-';
						}
					},{
						dataIndex:'PredecessorUserStoryObjectID',
						width:140,
						renderer: function(userStoryObjectID, meta, predecessorItemRecord){
							if(predecessorItemRecord.data.Assigned){
								var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
								if(userStory) return userStory.data.Name;
								else return '?';
							}
							else return '-';
						}				
					}];
					
					return {
						xtype: 'grid',
						cls:'risksdeps-grid predecessor-items-grid rally-grid',
						plugins: [ 'intelcellediting' ],
						viewConfig: { stripeRows:false },
						width:420,
						manageHeight:false,
						columns: {
							defaults: COLUMN_DEFAULTS,
							items: predecessorItemColumns
						},
						listeners: {
							mousedown: swallowEventHandler,
							mousemove: swallowEventHandler,
							mouseout: swallowEventHandler,
							mouseover: swallowEventHandler,
							mouseup: swallowEventHandler,
							mousewheel: swallowEventHandler,
							scroll: swallowEventHandler,
							click: swallowEventHandler,
							dblclick: swallowEventHandler,
							contextmenu: swallowEventHandler,
							render: function(){ me.PredecessorItemGrids[dependencyID] = this; },
							selectionchange: function(){ this.getSelectionModel().deselectAll(); }
						},
						rowLines:false,
						disableSelection: true,
						scroll:false,
						hideHeaders:true,
						enableEditing:false,
						store: me.PrececessorItemStores[dependencyID]
					};
				}
			},{
				text:'Plan', 
				dataIndex:'Plan',
				flex:1,
				tdCls: 'intel-editor-cell',
				editor: 'inteltextarea'
			},{
				dataIndex:'Status',
				width:90,
				tdCls: 'intel-editor-cell',
				text:'Disposition',					
				editor:{
					xtype:'intelfixedcombo',
					store: ['Done', 'Not Done']
				},
				renderer: function(val, meta){
					if(val === 'Done') meta.tdCls += ' predecessor-supported-cell';
					else meta.tdCls += ' predecessor-not-supported-cell';
					return val || 'Not Done';
				},
				items:[{ 
					xtype:'intelgridcolumnfilter',
					convertDisplayFn: function(val){ return val || 'Not Done'; }
				}]
				
			}];
			me.PredecessorGrid = me.add({
				xtype: 'grid',
				cls: 'risksdeps-grid predecessors-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'risksdeps-grid-header-text',
						width:400,
						text: "DEPENDENCIES WE HAVE ON OTHER TEAMS"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'Remove Filters',
							cls: 'intel-button',
							listeners:{ 
								click: function(){ 
									_.invoke(Ext.ComponentQuery.query('intelgridcolumnfilter', me.PredecessorGrid), 'clearFilters');
									me.PredecessorGrid.store.fireEvent('refresh', me.PredecessorGrid.store);
								}
							}
						}]
					}]
				},
				height:400,
				scroll:'vertical',
				columns: {
					defaults: COLUMN_DEFAULTS,
					items: predecessorColumns
				},
				plugins: [ 'intelcellediting' ],
				viewConfig:{
					xtype:'inteltableview',
					preserveScrollOnRefresh:true
				},
				listeners: {
					edit: function(editor, e){				
						var predecessorRecord = e.record,
							predecessorData = predecessorRecord.data,
							field = e.field,
							value = e.value,
							originalValue = e.originalValue;
						
						if(value === originalValue) return; 
						else if(!value) { predecessorRecord.set(field, originalValue); return; }
						if(field === 'Plan') {
							value = me.htmlEscape(value);			
							predecessorRecord.set(field, value);
						}
						
						var previousEdit = predecessorRecord.data.Edited; 
						predecessorRecord.set('Edited', true);
						
						me.PredecessorGrid.setLoading('Saving');
						me.enqueue(function(unlockFunc){
							me.getOldAndNewUserStoryRecords(predecessorData, me.UserStoryStore.getRange()).then(function(records){
								var userStoryRecord = records[1];
								return me.addPredecessor(userStoryRecord, predecessorData, null, me.DependenciesParsedData);
							})
							.then(function(){ predecessorRecord.set('Edited', false); })
							.fail(function(reason){ me.alert('ERROR:', reason); })
							.then(function(){
								me.PredecessorGrid.setLoading(false);
								unlockFunc();
							})
							.done();
						});
					}
				},
				disableSelection: true,
				enableEditing:false,
				store: predecessorStore
			});	

		/**************************************************** SUCCESSORS STUFF *******************************************************************/

			var successorStore = Ext.create('Intel.lib.component.Store', {
				data: Ext.clone(me.DependenciesParsedData.Successors),
				autoSync: true,
				model: 'IntelSuccessorDependency',
				proxy: {
					type: 'intelsessionstorage',
					id: 'IntelSuccessorProxy' + Math.random()
				},
				limit: Infinity,
				disableMetaChangeEvent: true,
				sorters: [dependencySorter],
				intelUpdate: function() {
					var realSuccessorsData = me.DependenciesParsedData.Successors.slice(),
						remoteChanged = false;
					successorStore.suspendEvents(true);
					_.each(successorStore.getRange(), function(successorRecord) {
						var realSuccessorData = me.spliceDependencyFromList(successorRecord.data.DependencyID, realSuccessorsData),
							dirtyType = me.getDirtyType(successorRecord, realSuccessorData);
						if(dirtyType === 'Edited'){} // dont remove pending changes
						else if(dirtyType === 'Deleted' || dirtyType === 'New') successorStore.remove(successorRecord);
						else {
							_.each(realSuccessorData, function(value, field) {
								if(!_.isEqual(successorRecord.data[field], value)) remoteChanged = true;
							});
							if(remoteChanged) {
								successorRecord.beginEdit();
								_.each(realSuccessorData, function(value, field) { successorRecord.set(field, value); });
								successorRecord.endEdit();
							}
						}
					});
					_.each(realSuccessorsData, function(realSuccessorData) {
						successorStore.add(Ext.create('IntelSuccessorDependency', Ext.clone(realSuccessorData)));
					});
					successorStore.resumeEvents();
				}
			});

			var successorColumns = [{
				text:'Requested By',
				dataIndex:'SuccessorProjectObjectID',
				width:160,
				sortable:true,
				renderer: function(projectOID){ return me.ProjectsWithTeamMembers[projectOID].data.Name; },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(oid){return me.ProjectsWithTeamMembers[oid].data.Name; }
				}]
			},{
				text:'Req #',
				dataIndex:'SuccessorUserStoryObjectID',
				width:90,
				sortable:true,
				renderer: function(userStoryObjectID){
					var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
					if(userStory){
						return '<a href="' + me.BaseUrl + '/#/' + userStory.data.Project.ObjectID + 'ud/detail/userstory/' + 
							userStory.data.ObjectID + '" target="_blank">' + userStory.data.FormattedID + '</a>';
					} else return '?';
				},
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(oid){
						var userStory = me.DependenciesHydratedUserStories[oid];
						return userStory ? userStory.data.FormattedID : undefined;
					}
				}]
			},{
				text:'Req UserStory',
				dataIndex:'SuccessorUserStoryObjectID',
				flex:1,
				sortable:true,
				renderer: function(userStoryObjectID){
					var userStory = me.DependenciesHydratedUserStories[userStoryObjectID];
					if(userStory) return userStory.data.Name;
					else return '?';
				},
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(oid){
						var userStory = me.DependenciesHydratedUserStories[oid];
						return userStory ? userStory.data.Name : undefined;
					}
				}]
			},{
				text:'Dependency Description', 
				dataIndex:'Description',
				flex:1
			},{
				text:'Needed By',
				dataIndex:'NeededBy',
				width:80,
				sortable:true,
				renderer: function(date){ return (date ? 'ww' + me.getWorkweek(date) : '-');},
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(dateVal){ return dateVal ? 'ww' + me.getWorkweek(dateVal) : undefined; }
				}]
			},{
				text:'Supported',					
				dataIndex:'Supported',
				width:90,
				sortable:true,
				tdCls: 'intel-editor-cell',
				editor:{
					xtype:'intelfixedcombo',
					width:80,
					store: Ext.create('Ext.data.Store', {
						fields: ['Sup'],
						data: [
							{Sup:'Undefined'},
							{Sup:'Yes'},
							{Sup:'No'}
						]
					}),
					displayField: 'Sup'
				},
				renderer: function(val, meta){
					if(val == 'No') meta.tdCls = 'successor-not-supported-cell';
					else if(val == 'Yes') meta.tdCls = 'successor-supported-cell';
					return val;
				},
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				text:'Sup #', 
				dataIndex:'UserStoryFormattedID',
				width:90,
				editor:{
					xtype:'intelcombobox',
					width:120,
					store: me.UserStoryFIDStore,
					displayField: 'FormattedID'
				},
				sortable:true,
				renderer:function(val, meta, record){ 
					if(record.data.Supported == 'Yes') meta.tdCls += ' intel-editor-cell';
					return val || '-'; 
				},	
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				text:'Sup UserStory', 
				dataIndex:'UserStoryName',
				flex:1,
				editor:{
					xtype:'intelcombobox',
					store: me.UserStoryNameStore,
					displayField: 'Name'
				},
				sortable: true,
				renderer:function(val, meta, record){ 
					if(record.data.Supported == 'Yes') meta.tdCls += ' intel-editor-cell';
					return val || '-'; 
				},	
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				dataIndex:'Edited',
				width:24,
				renderer: function(value, meta, successorRecord){		
					var id = Ext.id();
					if(!successorRecord.data.UserStoryFormattedID) return '';
					meta.tdAttr = 'title="Remove User Story"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							successorRecord.beginEdit(true);
							successorRecord.set('Edited', true);
							successorRecord.set('Assigned', false);
							successorRecord.set('UserStoryFormattedID', '');
							successorRecord.set('UserStoryName', '');
							successorRecord.endEdit();
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-minus"></i></div>';
				}
			},{
				dataIndex:'Edited',
				width:24,
				renderer: function(value, meta, successorRecord){	
					var id = Ext.id(), 
						dependencyID = successorRecord.data.DependencyID,
						realSuccessorData = me.spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice()),
						dirtyType = me.getDirtyType(successorRecord, realSuccessorData);
					if(dirtyType !== 'Edited') return;
					meta.tdAttr = 'title="Undo"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							var realSuccessorData = me.spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice());	
							successorRecord.beginEdit(true);
							_.each(realSuccessorData, function(value, field){ successorRecord.set(field, value); });
							successorRecord.endEdit();
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-undo"></i></div>';
				}
			},{
				dataIndex:'Edited',
				width:24,
				renderer: function(value, meta, successorRecord){
					var id = Ext.id(), 
						dependencyID = successorRecord.data.DependencyID,
						realSuccessorData = me.spliceDependencyFromList(dependencyID, me.DependenciesParsedData.Successors.slice()),
						dirtyType = me.getDirtyType(successorRecord, realSuccessorData);
					if(dirtyType != 'Edited') return;
					meta.tdAttr = 'title="Save Dependency"';
					setTimeout(function whenRendered(){
						var el = Ext.get(id);
						if(el) el.on('click', function(){
							if(!successorRecord.data.Supported){
								me.alert('ERROR', 'You must set the Supported field.'); return; }
							me.SuccessorGrid.setLoading("Saving Dependency");						
							me.enqueue(function(unlockFunc){
								var successorData = successorRecord.data, 
									oldUserStoryRecord, 
									newUserStoryRecord,
									realSuccessorData;
								me.getOldAndNewUserStoryRecords(successorData, me.UserStoryStore.getRange()).then(function(records){
									oldUserStoryRecord = records[0];
									newUserStoryRecord = records[1];
									
									realSuccessorData = me.getRealDependencyData(oldUserStoryRecord, successorData.DependencyID, 'Successors');
									if(!realSuccessorData) return Q.reject({SuccessorDeletedDependency:true, message:'Successor removed this dependency'});
									
									successorData.UserStoryObjectID = newUserStoryRecord.data.ObjectID;	
									successorData.SuccessorUserStoryObjectID = realSuccessorData.SuccessorUserStoryObjectID;
									
									return me.updateSuccessor(
											newUserStoryRecord, 
											successorData, 
											me.ProjectRecord,
											me.ProjectsWithTeamMembers, 
											me.ProjectRecord, 
											me.DependenciesParsedData)
									.then(function(){							
										if(oldUserStoryRecord.data.ObjectID !== newUserStoryRecord.data.ObjectID)
											return me.removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData);
									})
									.then(function(){ return me.addSuccessor(newUserStoryRecord, successorData, me.ProjectRecord, me.DependenciesParsedData); })
									.then(function(){ successorRecord.set('Edited', false); });
								})
								.fail(function(reason){
									if(reason.SuccessorDeletedDependency){
										me.alert('ERROR', reason.message + '. Deleting this dependency now');
										if(realSuccessorData){
											me.removeSuccessor(oldUserStoryRecord, realSuccessorData, me.ProjectRecord, me.DependenciesParsedData)
												.then(function(){ successorStore.remove(successorRecord); })
												.fail(function(reason){ me.alert('ERROR', reason); })
												.done();
										}
										else successorStore.remove(successorRecord);
									}
									else me.alert('ERROR', reason);
								})
								.then(function(){
									unlockFunc();
									me.SuccessorGrid.setLoading(false);
								})
								.done();
							}, 'Queue-Main');
						});
						else setTimeout(whenRendered, 10);
					}, 20);
					return '<div id="' + id + '" class="intel-editor-cell"><i class="fa fa-md fa-floppy-o"></i></div>';
				}
			}];
			me.SuccessorGrid = me.add({
				xtype: 'grid',
				cls: 'team-report-grid successor-grid rally-grid',
				header: {
					layout: 'hbox',
					items: [{
						xtype:'text',
						cls:'risksdeps-grid-header-text',
						width:400,
						text: "DEPENDENCIES OTHER TEAMS HAVE ON US"
					},{
						xtype:'container',
						flex:1000,
						layout:{
							type:'hbox',
							pack:'end'
						},
						items:[{
							xtype:'button',
							text:'Remove Filters',
							cls:'intel-button',
							width:110,
							listeners:{ 
								click: function(){ 
									_.invoke(Ext.ComponentQuery.query('intelgridcolumnfilter', me.SuccessorGrid), 'clearFilters'); 
									me.SuccessorGrid.store.fireEvent('refresh', me.SuccessorGrid.store);
								}
							}
						}]
					}]
				},
				height:400,
				scroll:'vertical',
				columns: {
					defaults: COLUMN_DEFAULTS,
					items:successorColumns
				},
				plugins: [ 'intelcellediting' ],
				viewConfig:{
					xtype:'inteltableview',
					preserveScrollOnRefresh:true
				},
				listeners: {
					beforeedit: function(editor, e){
						var successorRecord = e.record;
						if(successorRecord.data.Supported != 'Yes' && e.field != 'Supported') 
							return false; //don't edit user story stuff if not supported
					},
					edit: function(editor, e){					
						var grid = e.grid,
							successorRecord = e.record,
							field = e.field,
							value = e.value,
							originalValue = e.originalValue;	
							
						if(value == originalValue) return;
						else if(!value) { successorRecord.set(field, originalValue); return; }
						var previousEdit = successorRecord.data.Edited;
						successorRecord.set('Edited', true);
						
						if((field === 'UserStoryName' || field == 'UserStoryFormattedID') && successorRecord.data.Supported != 'Yes'){
							successorRecord.set(field, originalValue); 
							return; 
						}
						
						var userStoryRecord;
						if(field === 'UserStoryName'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.Name === value; });
							if(!userStoryRecord){
								successorRecord.set('UserStoryName', originalValue);
								successorRecord.set('Edited', previousEdit); 
							} else {
								successorRecord.set('UserStoryFormattedID', userStoryRecord.data.FormattedID);	
								successorRecord.set('Assigned', true);
							}
						} else if(field === 'UserStoryFormattedID'){
							userStoryRecord = _.find(me.UserStoriesInRelease, function(us){ return us.data.FormattedID === value; });
							if(!userStoryRecord) {
								successorRecord.set('UserStoryFormattedID', originalValue);
								successorRecord.set('Edited', previousEdit); 
							} else {
								successorRecord.set('UserStoryName', userStoryRecord.data.Name);	
								successorRecord.set('Assigned', true);
							}
						}
						else if(field === 'Supported'){ //cant be non-supported with a user story!
							if(value != 'Yes'){
								successorRecord.set('Assigned', false);
								successorRecord.set('UserStoryFormattedID', '');
								successorRecord.set('UserStoryName', '');
							}
						}
					}
				},
				disableSelection: true,
				showRowActionsColumn:false,
				showPagingToolbar:false,
				enableEditing:false,
				store: successorStore
			});	
		}	
	});
}());

            Rally.launchApp('Intel.SAFe.RisksDepsTracking', {
                name:"Risks and Deps Tracking",
	            parentRepos:""
            });

        });
    </script>


    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"/>

    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}
/************************************************ RALLY BUTTON STYLE *****************************************/
.intel-button {
  border-radius: 2px;
  background-color: #00a9e0;
  border-color: #00a9e0;
}
.intel-button:hover {
  background-color: #29beff;
  border-color: #29beff;
}
.intel-button * {
  font-size: 12px;
}

    </style>

    <style type="text/css">
        /************************************************ RISKS GRID *****************************************/
.x-grid-body .x-grid-row .risks-grid-error-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
/*red*/
/************************************************ DEPENDENCIES GRIDS *****************************************/
.predecessor-items-grid .x-grid-body {
  background-color: rgba(0, 0, 0, 0) !important;
  border-top: 0 !important;
}
.predecessor-items-grid-header {
  display: inline-block !important;
  line-height: 100% !important;
  font-weight: 500 !important;
}
.x-grid-body .x-grid-row .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.x-grid-body .x-grid-row .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.25) !important;
}
/************************************************ DUPLICATE RESOLVING MODAL *****************************************/
.duplicates-modal .grid-group-header {
  text-decoration: underline;
  padding-left: 10px;
  font-size: 1.25rem;
}
.duplicates-modal .done-button {
  margin: 10px 0 10px 10px;
}
.duplicates-modal .x-grid-row-selected .x-grid-cell,
.duplicates-modal .x-grid-row-over .x-grid-cell {
  background-color: rgba(0, 0, 0, 0) !important;
}
.duplicates-modal .duplicate-risks-grid,
.duplicates-modal .duplicate-predecessors-grid,
.duplicates-modal .duplicate-successors-grid {
  margin: 10px 20px 10px 20px;
}
.duplicates-modal .x-grid-row-checker {
  background-image: url(https://rally1.rallydev.com/apps/2.0rc3/rui/resources/css/images/form/radio.gif) !important;
}

    </style>

    <style type="text/css">
        .x-grid-cell.manager-expected-cell {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-feature-cell {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-feature-cell {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-cell-small {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-feature-cell-small {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-feature-cell-small {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-feature-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.manager-expected-feature-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), /* comment blue */ -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), /* expected yellow */ -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  /* feature purple */
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-RED,
.x-grid-row-over .x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREEN,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREY,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.7) !important;
}

    </style>

    <style type="text/css">
        .risk-grid .risk-grid-header-text {
  font-size: 13px;
}
.risk-grid .add-new-button,
.risk-grid .clear-filters-button {
  border-radius: 2px;
  margin-left: 10px;
  background-color: #00a9e0;
  border-color: #00a9e0;
}
.risk-grid .add-new-button:hover,
.risk-grid .clear-filters-button:hover {
  background-color: #29beff;
  border-color: #29beff;
}
.risk-grid .add-new-button *,
.risk-grid .clear-filters-button * {
  font-size: 12px;
}
.risk-grid .x-grid-row .x-grid-cell,
.risk-grid .x-grid-row.x-grid-row-alt.x-grid-row-over .x-grid-cell {
  background-color: transparent !important;
}

    </style>

    <style type="text/css">
        .risksdeps-grid-header-text {
  font-size: 13px !important;
}
.risksdeps-hidden-grid-row {
  display: none !important;
}
/************************************************ NAVBAR/CONTAINERS *****************************************/
#navbox {
  padding: 0 10px 0 10px;
}
#releasePicker {
  margin: 4px 0 0 0;
}
#manualRefreshButton {
  margin: 5px 0 0 5px;
}
/************************************************ RISKS GRID *****************************************/
#risk-grid {
  margin: 10px 10px 0px 10px;
}
/************************************************ DEPENDENCIES GRIDS *****************************************/
.predecessors-grid {
  margin: 40px 10px 20px 10px;
}
.x-grid-body .x-grid-row .predecessor-hot-urgency-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-hot-urgency-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}

    </style>
</head>
<body>
</body>
</html>
