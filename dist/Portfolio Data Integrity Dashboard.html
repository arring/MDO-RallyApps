<!-- Build: taya-dev:785a8bfaf0bf29dd776b76b5a0442b8a962a2ba9:2017-01-13T23:57:23.740Z --><!DOCTYPE html>
<html>
<head>
    <title>Portfolio Data Integrity Dashboard</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/2.2.2/jquery.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.src.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/modules/heatmap.src.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/sprintf/1.0.3/sprintf.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** 
	SUMMARY:
		This extends Rally.app.app. All Intel Apps should extend from this if they want to use the functionality it provides,
		as well as numerous other lib/* files that require you to extend from this.
		
		If you extend from Intel.lib.IntelRallyApp, you have to call me.configureIntelRallyApp() before anything else in your launch() 
		function. After you call me.configureIntelRallyApp, you will be able to access a lot of things, such as:
			- me.ScheduleStates: possible UserStory schedule States
			- me.PortfolioItemTypes: Ordered Array of PortfolioItem Types. e.g.: ['Feature', 'Milestone', 'Product']
			- me.ScrumGroupConfig: the scrum group portfolio location config for the workspace
			- me.HorizontalGroupingConfig: the horizontal scrum groupings by keywords
			- All the most-used Rally models, such as me.Project, me.UserStory, me.PortfolioItem, etc... 
		
	DEPENDENCIES:
		Q promise library
		
	ISSUES:
		sdk 2.0 does not work with the project function due to a bug in the sdk. use sdk 2.0rc3
	*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		ScrumGroupConfigPrefName = 'intel-config-portfolio-locations', //preference to store portfolio locations config for workspace
		HorizontalGroupingConfigPrefName = 'intel-config-horizontal-grouping',//preference to store map of keywords in project names to horizontal
		TrainTypeGroupConfigPrefName = 'intel-traintype-grouping-config',//preference to store map of train type
		EditPermissionListPrefName = 'intel-workspaceapp-permission-list',//preference to store list of people who can save changes
		LastModifiedWorkspaceAppByPrefName = 'intel-workspaceapp-modifiedby-list';//preference to save people who last modified the preferences
	
	//increase timeouts to 5 minutes since rally can be slow sometimes
	var timeout = 300000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('Intel.lib.IntelRallyApp', {
		extend: 'Rally.app.App',
		minWidth:910, //when Rally adds its own scrollbar anyways
		
		projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal',
			'PercentDoneByStoryPlanEstimate'],
		userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
        minimalFields: ['ObjectID', 'Name', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me.reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					User: 'User',
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[ScrumGroupConfigPrefName], scrumGroupConfig;
					try{
                        scrumGroupConfig = JSON.parse(configString);
                    }
					catch(e){
                        console.error(e);
                        scrumGroupConfig = [];
                    }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadHorizontalGroupingConfig: function(){
			/** HorizontalGroupingConfig is this:
			{
				enabled: boolean,
				groups: {
					<horizontal1Name>: ['keyword1', 'keyword2'],
					<horizontal2Name>: ['keyword1', 'keyword2'],
					...
				}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				success: function(prefs) {
					var configString = prefs[HorizontalGroupingConfigPrefName], horizontalGroupingConfig;
					try{ horizontalGroupingConfig = JSON.parse(configString); }
					catch(e){ horizontalGroupingConfig = {enabled:false, groups:{}}; }
					me.HorizontalGroupingConfig = horizontalGroupingConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadTrainTypeGroupingConfig: function(){
			/** TrainTypeGroupingConfig is this:
			{
				traintypes: {['keyword1', 'keyword2']}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: TrainTypeGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[TrainTypeGroupConfigPrefName], trainTypeGroupingConfig;
					try{ trainTypeGroupingConfig = JSON.parse(configString); }
					catch(e){ trainTypeGroupingConfig = {traintypes:{}}; }
					me.TrainTypeGroupingConfig = trainTypeGroupingConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		_loadConfigEditPermissionList: function(){
			/** ConfigEditPermissionList is this:
			{
				username: {['keyword1', 'keyword2']}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: EditPermissionListPrefName,
				success: function(prefs) {
					var permissionListString = prefs[EditPermissionListPrefName], ConfigEditPermissionList;
					try{ configEditPermissionList = JSON.parse(permissionListString); }
					catch(e){ configEditPermissionList = {username:{}}; }
					me.ConfigEditPermissionList = configEditPermissionList;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadLastModifiedWorkspaceAppByPref: function(){
			/**  */
			/** me.LastModifiedWorkspaceAppBy is an array of these objects: 
				{
					KeyValueDatabase: {username:"",date:""},
					TrainTypeConfig: {username:"",date:""},
					ScrumGroupAndPortfolioConfig:{username:"",date:""},
					WorkspaceAppPermissionConfig:{username:"",date:""},
					EnableHorizontal: {username:"",date:""},
					HorizontalGroupingConfig:{username:"",date:""}
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: LastModifiedWorkspaceAppByPrefName,
				success: function(prefs) {
					var configString = prefs[LastModifiedWorkspaceAppByPrefName], lastModifiedWorkspaceAppBy;
					try{ 
						lastModifiedWorkspaceAppBy = JSON.parse(configString); 
						if(_.isEmpty(lastModifiedWorkspaceAppBy))
							lastModifiedWorkspaceAppBy = {
								KeyValueDatabase: [],
								TrainTypeConfig: [],
								ScrumGroupAndPortfolioConfig:[],
								WorkspaceAppPermissionConfig:[],
								EnableHorizontal: [],
								HorizontalGroupingConfig:[]
							};								
						}
					catch(e){ 
						lastModifiedWorkspaceAppBy = {
							KeyValueDatabase: [],
							TrainTypeConfig: [],
							ScrumGroupAndPortfolioConfig:[],
							WorkspaceAppPermissionConfig:[],
							EnableHorizontal: [],
							HorizontalGroupingConfig:[]
						}; 
					}
					me.LastModifiedWorkspaceAppBy = lastModifiedWorkspaceAppBy;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveLastModifiedWorkspaceAppBy: function(lastModifiedByObj){
			var me=this, s = {}, deferred = Q.defer();
			_.each(lastModifiedByObj,function(value,key){
				if(lastModifiedByObj[key].length > 10){
					lastModifiedByObj[key] = _.sortBy(lastModifiedByObj[key],	function(o) { return new Date(o.date); });
					lastModifiedByObj[key].splice(0, lastModifiedByObj[key].length-10);	//need to keep only 10 recent records			
				}
			});
			s[LastModifiedWorkspaceAppByPrefName] = JSON.stringify(lastModifiedByObj); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: LastModifiedWorkspaceAppByPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveConfigEditPermissionList: function(userListObj){
			var me=this, s = {}, deferred = Q.defer();
			s[EditPermissionListPrefName] = JSON.stringify(userListObj); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: EditPermissionListPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		saveHorizontalGroupingConfig: function(horizontalGroupingConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[HorizontalGroupingConfigPrefName] = JSON.stringify(horizontalGroupingConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveTrainTypeGroupingConfig: function(traintypeGroupingConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[TrainTypeGroupConfigPrefName] = JSON.stringify(traintypeGroupingConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: TrainTypeGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},		
		configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me.userStoryFields.push(me.PortfolioItemTypes[0]);  
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadHorizontalGroupingConfig(),
				me._loadTrainTypeGroupingConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadProject');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me.projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadUserStory');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me.userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: loadPortfolioItemByType');
			else {
				type = (type.indexOf('PortfolioItem/') === 0) ? type : ('PortfolioItem/' + type);	
				me[type].load(oid, {
					fetch: me.portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me.loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID;
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me.loadProject(parent.ObjectID).then(function(parentRecord){
							return me.projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me.loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me.reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		getScrumGroupPortfolioObjectIDs: function(){
			return _.map(me.ScrumGroupConfig, function(item){
				return item.ScrumGroupAndPortfolioLocationTheSame ? item.ScrumGroupRootProjectOID : item.PortfolioProjectOID;
			});
		},
		getPortfolioOIDForScrumGroupRootProjectRecord: function(scrumGroupRootProjectRecord){
			var configItem = _.find(this.ScrumGroupConfig, function(item){ 
				return item.ScrumGroupRootProjectOID === scrumGroupRootProjectRecord.data.ObjectID; 
			});
			return configItem.ScrumGroupAndPortfolioLocationTheSame ? configItem.ScrumGroupRootProjectOID : configItem.PortfolioProjectOID;
		},
		
		/**************************************** UserStory Funcs ************************************************/
		_getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: loadRandomUserStory');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: loadRandomUserStoryFromReleaseTimeframe');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me.userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me.reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: loadUserStoryByFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfType');
			var me = this;
			//US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
			if(type == 'Business Objective')
			{
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'PortfolioItem/' + type,
					limit: Infinity,
					disableMetaChangeEvent: true,
					remoteSort: false,
					fetch: me.portfolioItemFields,
					context: {
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp: true
					}
				});
			}
			else{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: false
						}
					});
			}
			return me.reloadStore(store);
		},		
		loadPortfolioItemsOfTypeInRelease: function(releaseRecord, portfolioProject, type){
			if(!releaseRecord || !portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfTypeInRelease');
			var me = this;
			//US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
			if(type == 'Business Objective')
			{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: true
						}
					});
			}
			else{
					store = Ext.create('Rally.data.wsapi.Store', {
						model: 'PortfolioItem/' + type,
						limit: Infinity,
						disableMetaChangeEvent: true,
						remoteSort: false,
						fetch: me.portfolioItemFields,
						filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
						context: {
							project: portfolioProject.data._ref,
							projectScopeDown: true,
							projectScopeUp: false
						}
					});
			}
			return me.reloadStore(store);
		},
		loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: loadPortfolioItemsOfOrdinal');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me.loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this.getPortfolioItemTypeStateByOrdinal(this.portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap: function(portfolioItemStores){
			var portfolioItemMap = {};
			_.each(portfolioItemStores[0].getRange(), function(lowPortfolioItemRecord){ //create the portfolioItem mapping
				var ordinal = 0, 
					parentPortfolioItemRecord = lowPortfolioItemRecord,
					getParentRecord = function(child, parentList){
						return _.find(parentList, function(parent){ 
							return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID; 
						});
					};
				while(ordinal < (portfolioItemStores.length-1) && parentPortfolioItemRecord){
					parentPortfolioItemRecord = getParentRecord(parentPortfolioItemRecord, portfolioItemStores[ordinal+1].getRange());
					++ordinal;
				}
				if(ordinal === (portfolioItemStores.length-1) && parentPortfolioItemRecord) //has a mapping, so add it
					portfolioItemMap[lowPortfolioItemRecord.data.ObjectID] = parentPortfolioItemRecord.data.Name;
			});
			return portfolioItemMap;
		},
			
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		_storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},
		getPorfolioProjectFilterQuery: function(rootProjectRecord){
			//filter out porfolio as project if train and porfolio is under same project
			//rootProjectRecord is optional
			var me = this,
				deferred = Q.defer(),
				filter = [];
			me.ScrumGroupAndPortfolioConfig =  _.filter(me.ScrumGroupConfig,function(train){return train.ScrumGroupRootProjectOID === rootProjectRecord.data.ObjectID; })[0];
			if(!rootProjectRecord || me.ScrumGroupAndPortfolioConfig.ScrumGroupAndPortfolioLocationTheSame) return Q();
			if(me.ScrumGroupPortfolioProject){
				filter =  Ext.create('Rally.data.wsapi.Filter', { property: 'Parent.ObjectID',operator: '!= ', value: me.ScrumGroupPortfolioProject.data.ObjectID });
				return Q(filter);
			}else{
			return me.loadScrumGroupPortfolioProject(rootProjectRecord)
				.then(function(scrumGroupPortfolioProject){
					me.ScrumGroupPortfolioProject = scrumGroupPortfolioProject;
					filter =   Ext.create('Rally.data.wsapi.Filter', { property: 'Parent.ObjectID',operator: '!= ', value: me.ScrumGroupPortfolioProject.data.ObjectID });
					return Q(filter);
				});				
			}
		},
        loadAllLeafProjectsForPortfolioDI:function(rootProjectRecord){
            //rootProjectRecord is optional
            var me = this,
                leafProjects = {};
            return me.getPorfolioProjectFilterQuery(rootProjectRecord)
                .then(function(filter){
                    var store = Ext.create('Rally.data.wsapi.Store', {
                        model: "Project",
                        fetch: me.projectFields,
                        //filters: filter ? [filter] : [],
                        compact: false,
                        limit:Infinity,
                        disableMetaChangeEvent: true,
                        context:{
                            workspace: me.getContext().getWorkspace()._ref,
                            project:null
                        }
                    });
                    return me.reloadStore(store).then(function(store){
                        if(rootProjectRecord){
                            var projTree = me._storeItemsToProjTree(store.getRange());
                            me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
                            return leafProjects;
                        } else {
                            return _.reduce(_.filter(store.getRange(),
                                function(project){ return project.data.Children.Count === 0; }),
                                function(map, project){
                                    map[project.data.ObjectID] = project;
                                    return map;
                                }, {});
                        }
                    });
                });
        },

		loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me = this,
			leafProjects = {};
			return me.getPorfolioProjectFilterQuery(rootProjectRecord)
				.then(function(filter){
					var store = Ext.create('Rally.data.wsapi.Store', {
							model: "Project",
							fetch: me.projectFields,
							filters: filter ? [filter] : [],
							compact: false,
							limit:Infinity,
							disableMetaChangeEvent: true,
							context:{
								workspace: me.getContext().getWorkspace()._ref,
								project:null
							}
						});	
					return me.reloadStore(store).then(function(store){
						if(rootProjectRecord){
							var projTree = me._storeItemsToProjTree(store.getRange());
							me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
							return leafProjects;
						} else {
							return _.reduce(_.filter(store.getRange(),
								function(project){ return project.data.Children.Count === 0; }),
								function(map, project){
									map[project.data.ObjectID] = project;
									return map;
								}, {});
						}
					});					
				});
		},
        loadMinimalLeafProjects: function(rootProjectRecord, fetchFields){
            //rootProjectRecord and fetchFields parameters are optional
            var me = this;
            var leafProjects = {};
            if(!fetchFields){
                fetchFields = me.projectFields;
            }
            return me.getPorfolioProjectFilterQuery(rootProjectRecord)
                .then(function(filter){
                    var store = Ext.create('Rally.data.wsapi.Store', {
                        model: "Project",
                        fetch: fetchFields,
                        filters: filter ? [filter] : [],
                        compact: true,
                        limit:Infinity,
                        disableMetaChangeEvent: true,
                        context:{
                            workspace: me.getContext().getWorkspace()._ref,
                            project:null
                        }
                    });
                    return me.reloadStore(store).then(function(store){
                        if(rootProjectRecord){
                            var projTree = me._storeItemsToProjTree(store.getRange());
                            me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
                            return leafProjects;
                        } else {
                            return _.reduce(_.filter(store.getRange(),
                                    function(project){ return project.data.Children.Count === 0; }),
                                function(map, project){
                                    map[project.data.ObjectID] = project;
                                    return map;
                                }, {});
                        }
                    });
                });
        },
		loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesAfterGivenDateByProjectObjID: function(projectObjectID, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},		
		loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesInTheFuture: function(projectRecord){
			return this.loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                /** 
	SUMMARY:
		This mixin is used if you want to listen to events in the parent window (e.g. useful for rally apps that 
		resize with browser screen vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run using fireParentWindowEvent
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		windowListeners = {};

	Ext.define('Intel.lib.mixin.WindowListener', {

		_initWindowEventListener: function(eventName){
			if(!windowListeners) windowListeners = {};
			windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		/** eventName is something like: resize, scroll, etc... */
		addWindowEventListener: function(eventName, fn){
			if(!windowListeners || !windowListeners[eventName]) 
				this._initWindowEventListener(eventName);
			windowListeners[eventName].push(fn);
		},
		
		/** eventName is something like: resize, scroll, etc... */
		fireParentWindowEvent: function(eventName){
			var me=this;
			if(!windowListeners || !windowListeners[eventName]) return;
			var listeners = windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** 
	SUMMARY:
		this mixin is used to mess with the environment outside of the iframe that the rally app is put in. 
		
	DEPENDENCIES:
		'Intel.lib.mixin.WindowListener' mixed in to app so listen for window events
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('Intel.lib.mixin.IframeResize', {
		requires: ['Intel.lib.mixin.WindowListener'],
		
		/**
			makes app as large as screen, without the padding/margin. 
			Makes it look more like a built-in rally app instead of a custom app.
			NOTE: as rally changes their interface overtime, this mixin will have to change as well to compensate for it.
			This changed once and all the classes names got changes. Thats why its commented out. 
		*/
		hideGearButtonAndCustomAppPanel: function(){
			var me = this;
			if(Ext.get(window.frameElement)){
				//hide the gear button for the first panel that has the App name
				Ext.get(window.frameElement).up('#content').down('.smb-Header').dom.querySelectorAll('.smb-HeaderGroupContainer--right')[0].style.display = 'none';
				//hides the whole custom html panel 
				Ext.get(window.frameElement).up('#content').down('.smb-Grid').down('.smb-Header').dom.style.display ='none';					
			}
		},
		_fixRallyDashboard: function(){ 
		/*	if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//remove vertical/horizontal scrolls from top window
				window.parent.document.body.insertAdjacentHTML('afterend', '<style>html, body {overflow: hidden !important; }</style>');
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 10) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING) - 10) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			} */
		},		
		initFixRallyDashboard: function(){ 
/*		var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard(); */
		},

		/** 
			hides the draggable resize handle from under the app 
		*/
		_disableResizeHandle: function(){ 
/*		var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			} */
		},	
		initDisableResizeHandle: function(){
/*		var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle(); */
		}
	});
}());
                /**  
	DESCRIPTION:
		This mixin gives a window-centered alert or confirm dialog box that isn't ugly. 
		
	ISSUES:
		Sometimes alert.setY() fails so we have to fallback to the ugly built-in alert
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.PrettyAlert', {	
		_getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_formatString: function(message){
			message = message || '';
			return (typeof message === 'string') ? 
				message : (message.message ? 
				message.message : JSON.stringify(message, null, '\t'));
		},

		/** non-ugly alert dialog */
		alert: function(title, message){
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			
			try {
				Ext.MessageBox.alert(this._formatString(title), this._formatString(message)).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ alert(this._formatString(message)); }
		},
		
		/** non-ugly confirm dialog */
		confirm: function(title, message, fn){
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			
			try {
				Ext.MessageBox.confirm(this._formatString(title), this._formatString(message), fn).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ if(confirm(this._formatString(message))) fn('yes'); else fn('no'); }
		}
	});
}());
                /** 
	intel workweek utility module. you can pass in Date objects, strings, or numbers.
	do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
**/
(function(){
	var Ext = window.Ext4 || window.Ext,
		intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('Intel.lib.mixin.IntelWorkweek', {
		/** calculates intel workweek, returns integer */
		getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		getWeekCount: function(_date){
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of Date()'s for each week start between start and end date*/
		getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this.roundDateDownToWeekStart(startDate),
				endWeekDate = this.roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		/** gets the Date() object of this ww and year */
		workweekToDate: function(ww, year){ 
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/** assumes DropDown uses Intel.lib.data.WorkweekDropdown model */
		getWorkweeksForDropdown: function(releaseStartDate, releaseEndDate){ 
			var workweeks = this.getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this.getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** 
	SUMMARY: 
		This mixin is used to save user preferences per project, that can follow the user from app to app. So 
		when you call saveAppsPreference it saves it to a preference filtered by user and the value of me.userAppsPref.
		
		Different apps can share the me.userAppsPref which is useful if you have 5 apps that should all scope to the same
		Release. So if the user scopes to Release R1 on one of the apps, when she goes to any of the other apps, it should
		scope to Release R1 as well.
**/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.UserAppsPreference', {
		
		/** preference name SHOULD be overridden, unless you want all apps to share default preference-name */
		userAppsPref: 'intel-user-apps-preference',
		
		loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName: me.userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me.userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me.userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName: me.userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                /** 
	SUMMARY:
		Use this mixin to load stores that have lots of records. it will load them in parallel instead of serially.
		what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.
		
		The config you pass to parallelLoadLookbackStore and parallelLoadWsapiStore are the same configs you would pass
		to Rally.data.lookback.Store (or something like that) and Rally.data.wsapi.Store.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.mixin.ParallelLoader', {		
		parallelLoadWsapiStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
						pageSize:200,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.wsapi.Store', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/200>>0) + (store.totalCount%200 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		},
		parallelLoadLookbackStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
						pageSize:20000,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/20000>>0) + (store.totalCount%20000 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		}
	});
}());

                /** 
	SUMMARY:
		This mixin is used to communicate between apps the objectID of eachother, so they can link to eachother
		by saving their ObjectIDs in a preference tied to the workspace. 
		
		To get the ObjectID of an app in teh workspace, you need to pass the ClassName of the app,
		which is the string that you pass you Ext.define(<className>, {appConfigObject})
	
	DEPENDENCIES:
		Q promise library
**/
(function(){
	var Ext = window.Ext4 || window.Ext,
		customAppRegisterObjectIdPref = 'intel-custom-app-objectid-register-preference';

	Ext.define('Intel.lib.mixin.CustomAppObjectIDRegister', {
		_loadCustomAppObjectIDSettings: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: customAppRegisterObjectIdPref,
				success: function(prefs){
					var map;
					try{ map = JSON.parse(prefs[customAppRegisterObjectIdPref]); }
					catch(e){ map = {}; }
					deferred.resolve(map);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		getCustomAppObjectID: function(appClassName){
			var me=this;
			return me._loadCustomAppObjectIDSettings().then(function(customAppOIDSettings){
				return customAppOIDSettings[appClassName] || null;
			});
		},
		setCustomAppObjectID: function(appClassName){
			var me=this, s = {},
				//addding updater script in the url
				objectID = window.parent.location.hash.split("?")[0].split("/").pop();
			if(!appClassName) return Q.reject('invalid appClassName');
			return me._loadCustomAppObjectIDSettings().then(function(customAppOIDSettings){
				var deferred = Q.defer();
				customAppOIDSettings[appClassName] = objectID;
				s[customAppRegisterObjectIdPref] = JSON.stringify(customAppOIDSettings, null, '  ');
				Rally.data.PreferenceManager.update({
					workspace: me.getContext().getWorkspace()._ref,
					filterByName: customAppRegisterObjectIdPref,
					settings: s,
					success: deferred.resolve,
					failure: deferred.reject
				});
				return deferred.promise;
			});
		}
	});
}());
                /**
	This mixin exposes a few public methods that allow the caller to easily get 
	info about the horizontal and teamTypeInfo for a list of projects.
	
	The reason that you should ALWAYS call getAllHorizontalTeamTypeInfos with multiple 
	projects instead of getHorizontalTeamTypeInfo 1 project is because this allows the 
	'number' field of the teamTypeInfo to be set correctly.
	For example:
		You have projects: ['MPV 1', 'MPV 2', 'MVP OR'],
		this will map to: ['MPV 1', 'MPV 2', 'MPV 3']
		but if you passed all three separately: ['MPV 1'], ['MPV 2'], ['MVP OR'],
		you would end up with 2 'MPV 1's: ['MPV 1'], ['MPV 2'], ['MVP 1'],
		
	The above example shows that the algorithm tries to set the numbers of teams
	with no numbers. the numbers assigned to these will be relative to the other
	projects passed in. That is why you will ALMOST ALWAYS WASNT TO PASS IN ALL
	PROJECTS OF A TRAIN AT ONCE!
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.HorizontalTeamTypes', {
		requires:['Intel.lib.IntelRallyApp'],
		
		_getHorizontalTeamTypeInfo: function(projectRecord){
			var me=this,
				scrumName = projectRecord.data.Name.split('-')[0].trim(), //.replace(/\(.*\)/g, '')
				scrumTeamType = scrumName.split(/\d/)[0].trim(),
				number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
				notInHorizontalObject = {
					projectRecord: projectRecord,
					horizontal:null, 
					teamType:scrumTeamType,
					teamTypeComponents: [],
					number:number
				},
				teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function(result, teamTypes, horizontal){
					if(result) return result; 
					else {
						var teamTypeMatches = _.reduce(teamTypes, function(teamTypeMatches, teamType){
							/**
								If the teamType is in the name of the scrum, add it to teamTypeMatches.
								If there is another teamType already added that is a substring of this teamType,
								remove it from the teamType matches. If the current teamType is a substring of another
								teamType already matches, DO NOT add this teamType to the matched teamTypes
								
								Example:	
									scrum name="ABC - Train"
									teamType options:["AB" "ABC" "ABCD"]
											
									the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
							*/
							if(scrumName.indexOf(teamType) > -1){
								for(var i=teamTypeMatches.length-1;i>=0;--i){
									if(teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
									if(teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
								}
								teamTypeMatches.push(teamType);
							}
							return teamTypeMatches;
						}, []);
						return teamTypeMatches.length ? {
								projectRecord: projectRecord,
								horizontal:horizontal, 
								teamType: teamTypeMatches.sort().join(' '), 
								teamTypeComponents: teamTypeMatches.sort(),
								number:number
							} : 
							null;
					}
				}, null);
			return teamTypeObject || notInHorizontalObject;
		},	
		_resolveTeamTypeInfoConflicts: function(teamTypeInfos, startIndex){
			startIndex = startIndex || 1;
			_.each(_.sortBy(teamTypeInfos, 
				function(teamTypeInfo){ return teamTypeInfo.projectRecord.data.Name; }),
				function(teamTypeInfo, index){ teamTypeInfo.number = index + startIndex; return teamTypeInfo; });
		},
		getAllHorizontalTeamTypeInfos: function(projectRecords){
			var me = this;
			return [].concat.apply([], _.map(_.groupBy(_.map(projectRecords, 
				function(projectRecord){ return me._getHorizontalTeamTypeInfo(projectRecord); }),
				function(teamTypeInfo){ return teamTypeInfo.teamType; }),
				function(teamTypeInfos){
					if(teamTypeInfos.length === 1) return teamTypeInfos; 
					else {
						var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function(teamTypeInfo){ return teamTypeInfo.number === 1; });
						if(teamTypeInfosWithNumber1.length > 1){
							var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function(teamTypeInfo){ 
									return teamTypeInfo.projectRecord.data.Name.indexOf('1') === -1; 
								}),
								startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
							me._resolveTeamTypeInfoConflicts(projectsWithoutExplicit1, startIndex);
						}
						return teamTypeInfos;
					}
				})
			);
		},
		getHorizontalTeamTypeInfo: function(projectRecord){
			return this._getHorizontalTeamTypeInfo(projectRecord);
		},
		isProjectInHorizontal: function(projectRecord, horizontal){
			return this._getHorizontalTeamTypeInfo(projectRecord).horizontal === horizontal;
		},
		
		_getHorizontalTeamTypeInfoFromProjectName: function(projectName){
			var me=this,
				scrumName = projectName.split('-')[0].trim(), //.replace(/\(.*\)/g, '')
				scrumTeamType = scrumName.split(/\d/)[0].trim(),
				number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
				notInHorizontalObject = {
					projectName: projectName,
					horizontal:null, 
					teamType:scrumTeamType,
					teamTypeComponents: [],
					number:number
				},
				teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function(result, teamTypes, horizontal){
					if(result) return result; 
					else {
						var teamTypeMatches = _.reduce(teamTypes, function(teamTypeMatches, teamType){
							/**
								If the teamType is in the name of the scrum, add it to teamTypeMatches.
								If there is another teamType already added that is a substring of this teamType,
								remove it from the teamType matches. If the current teamType is a substring of another
								teamType already matches, DO NOT add this teamType to the matched teamTypes
								
								Example:	
									scrum name="ABC - Train"
									teamType options:["AB" "ABC" "ABCD"]
											
									the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
							*/
							if(scrumName.indexOf(teamType) > -1){
								for(var i=teamTypeMatches.length-1;i>=0;--i){
									if(teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
									if(teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
								}
								teamTypeMatches.push(teamType);
							}
							return teamTypeMatches;
						}, []);
						return teamTypeMatches.length ? {
								projectName: projectName,
								horizontal:horizontal, 
								teamType: teamTypeMatches.sort().join(' '), 
								teamTypeComponents: teamTypeMatches.sort(),
								number:number
							} : 
							null;
					}
				}, null);
			return teamTypeObject || notInHorizontalObject;
		},
		_resolveTeamTypeInfoConflictsFromProjectNames: function(teamTypeInfos, startIndex){
			startIndex = startIndex || 1;
			_.each(_.sortBy(teamTypeInfos, 
				function(teamTypeInfo){ return teamTypeInfo.projectName; }),
				function(teamTypeInfo, index){ teamTypeInfo.number = index + startIndex; return teamTypeInfo; });
		},	
		getAllHorizontalTeamTypeInfosFromProjectNames: function(projectNames){
			var me = this;
			return [].concat.apply([], _.map(_.groupBy(_.map(projectNames, 
				function(projectName){ return me._getHorizontalTeamTypeInfoFromProjectName(projectName); }),
				function(teamTypeInfo){ return teamTypeInfo.teamType; }),
				function(teamTypeInfos){
					if(teamTypeInfos.length === 1) return teamTypeInfos; 
					else {
						var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function(teamTypeInfo){ return teamTypeInfo.number === 1; });
						if(teamTypeInfosWithNumber1.length > 1){
							var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function(teamTypeInfo){ 
									return teamTypeInfo.projectName.indexOf('1') === -1; 
								}),
								startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
							me._resolveTeamTypeInfoConflictsFromProjectNames(projectsWithoutExplicit1, startIndex);
						}
						return teamTypeInfos;
					}
				})
			);
		},		
		getHorizontalTeamTypeInfoFromProjectName: function(projectName){
			return this._getHorizontalTeamTypeInfoFromProjectName(projectName);
		},
		isProjectNameInHorizontal: function(projectName, horizontal){
			return this._getHorizontalTeamTypeInfoFromProjectName(projectName).horizontal === horizontal;
		},
		
		getAllHorizontalTeamTypeComponents: function(){
			return [].concat.apply([], _.values(this.HorizontalGroupingConfig.groups));
		},
		getAllHorizontals: function(){
			return _.keys(this.HorizontalGroupingConfig.groups);
		},
		teamTypeComponentInWhichHorizontal: function(teamType){
			var me=this;
			return _.find(_.keys(me.HorizontalGroupingConfig.groups), function(hz){ 
				return _.contains(me.HorizontalGroupingConfig.groups[hz], teamType);
			});
		}
	});
}());

                /** 
	SUMMARY:
		This combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.component.ComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					change: function(a,b){
						if(!b || (b.keyCode>=37 && b.keyCode <=40)) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							var escapedValue = combo.getRawValue().replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
							return item.data[combo.displayField].match(new RegExp(escapedValue, 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                /** 
	SUMMARY:
		This combo has some built in defaults for static-comboboxes (which means you dont type into it, you just select from it)
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.FixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		editable: false,	
		allowBlank:true,
		queryMode:'local',
		matchFieldWidth: false,
		listeners: {
			change:function(combo, newval, oldval){ 
				if(newval.length===0) combo.setValue(oldval || ''); 
			},
			focus: function(combo) {
				if(combo.store.findExact(combo.valueField, combo.getValue()) === -1) combo.setValue('');
				combo.expand();
			}
		}
	});
}());
                /** 
	SUMMARY:
		This component is an easy release picker based off Intel.lib.component.FixedComboBox. You supply the 
		Release Records to it on construction.
		
		YOU MUST PASS IT 2 THINGS IN THE CONFIG
			1: releases (array of release records)
			2: currentRelease (what to show as initial value
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.ReleasePicker', {
		extend: 'Intel.lib.component.FixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                /**
 SUMMARY:

 ------------------------------------------------ RALLY APP REQUIREMENTS ---------------------------------------------------------------------
 app MUST impelement the following functions:

 - cacheKeyGenerator() -> string                                        (return the 'key' the cache mixin should store/load/delete the data under)
 - getCacheTimeoutDate() -> Date                                        (returns the date the cache should timeout from relative to NOW)
 - getCachePayloadFn(payload)                                            (JSON data that was returned from the cache is passed to this function after a cache-hit)
 - setCachePayLoadFn(payload)                                            (add fields to the json payload to be stored in the cache)
 - getCacheUrlSetting()                                                        (add app setting for the cacheUrl)

 the app has the following cache functions added to it:

 - getCache() -> Promise(cacheHit)                 (cacheHit === true if successfully got cache from server)
 - updateCache() -> Promise()                      (returns when the cache has been successfully updated)
 - deleteCache() -> Promise()                      (returns when the cache has been successfully delete)

 ------------------------------------------------ SERVER REQUIREMENTS ---------------------------------------------------------------------
 This mixin is used to enable caching for large apps that pull lots of data. This requires that you also
 set up a server to handle the key/value database. The server should support timeouts and it should
 gzip the PUTted cache JSON payloads for faster transmission times for the cache hits (35 MB takes a while
 to send, gzip can take a 35 MB JSON down to 1 MB). Since the server should gzip, it should also set the
 Content-Encoding = gzip when it returns cached data. Lastly, you should also have an updater script that
 runs periodically and updates the cache. This cache mixin and the updater script should agree to the following
 terms:

 the script loads the page with the following query parameter:
 rally/projectId/stuff/data-ingrity-oibjectid?cache-update-script=true

 the app adds an invisible div with id="cache-mixin-update-complete"

 The script (phantomjs probably), should wait for the above <div> to be placed to know it is finished. There
 should be a 5 minute timeout for errors on loading as well:
 */

(function () {
    var Ext = window.Ext4 || window.Ext;

    Ext.define('Intel.lib.mixin.Caching', {
        getCache: function () {
            var me = this;
            var key = me.cacheKeyGenerator(); //generate key for the app
            var cacheUrl = me.getCacheUrlSetting();
            var isUpdateScript = me._isCacheUpdateScript();
            var url = cacheUrl + key;
            var deferred = Q.defer();
            $('#cache-mixin-update-complete', window.parent.document).remove();//remove and add each time
            if (typeof key === 'undefined' || _.isEmpty(cacheUrl) || isUpdateScript) {
                return Q.resolve(false); //pretend there was cache miss
            }
            $.ajax({
                url: url,
                method: 'GET',
                processData: false,
                dataType: 'text',
                success: function (requestData, status, xhr) {
                    try {
                        me.lastCacheModified = Rally.util.DateTime.format(new Date(xhr.getResponseHeader('Last-Modified')), 'D M d Y h:i:s a') + " (Pacific Daylight Time)";
                        payload = JSON.parse(requestData);
                        me._getCacheIntelRallyAppSettings(payload);
                        Q(me.getCachePayloadFn(payload)).then(function () {
                            deferred.resolve(true);
                        });
                    }
                    catch (e) {
                        console.log('corrupt cache payload');
                        console.error(e);
                        deferred.resolve(false);
                    }
                },
                error: function (reason) {
                    console.log('Cache GET error: This could mean either it failed to get the cache, or the cache file does not exist.', reason);
                    deferred.resolve(false);
                }
            });

            return deferred.promise;
        },
        updateCache: function () {
            var me = this;
            var payload = {};
            var key = me.cacheKeyGenerator(); //generate key for the app
            var cacheUrl = me.getCacheUrlSetting();
            var timeoutDate = me.getCacheTimeoutDate();
            var isUpdateScript = me._isCacheUpdateScript();
            var url = cacheUrl + key;
            var deferred = Q.defer();

            if (typeof key === 'undefined' || _.isEmpty(cacheUrl)) {
                return Q.reject('Cannot PUT to cache, invalid key or invalid cacheUrl');
            }

            if (timeoutDate) {
                url += '?timeout=' + timeoutDate.toISOString();
            }

            me._setIntelRallyAppSettings(payload);
            me.setCachePayLoadFn(payload);
            var jsonData = JSON.stringify(payload);

            $.ajax({
                url: url,
                method: 'PUT',
                headers: {'Content-Type': 'text/plain'},
                data: jsonData,
                processData: false,
                success: function () {
                    if (isUpdateScript) {
                        $(window.parent.document.body).append('<div id="cache-mixin-update-complete"></div>'); //signal to update script that we are finished
                    }
                    deferred.resolve();
                },
                error: function (reason) {
                    deferred.reject(reason);
                }
            });
            return deferred.promise;
        },
        deleteCache: function (keyGenerator) {
            var me = this;
            var key = me.cacheKeyGenerator(); //generate key for the app
            var cacheUrl = me.getCacheUrlSetting();
            var deferred = Q.defer();
            var url = cacheUrl + key;

            if (typeof key === 'undefined' || _.isEmpty(cacheUrl)) {
                return Q.reject('cannot DELETE from cache, invalid key');
            }

            $.ajax({
                url: url,
                type: 'DELETE',
                success: function (data) {
                    deferred.resolve(data);
                },
                error: function (xhr, status, reason) {
                    deferred.reject(reason);
                }
            });

            return deferred.promise;
        },
        _isCacheUpdateScript: function () {
            return decodeURI(window.parent.location.href).indexOf('cache-update-script=true') > -1;
        },
        _getCacheIntelRallyAppSettings: function (payload) {
            var me = this;
            //intel-rally-app sets these (copy these for each app that uses the cache!)
            me.BaseUrl = Rally.environment.getServer().getBaseUrl();
            me.PortfolioItemTypes = payload.PortfolioItemTypes || [];
            if(me.PortfolioItemTypes.length) {
                me.userStoryFields.push(me.PortfolioItemTypes[0]);  //userStoryFields supposed to be lowercase, dont worry
            } else {
                me.userStoryFields = [];
            }
            me.ScrumGroupConfig = payload.ScrumGroupConfig;
            me.HorizontalGroupingConfig = payload.HorizontalGroupingConfig;
            me.ScheduleStates = payload.ScheduleStates;
        },
        _setIntelRallyAppSettings: function (payload) {
            var me = this;
            payload.PortfolioItemTypes = me.PortfolioItemTypes;
            payload.ScrumGroupConfig = me.ScrumGroupConfig;
            payload.HorizontalGroupingConfig = me.HorizontalGroupingConfig;
            payload.ScheduleStates = me.ScheduleStates;
        }
    });
}());		
                /**
 This is the hyper-optimized version of the Data Integrity Dashboard. It is capable of viewing
 integrity both horizontally and vertically. Use of lodash is minimized for the sake of reducing
 function overhead and increasing performance (SS: i dont think lodash usage is as big a deal as network
 overhead and DOM manipulation)(SS: but little things add up over time)(SS: i dont need you for
 this conversation)
 */
(function () {
    var Ext = window.Ext4 || window.Ext;

    /*------------------------------------IMPORTANT--------------------------------------
     "isLocalDev" variable:
     - IMPORTANT: Change to true if you are running locally (http-server, localhost)
     - IMPORTANT: Make sure to set it to false before checking the code or publishing to rally
     ----------------------------------------------------------------------------------*/
    var isLocalDev = false;

    //You can only get the Rally environment in Rally, not in local dev.
    if (Rally.environment) {
        var context = Rally.environment.getContext();
        var SETTINGS_TOKEN = context.getProject().ObjectID.toString();
    } else {
        console.log("Rally.environment is undefined. Setting Settings token to 59951441366.");
        var SETTINGS_TOKEN = "59951441366";
    }

    /*----------------------------------------------------------------------------------
     Rule categories are defined here, and used throughout this file.
     To add or remove a rule, you need to edit it here, and in the gridConfigs array.
     This also defines a color for each rule.
     ----------------------------------------------------------------------------------*/
    var ruleCategories = [
        "Epics with No Parent",
        "Epics with No Start or End date",
        "Unaccepted Epics Past End Date",
        "Unaccepted Features Past End Date",
        "Features with No Parent",
        "Features with No Start or End Date",
        "Features with No Stories"
    ];

    /*----------------------------------------------------------------------------------
     Changes each rule category to lower case and replaces spaces with dashes.
     ----------------------------------------------------------------------------------*/
    var ruleCategorySelectors = [];
    _.each(ruleCategories, function (ruleString) {
        ruleCategorySelectors.push(ruleString.replace(/\s+/g, '-').toLowerCase());
    });

    /************************** Data Integrity Dashboard *****************************/
    Ext.define('Intel.PortfolioDataIntegrityDashboard', {
        extend: 'Intel.lib.IntelRallyApp',
        cls: 'app',
        mixins: [
            'Intel.lib.mixin.WindowListener',
            'Intel.lib.mixin.PrettyAlert',
            'Intel.lib.mixin.IframeResize',
            'Intel.lib.mixin.IntelWorkweek',
            'Intel.lib.mixin.ParallelLoader',
            'Intel.lib.mixin.CustomAppObjectIDRegister',
            'Intel.lib.mixin.HorizontalTeamTypes',
            'Intel.lib.mixin.Caching'
        ],
        /**************************************** Settings ***************************************/
        settingsScope: 'workspace',
        getSettingsFields: function () {
            return [
                {
                    name: 'Horizontal',
                    xtype: 'rallycheckboxfield'
                }, {
                    name: 'cacheUrl',
                    xtype: 'rallytextfield'
                },
                {
                    name: ruleCategories[0] + SETTINGS_TOKEN,
                    label: ruleCategories[0],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory0'
                }, {
                    name: ruleCategories[1] + SETTINGS_TOKEN,
                    label: ruleCategories[1],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory1'
                }, {
                    name: ruleCategories[2] + SETTINGS_TOKEN,
                    label: ruleCategories[2],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory2'
                }, {
                    name: ruleCategories[3] + SETTINGS_TOKEN,
                    label: ruleCategories[3],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory3'
                }, {
                    name: ruleCategories[4] + SETTINGS_TOKEN,
                    label: ruleCategories[4],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory4'
                }, {
                    name: ruleCategories[5] + SETTINGS_TOKEN,
                    label: ruleCategories[5],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory5'
                }, {
                    name: ruleCategories[6] + SETTINGS_TOKEN,
                    label: ruleCategories[6],
                    xtype: 'rallycheckboxfield',
                    labelWidth: 120,
                    width: '100%',
                    id: 'ruleCategory6'
                }
            ];
        },
        config: {
            defaultSettings: {
                ruleCategory0: true,
                ruleCategory1: true,
                ruleCategory2: true,
                ruleCategory3: true,
                ruleCategory4: true,
                ruleCategory5: true,
                ruleCategory6: true,
                cacheUrl: 'https://localhost:45557/api/v1.0/custom/rally-app-cache/'
            }
        },
        minWidth: 1100,
        /**
         This layout consists of:
         Top horizontal bar for controls
         Horizontal bar for a pie chart and heat map (the 'ribbon')
         Two columns (referred to as Left and Right) for grids
         */
        items: [{
            xtype: 'container',
            id: 'cacheButtonsContainer'
        }, {
            xtype: 'container',
            id: 'navContainer',
            layout: 'hbox',
            items: [{
                xtype: 'container',
                id: 'controlsContainer',
                layout: 'vbox',
                width: 260
            }, {
                xtype: 'container',
                id: 'emailLinkContainer',
                width: 150
            }, {
                xtype: 'container',
                id: 'cacheMessageContainer'
            }, {
                xtype: 'container',
                id: 'integrityIndicatorContainer',
                flex: 1
            }]
        }, {
            xtype: 'container',
            id: 'ribbon',
            cls: 'ribbon',
            layout: 'column',
            items: [{
                xtype: 'container',
                width: 480,
                id: 'pie'
            }, {
                xtype: 'container',
                columnWidth: 0.999,
                id: 'heatmap'
            }]
        }, {
            xtype: 'button',
            id: 'expand-heatmap-button',
            text: 'Expand Heatmap'
        }, {
            xtype: 'container',
            id: 'gridsContainer',
            cls: 'grids-container',
            layout: 'column',
            items: [{
                xtype: 'container',
                columnWidth: 0.495,
                id: 'gridsLeft',
                cls: 'grids-left'
            }, {
                xtype: 'container',
                columnWidth: 0.495,
                id: 'gridsRight',
                cls: 'grids-right'
            }]
        }],
        chartColors: [
            '#AAAAAA', //GRAY
            '#2ECC40', //GREEN
            '#7FDBFF', //AQUA
            '#DDDDDD', //SILVER
            '#39CCCC', //TEAL
            '#01FF70', //LIME
            '#FFDC00', //YELLOW
            '#0074D9', //BLUE
            '#AAAAAA', //GRAY
            '#2ECC40', //GREEN
            '#7FDBFF', //AQUA
            '#DDDDDD', //SILVER
            '#39CCCC', //TEAL
            '#01FF70', //LIME
            '#FFDC00', //YELLOW
            '#0074D9' //BLUE
        ],
        /******************************************************* Caching Mixin operations ********************************************************/
        /**
         NOTE: this requires that me.PortfolioItemTypes is already populated. This is done in
         the _getCacheIntelRallyAppSettings() function of caching.js
         */
        _loadModelsForCachedView: function () {
            var me = this,
                promises = [],
                models = {UserStory: 'HierarchicalRequirement'};
            models['PortfolioItem/' + me.PortfolioItemTypes[0]] = 'PortfolioItem/' + me.PortfolioItemTypes[0];
            _.each(models, function (modelType, modelName) {
                var deferred = Q.defer();
                Rally.data.WsapiModelFactory.getModel({
                    type: modelType,
                    success: function (loadedModel) {
                        me[modelName] = loadedModel;
                        deferred.resolve();
                    }
                });
                promises.push(deferred.promise);
            });
            return Q.all(promises);
        },
        getCacheUrlSetting: function () {
            var me = this;
            return me.getSetting('cacheUrl');
        },
        getCachePayloadFn: function (payload) {
            var me = this;

            me.ProjectRecord = payload.ProjectRecord;
            //me.isScopedToScrum = payload.isScopedToScrum ;
            me.ScrumGroupRootRecords = payload.ScrumGroupRootRecords;
            me.ScrumGroupPortfolioOIDs = payload.ScrumGroupPortfolioOIDs;
            me.LeafProjects = payload.LeafProjects;
            me.LeafProjectsByScrumGroup = payload.LeafProjectsByScrumGroup;
            me.LeafProjectsByHorizontal = payload.LeafProjectsByHorizontal;
            me.LeafProjectsByTeamTypeComponent = payload.LeafProjectsByTeamTypeComponent;
            me.ScrumGroupRootRecords = payload.ScrumGroupRootRecords;
            me.FilteredLeafProjects = payload.FilteredLeafProjects;
            me.PortfolioProjectToPortfolioItemMap = payload.PortfolioProjectToPortfolioItemMap;
            me.PortfolioUserStoryCount = payload.PortfolioUserStoryCount;

            return me._loadModelsForCachedView().then(function () {
                me.UserStoryStore = Ext.create('Rally.data.wsapi.Store', {
                    autoLoad: false,
                    model: me.UserStory,
                    pageSize: 200,
                    data: payload.UserStories
                });
                me.fixRawUserStoryAttributes();
                me.fixScheduleStateEditor();
                me.PortfolioItemStore = Ext.create('Rally.data.custom.Store', {
                    autoLoad: false,
                    model: me['PortfolioItem/' + me.PortfolioItemTypes[0]],
                    pageSize: 200,
                    data: []
                });
            });
        },
        setCachePayLoadFn: function (payload) {
            var me = this,
                lowestPortfolioItem = me.PortfolioItemTypes[0],
                userStoryFields = ['Name', 'ObjectID', 'Project', 'Iteration',
                    'Release', 'PlanEstimate', 'FormattedID', 'ScheduleState', 'Owner',
                    'Blocked', 'BlockedReason', 'Blocker', 'CreationDate', lowestPortfolioItem, '_p', '_ref',
                    '_refObjectUUID', '_type', '_objectVersion', '_CreatedAt'],
                portfolioItemFields = ['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate',
                    'Release', 'Description', 'FormattedID', 'UserStories', 'Parent', '_p', '_ref',
                    '_refObjectUUID', '_type', '_objectVersion', '_CreatedAt', 'InvestmentCategory',
                    'DirectChildrenCount'],
                projectFields = ['Children', 'Name', 'ObjectID', 'Parent'];

            function filterProjectData(projectData) {
                var data = _.pick(projectData, projectFields);
                data.Parent = _.pick(data.Parent, projectFields);
                data.Children = _.pick(data.Children, ['Count']);
                return {data: data};
            }

            function filterUserStoryForCache(userStoryRecord) {
                var data = _.pick(userStoryRecord.data, userStoryFields);
                data.Iteration = data.Iteration ? _.pick(data.Iteration, ['EndDate', 'Name', 'ObjectID', 'StartDate', '_refObjectName']) : null;
                data.Project = _.pick(data.Project, ['Name', 'ObjectID', '_refObjectName']);
                data.Owner = _.pick(data.Owner, ['_refObjectName']);
                data.Release = data.Release ? _.pick(data.Release, ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate']) : null;
                return data;
            }

            payload.ProjectRecord = filterProjectData(me.ProjectRecord.data);
            //	payload.isScopedToScrum = me.isScopedToScrum ;
            payload.ScrumGroupRootRecords = _.map(me.ScrumGroupRootRecords, function (ss) {
                return filterProjectData(ss.data);
            });
            payload.ScrumGroupPortfolioOIDs = me.ScrumGroupPortfolioOIDs;
            payload.LeafProjects = _.map(me.LeafProjects, function (ss) {
                return filterProjectData(ss.data);
            });
            payload.LeafProjectsByScrumGroup = _.reduce(me.LeafProjectsByScrumGroup, function (map, sss, key) {
                map[key] = _.map(sss, function (ss) {
                    return filterProjectData(ss.data);
                });
                return map;
            }, {});
            payload.LeafProjectsByHorizontal = _.reduce(me.LeafProjectsByHorizontal, function (map, sss, key) {
                map[key] = _.map(sss, function (ss) {
                    return filterProjectData(ss.data);
                });
                return map;
            }, {});
            payload.LeafProjectsByTeamTypeComponent = _.reduce(me.LeafProjectsByTeamTypeComponent, function (map, sss, key) {
                map[key] = _.map(sss, function (ss) {
                    return filterProjectData(ss.data);
                });
                return map;
            }, {});
            payload.FilteredLeafProjects = _.map(me.FilteredLeafProjects, function (ss) {
                return filterProjectData(ss.data);
            });
            payload.PortfolioProjectToPortfolioItemMap = _.reduce(me.PortfolioProjectToPortfolioItemMap, function (map, sss, key) {
                map[key] = _.map(sss, function (ss) {
                    return _.pick(ss.data, portfolioItemFields);
                });
                return map;
            }, {});
            payload.PortfolioUserStoryCount = me.PortfolioUserStoryCount;

            payload.UserStories = _.map(me.UserStoryStore.getRange(), filterUserStoryForCache);
        },
        cacheKeyGenerator: function () {
            var me = this;
            var projectOID = me.getContext().getProject().ObjectID;
            var horizontalName = "";
            if (me.isHorizontalView) {
                var horizontalInUrl = !me.isScopedToScrum && me.isHorizontalView && !me.ScopedTeamType;
                horizontalName = horizontalInUrl ? me.Overrides.ScopedHorizontal : me.HorizontalTeamTypeInfo.horizontal;
                horizontalName = horizontalName ? horizontalName : (!me.ScopedHorizontalPicker ? _.keys(me.HorizontalGroupingConfig.groups).sort()[0] : me.ScopedHorizontalPicker.value);
            }
            var releaseOID = me.ReleaseRecord.data.ObjectID;
            var releaseName = me.ReleaseRecord.data.Name;
            return 'DI-' + (me.isHorizontalView ? horizontalName : projectOID) + '-' + (me.isHorizontalView ? releaseName : releaseOID);
        },
        getCacheTimeoutDate: function () {
            return new Date(new Date() * 1 + 1000 * 60 * 60);
        },

        loadNonConfigDataFromCacheOrRally: function () {
            var me = this;
            return me.loadData().then(function () {
            });
        },
        loadDataFromCacheOrRally: function () {
            var me = this;
            if (me.isHorizontalView) me.applyProjectFilters();
            else me.applyScopingOverrides();
            return me.loadRemainingConfiguration()
                .then(function () {
                    return me.loadData();
                });
        },
        loadCacheIndependentConfig: function () {
            var me = this;
            return Q.all([
                me.isHorizontalView ? me._loadHorizontalGroupingConfig() : Q(),
                me.loadReleases()
            ])
                .then(function () {
                    if (me.isHorizontalView && !me.isStandalone) {
                        me.ProjectRecord = me.createDummyProjectRecord(me.getContext().getProject());
                        me.HorizontalTeamTypeInfo = me.getHorizontalTeamTypeInfoFromProjectName(me.ProjectRecord.data.Name);
                        me.applyScopingOverrides();
                    }
                });
        },
        /******************************************************* LAUNCH ********************************************************/
        launch: function () {
            var me = this;
            me.rules = [];

            /*----------------------------------------------------------------------------------
             For production/rally official only. Not for local dev/localhost.
             ----------------------------------------------------------------------------------*/
            if (!isLocalDev) {
                me.isHorizontalView = me.getSetting('Horizontal');
                //For each of the rule categories, get the setting checkbox value
                _.each(ruleCategories, function (item, index) {
                    var ruleSetting = (ruleCategories[index] + SETTINGS_TOKEN);
                    //me.rules[index] = me.getSetting(ruleCategories[index]);
                    me.rules[index] = me.getSetting(ruleSetting);
                    //console.log(">> ", index, ": ruleSetting: ", ruleSetting);
                    //console.log(">> ",index, ": me.getSetting(ruleSetting): ", me.getSetting(ruleSetting));
                    //console.log(">> me.rules[" + index + "]: " + me.rules[index]);
                });
            } else {
                /*----------------------------------------------------------------------------------
                 For local development/http-server localhost. Not for Rally/production
                 ----------------------------------------------------------------------------------*/
                me.isHorizontalView = false;
                //for each of the rule categories, set the checkbox value to true
                _.each(ruleCategories, function (item, index) {
                    me.rules[index] = true;
                });
                //Optional: if you want to change one of the rules to false, for local dev, do it here.
            }

            // me.initDisableResizeHandle();
            // me.initFixRallyDashboard();
            me.initRemoveTooltipOnScroll();
            me.processURLOverrides();

            me.setLoading('Loading Configuration');
            me.loadCacheIndependentConfig()
                .then(function () {
                    return me.loadDataFromCacheOrRally();
                })
                .then(function () {
                    return me.loadUI();
                })
                .then(function () {
                    return me.registerCustomAppId();
                })
                .fail(function (reason) {
                    me.setLoading(false);
                    me.alert('ERROR', reason);
                })
                .done();
        },

        /**************************************** registerCustomAppId ***************************************/
        registerCustomAppId: function () {
            return this.setCustomAppObjectID(this.getSetting('Horizontal') ?
                    'Intel.PortfolioDataIntegrityDashboard.Horizontal' :
                    'Intel.PortfolioDataIntegrityDashboard.Vertical'
            );
        },

        /**************************************** Loading Config Items ***********************************/
        /**
         load releases for current scoped project and set the me.ReleaseRecord appropriately.
         */
        loadReleases: function () {
            var me = this,
                twelveWeeksAgo = new Date(new Date() * 1 - 12 * 7 * 24 * 60 * 60 * 1000),
                projectRecord = me.createDummyProjectRecord(me.getContext().getProject());

            return me.loadReleasesAfterGivenDate(projectRecord, twelveWeeksAgo).then(function (releaseRecords) {
                me.ReleaseRecords = releaseRecords;

                // Set the current release to the release we're in or the closest release to the date
                // Important! This sets the current release to an overridden value if necessary
                me.ReleaseRecord = (me.isStandalone ?
                    _.find(me.ReleaseRecords, function (release) {
                        return release.data.Name === me.Overrides.ReleaseName;
                    }) :
                    false) ||
                me.getScopedRelease(me.ReleaseRecords, null, null);
            });
        },

        loadRemainingConfiguration: function () {
            var me = this;
            me.ProjectRecord = me.createDummyProjectRecord(me.getContext().getProject());
            //for horizontal view you want to make sure that projects from all the trains are loaded not just that project
            if (!isLocalDev && me.ProjectRecord.data.Children) {
                me.isScopedToScrum = me.isHorizontalView ? false : ( me.ProjectRecord.data.Children.count === 0);
            } else {
                //for Local development/http-server localhost
                me.isScopedToScrum = false;//set this to true for team scoping in local dev, and false for train scoping.
            }

            return me.configureIntelRallyApp()
                .then(function () {
                    //things that need to be done immediately after configuraing app
                    me.fixScheduleStateEditor();
                    if (me.isHorizontalView && (!me.HorizontalGroupingConfig || !me.HorizontalGroupingConfig.enabled))
                        throw "workspace is not configured for horizontals";
                })
                .then(function () {
                    return me.loadScrumGroups();
                })
                .then(function () {
                    return me.loadProjects();
                })
                .then(function () {
                    return me.loadEpicProjects();
                })
                .then(function () {
                    me.applyScopingOverrides();
                });
        },

        /**
         Load all scrumGroups in horizontal mode, regardless of project scoping. Load scrum group in
         vertical mode ONLY if we are scoped to a scrumGroupRootRecord
         */
        loadScrumGroups: function () {
            var me = this;
            me.ScrumGroupRootRecords = [];
            me.ScrumGroupPortfolioOIDs = [];

            if (me.isHorizontalView) {
                for (var i = 0; i < me.ScrumGroupConfig.length; i++) {
                    if (me.ScrumGroupConfig[i].IsTrain) { //only load train scrumGroups in horizontal view
                        var dummyScrumGroupRootRecord = me.createDummyProjectRecord({ObjectID: me.ScrumGroupConfig[i].ScrumGroupRootProjectOID});
                        me.ScrumGroupRootRecords.push(dummyScrumGroupRootRecord);
                        me.ScrumGroupPortfolioOIDs.push(me.getPortfolioOIDForScrumGroupRootProjectRecord(dummyScrumGroupRootRecord));
                    }
                }
            }
            else {
                return me.loadProject(me.ProjectRecord.data.ObjectID)
                    .then(function (projectRecord) {
                        return me.projectInWhichScrumGroup(projectRecord);
                    })
                    .then(function (scrumGroupRootRecord) {
                        if (scrumGroupRootRecord) {
                            if (scrumGroupRootRecord.data.ObjectID === me.ProjectRecord.data.ObjectID) { //if scoped to a scrumGroupRootRecord
                                me.ScrumGroupRootRecords.push(scrumGroupRootRecord);
                                me.ScrumGroupPortfolioOIDs.push(me.getPortfolioOIDForScrumGroupRootProjectRecord(scrumGroupRootRecord));
                            }
                        }
                    });
            }
        },

        /**
         NOTE: this does NOT set me.FilteredLeafProjects, which is the list of projects that should be used
         in querying userStories. This only loads all relevent projects 1 time, up front, during the app
         configuration.
         */
        loadProjects: function () {
            var me = this;
            me.LeafProjects = [];
            me.LeafProjectsByScrumGroup = {};
            me.LeafProjectsByHorizontal = {};
            me.LeafProjectsByTeamTypeComponent = {};

            return Q.all(_.map(me.ScrumGroupRootRecords, function (scrumGroupRootRecord) {
                return me.loadAllLeafProjectsForPortfolioDI(scrumGroupRootRecord).then(function (leafProjects) {
                    me.LeafProjects = me.LeafProjects.concat(_.values(leafProjects));
                    me.LeafProjectsByScrumGroup[scrumGroupRootRecord.data.ObjectID] = _.values(leafProjects);

                    var teamTypes = me.getAllHorizontalTeamTypeInfos(leafProjects);
                    for (var i in teamTypes) {
                        me.LeafProjectsByHorizontal[teamTypes[i].horizontal] = me.LeafProjectsByHorizontal[teamTypes[i].horizontal] || [];
                        me.LeafProjectsByHorizontal[teamTypes[i].horizontal].push(teamTypes[i].projectRecord);
                        for (var j in teamTypes[i].teamTypeComponents) {
                            var cmp = teamTypes[i].teamTypeComponents[j];
                            me.LeafProjectsByTeamTypeComponent[cmp] = me.LeafProjectsByTeamTypeComponent[cmp] || [];
                            me.LeafProjectsByTeamTypeComponent[cmp].push(teamTypes[i].projectRecord);
                        }
                    }

                });
            }));
        },


        loadEpicProjects: function () {
            var me = this;
            me.AllProjects = {};
            me.LeafProjectsByEpicComponent = {};

            return me.loadAllProjects().then(function (projects) {
                me.AllProjects = projects;

            });
        },

        applyScopingOverrides: function () {
            var me = this;

            //the following code validates URL overrides and sets defaults for viewing projects/horizontals/scrumGroups
            if (!me.isScopedToScrum) {
                me.ScopedTeamType = me.Overrides.TeamName || (me.isHorizontalView && !me.isStandalone ? me.HorizontalTeamTypeInfo.teamType : '' ); //could be a teamTypeComponent (for horizontal mode) or scrumName (for vertical mode)
                if (me.isHorizontalView) {
                    if (me.ScopedTeamType) {
                        if (!_.contains(me.getAllHorizontalTeamTypeComponents(), me.ScopedTeamType)) throw me.ScopedTeamType + ' is not configured as horizontal teamType';
                        me.ScopedHorizontal = me.teamTypeComponentInWhichHorizontal(me.ScopedTeamType);
                    }
                    else me.ScopedHorizontal = me.Overrides.ScopedHorizontal || _.keys(me.HorizontalGroupingConfig.groups).sort()[0];

                    if (typeof me.HorizontalGroupingConfig.groups[me.ScopedHorizontal] === 'undefined')
                        throw me.ScopedHorizontal + ' is not a valid horizontal';
                }
                else {
                    if (me.ScopedTeamType) {
                        if (!me.ScrumGroupRootRecords.length) throw "cannot specify team when not in ScrumGroup";
                        var matchingTeam = _.find(me.LeafProjectsByScrumGroup[me.ScrumGroupRootRecords[0].data.ObjectID], function (p) {
                            return p.data.Name === me.ScopedTeamType;
                        });
                        if (!matchingTeam) throw me.ScopedTeamType + " is not a valid team";
                    }
                }
            }
        },

        /**************************************** Data Loading ************************************/
        /**
         Filters only apply if we are in horizontal-mode OR we are scoped to a train in vertical mode
         */
        applyProjectFilters: function () {
            var me = this, filteredProjects;

            if (me.isScopedToScrum) filteredProjects = [me.ProjectRecord];
            else if (me.isHorizontalView) {
                if (me.ScopedTeamType && me.ScopedTeamType !== 'All') filteredProjects = me.LeafProjectsByTeamTypeComponent[me.ScopedTeamType] || [];
                else {
                    if (!me.ScopedHorizontal || me.ScopedHorizontal === 'All') filteredProjects = [].concat.apply([], _.values(me.LeafProjectsByHorizontal));
                    else filteredProjects = me.LeafProjectsByHorizontal[me.ScopedHorizontal] || [];
                }
            }
            else {
                if (!me.ScrumGroupRootRecords.length) filteredProjects = [me.ProjectRecord];
                else {
                    if (me.ScopedTeamType && me.ScopedTeamType !== 'All')
                        filteredProjects = [_.find(me.LeafProjects, function (leafProject) {
                            return leafProject.data.Name === me.ScopedTeamType;
                        })];
                    else filteredProjects = me.LeafProjectsByScrumGroup[me.ScrumGroupRootRecords[0].data.ObjectID] || [];
                }
            }
            filteredProjects.push(me.ProjectRecord);
            me.FilteredLeafProjects = filteredProjects;
            return Q();
        },

        /**
         Creates a filter for the portfolio items
         */
        createPortfolioItemFilter: function () {
            var me = this,
                releaseName = me.ReleaseRecord.data.Name,
                releaseFilter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Release.Name',
                    operator: '=',
                    value: releaseName
                }),
                oids = [];
            return releaseFilter;
        },

        /**************************************** Data Loading ************************************/
        /**
         Filters only apply if we are in horizontal-mode OR we are scoped to a train in vertical mode
         */
        applyEpicProjectFilters: function () {
            var me = this, tempProjects;
            var projects = [];
            if (me.PortfolioEpicStore.data.items) {

                for (var i = 0; i < me.PortfolioEpicStore.data.items.length; i++) {
                    projects[i] = [_.find(me.AllProjects, function (leafProject) {
                        return leafProject.data.Name === me.PortfolioEpicStore.data.items[i].data.Project.Name;
                    })];
                }
            }
            tempProjects = (_.uniq(projects, function (p) {
                return p[0].data.Name;
            }));
            me.LeafProjectsByEpicComponent = tempProjects;
            return Q();
        },

        /**
         Filters only apply if we are in horizontal-mode OR we are scoped to a train in vertical mode
         */
        applyAllProjectFilters: function () {
            var me = this, tempProjects;
            var allProjectsForDI = [];
            //Add all the Feature Projects
            for (var i = 0; i < me.FilteredLeafProjects.length; i++) {
                allProjectsForDI.push(me.FilteredLeafProjects[i]);
            }
            //Add all the Epic Projects
            for (var j = 0; j < me.LeafProjectsByEpicComponent.length; j++) {
                allProjectsForDI.push(me.LeafProjectsByEpicComponent[j][0]);
            }
            allProjectsForDI.push(me.ProjectRecord);
            tempProjects = (_.uniq(allProjectsForDI, function (p) {
                return p.data.Name;
            }));
            me.FilteredAllProjectsAndEpicProjects = tempProjects;
            return Q();
        },

        /**
         Gets portfolio items in the current release associated with the scrum groups (if there are any)
         Also: creates a map of portfolioOID to the portfolioItems loaded under it
         */
        loadPortfolioItems: function () {
            var me = this,
                lowestPortfolioItemType = me.PortfolioItemTypes[0];
            var pageSize = 0;

            me.PortfolioProjectToPortfolioItemMap = {};
            return Q.all(_.map(me.ScrumGroupPortfolioOIDs, function (portfolioOID) {
                var store = Ext.create('Rally.data.wsapi.Store', {
                    model: me['PortfolioItem/' + lowestPortfolioItemType],
                    autoLoad: false,
                    pageSize: 600,
                    fetch: ['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate',
                        'Release', 'Description', 'FormattedID', 'UserStories', 'Parent'],
                    context: {
                        project: '/project/' + portfolioOID,
                        projectScopeUp: false,
                        projectScopeDown: true
                    }
                });
                return me.reloadStore(store).tap(function (store) {
                    me.PortfolioProjectToPortfolioItemMap[portfolioOID] = store.getRange();
                });
                pageSize = store.totalCount;
            }))
                .then(function (stores) {
                    me.PortfolioItemStore = Ext.create('Rally.data.custom.Store', {
                        autoLoad: false,
                        model: me['PortfolioItem/' + lowestPortfolioItemType],
                        pageSize: pageSize,
                        data: [].concat.apply([], _.invoke(stores, 'getRange'))
                    });
                });
        },

        loadPortfolioEpics: function () {
            var me = this,
                epicPortfolioItemType = me.PortfolioItemTypes[1];
            me.PortfolioProjectToPortfolioEpicMap = {};
            return Q.all(_.map(me.ScrumGroupPortfolioOIDs, function (portfolioOID) {
                var store = Ext.create('Rally.data.wsapi.Store', {
                    model: me['PortfolioItem/' + epicPortfolioItemType],
                    //filters: [me.createPortfolioItemFilter()],
                    autoLoad: false,
                    pageSize: 200,
                    fetch: ['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate',
                        'Release', 'Description', 'FormattedID', 'Parent'],
                    context: {
                        project: '/project/' + portfolioOID,
                        projectScopeUp: false,
                        projectScopeDown: true
                    }
                });
                return me.reloadStore(store).tap(function (store) {
                    me.PortfolioProjectToPortfolioEpicMap[portfolioOID] = store.getRange();
                });
            }))
                .then(function (stores) {
                    //console.log("stores = ", stores); // This has data
                    me.PortfolioEpicStore = Ext.create('Rally.data.custom.Store', {
                        autoLoad: false,
                        model: me['PortfolioItem/' + epicPortfolioItemType],
                        pageSize: 200,
                        data: [].concat.apply([], _.invoke(stores, 'getRange'))
                    });
                    //console.log("me.PortfolioEpicStore.data = ", me.PortfolioEpicStore.data);
                });
        },

        /**
         Creates a filter for stories that:
         Belong to one of the projects
         AND
         Are in an during the release but not the release OR in the release
         */
        createStoryFilter: function (leafProjects) {			//NOTE: we are filtering for leaf stories here
            var me = this,
                releaseName = me.ReleaseRecord.data.Name,
                releaseDate = new Date(me.ReleaseRecord.data.ReleaseDate).toISOString(),
                releaseStartDate = new Date(me.ReleaseRecord.data.ReleaseStartDate).toISOString(),
                releaseNameFilter = Ext.create('Rally.data.wsapi.Filter', {
                    property: 'Release.Name',
                    value: releaseName
                }),
                leafStoriesInIterationButNotReleaseFilter =
                    Ext.create('Rally.data.wsapi.Filter', {
                        property: 'Iteration.StartDate',
                        operator: '<',
                        value: releaseDate
                    }).and(
                        Ext.create('Rally.data.wsapi.Filter', {
                            property: 'Iteration.EndDate',
                            operator: '>',
                            value: releaseStartDate
                        })).and(
                        Ext.create('Rally.data.wsapi.Filter', {
                            property: 'Release.Name',
                            operator: '=',
                            value: null
                        })).and(
                        Ext.create('Rally.data.wsapi.Filter', {
                            property: 'Iteration.Name',
                            operator: 'contains',
                            value: releaseName
                        }).and(
                            Ext.create('Rally.data.wsapi.Filter', {property: 'DirectChildrenCount', value: 0}))),
                projectFilter = _.reduce(leafProjects, function (filter, leafProject) {
                    var newFilter = Ext.create('Rally.data.wsapi.Filter', {
                        property: 'Project.ObjectID',
                        value: leafProject.data.ObjectID
                    });
                    return filter ? filter.or(newFilter) : newFilter;
                }, null);

            return projectFilter.and(leafStoriesInIterationButNotReleaseFilter.or(releaseNameFilter));
        },

        /**
         Loads userstories under leafProjects in chunks of projects at a time. we batch projects to reduce requests sent
         */
        loadUserStories: function () {
            var me = this,
                lowestPortfolioItem = me.PortfolioItemTypes[0];

            me.UserStoryFetchFields = ['Name', 'ObjectID', 'Project', 'Owner', 'PlannedEndDate', 'ActualEndDate',
                'StartDate', 'EndDate', 'Iteration[StartDate;EndDate]', 'DirectChildrenCount',
                'Release', 'ReleaseStartDate', 'ReleaseDate', 'PlanEstimate', 'FormattedID', 'ScheduleState',
                'Blocked', 'BlockedReason', 'Blocker', 'CreationDate', 'Description', lowestPortfolioItem];

            if (!me.FilteredLeafProjects) throw "No leaf projects for userstory filter";

            return Q.all(_.map(_.chunk(me.FilteredLeafProjects, 20), function (leafProjects) {
                return me.parallelLoadWsapiStore({
                    model: me.UserStory,
                    enablePostGet: true,
                    autoLoad: false,
                    filters: [me.createStoryFilter(leafProjects)],
                    fetch: me.UserStoryFetchFields,
                    context: {
                        workspace: me.getContext().getWorkspace()._ref,
                        project: null
                    },
                    pageSize: 200
                });
            }))
                .then(function (stores) {
                    me.UserStoryStore = Ext.create('Rally.data.wsapi.Store', {
                        autoLoad: false,
                        model: me.UserStory,
                        pageSize: 200,
                        data: [].concat.apply([], _.invoke(stores, 'getRange'))
                    });

                    /* US436545: Remove this to get back improperly sized user stories */
                    _.each(me.UserStoryStore.getRange(), function (item, key) {
                        if (key < me.UserStoryStore.count() && me.UserStoryStore.getAt(key).data) {
                            var pe = me.UserStoryStore.getAt(key).data.LeafStoryPlanEstimateTotal;
                            if (pe && pe !== 0 && pe !== 1 && pe !== 2 && pe !== 4 && pe !== 8 && pe !== 16) {
                                me.UserStoryStore.removeAt(key);
                            }
                        }
                    });

                    me.fixRawUserStoryAttributes();
                });
        },

        /**
         Counts the number of stories associated with each portfolio item.
         This is only used for 1 of the portfolioItem integrity grids
         */
        countPortfolioItemStories: function () {
            var me = this;
            if (me.PortfolioItemStore) {
                var lowestPortfolioItemType = me.PortfolioItemTypes[0];
                me.PortfolioUserStoryCount = {};
                _.each(me.PortfolioItemStore.getRange(), function (portfolioItemRecord) {
                    me.PortfolioUserStoryCount[portfolioItemRecord.data.ObjectID] = portfolioItemRecord.data.UserStories.Count;
                });
            }
        },

        /**
         Control function for loading projects, portfolio items, and stories
         */
        loadData: function () {
            var me = this;
            me.setLoading('Loading Data');
            return me.applyProjectFilters()
                .then(function () {
                    return me.loadPortfolioItems();
                })
                .then(function () {
                    return me.loadPortfolioEpics();
                })
                .then(function () {
                    return me.loadUserStories();
                })
                .then(function () {
                    return me.applyEpicProjectFilters();
                })
                .then(function () {
                    return me.applyAllProjectFilters();
                })
                .then(function () {
                    me.setLoading(false);
                    return me.countPortfolioItemStories();
                });
        },

        /**************************************** UI Component Loading/Removing ****************************/
        /**
         Removes the chart, heat map, and all grids
         */
        removeAllItems: function () {
            var me = this;
            Ext.getCmp('pie').removeAll();
            Ext.getCmp('heatmap').removeAll();
            Ext.getCmp('gridsLeft').removeAll();
            Ext.getCmp('gridsRight').removeAll();
            var indicator = Ext.getCmp('integrityIndicator');
            if (indicator) indicator.destroy();
        },

        /**
         the team picker acts as a horizontal TeamType picker in horizontal view mode, and a leaf project picker
         in vertical view mode while scoped to a scrumGroupRootRecord
         */
        getTeamPickerValues: function () {
            var me = this;
            if (me.isHorizontalView) {
                return [{Type: 'All'}].concat(
                    _.sortBy(_.map(me.HorizontalGroupingConfig.groups[me.ScopedHorizontal] || [],
                            function (type) {
                                return {Type: type};
                            }),
                        function (type) {
                            return type.Type;
                        })
                );
            }
            else {
                return [{Type: 'All'}].concat(_.sortBy(_.map(me.FilteredLeafProjects,
                            function (project) {
                                return {Type: project.data.Name};
                            }),
                        function (type) {
                            return type.Type;
                        })
                );
            }
        },

        /**
         Adds comboboxes in the nav section to filter data on the page
         */
        renderGetLiveDataButton: function () {
            var me = this;
            me.UpdateCacheButton = Ext.getCmp('cacheButtonsContainer').add({
                xtype: 'button',
                text: 'Get Live Data',
                listeners: {
                    click: function () {
                        me.setLoading('Pulling Live Data, please wait');
                        Ext.getCmp('cacheMessageContainer').removeAll();
                        return Q.all([
                            me.isHorizontalView ? Q() : me.loadRemainingConfiguration()
                        ])
                            .then(function () {
                                return me.loadData();
                            })
                            .then(function () {
                                return me.renderVisuals();
                            })
                            .then(function () {
                                //NOTE: not returning promise here, performs in the background!
                                //dont want to cache in the horizontal view if only a team is selected
                                //we want to only cache for All in a horizontal view, me.isStandalone checks if its the caching script
                                Ext.getCmp('cacheButtonsContainer').removeAll();
                                var doCaching = me.isHorizontalView ? (me.ScopedTeamType === 'All' || ( me.TeamPicker ? me.TeamPicker.value === 'All' : "") || me.isStandalone ) : !me.isScopedToScrum;
                                if (doCaching) {
                                    me.updateCache().fail(function (e) {
                                        alert(e);
                                        console.log(e);
                                    });
                                }
                            })
                            .then(function () {
                                me.setLoading(false);
                            });
                    }
                }
            });
        },
        renderReleasePicker: function () {
            var me = this;
            me.ReleasePicker = Ext.getCmp('controlsContainer').add({
                xtype: 'intelreleasepicker',
                labelWidth: 60,
                width: 240,
                releases: me.ReleaseRecords,
                currentRelease: me.ReleaseRecord,
                listeners: {
                    change: function (combo, newval, oldval) {
                        if (newval.length === 0) combo.setValue(oldval);
                    },
                    select: me.releasePickerSelected.bind(me)
                }
            });
        },
        renderHorizontalGroupPicker: function () {
            var me = this;
            me.ScopedHorizontalPicker = Ext.getCmp('controlsContainer').add({
                xtype: 'intelcombobox',
                labelWidth: 60,
                width: 240,
                fieldLabel: 'Horizontal:',
                store: Ext.create('Ext.data.Store', {
                    fields: ['Horizontal', 'TeamTypes'],
                    data: [{Horizontal: 'All', TeamTypes: []}].concat(_.sortBy(_.map(me.HorizontalGroupingConfig.groups,
                                function (teamTypes, horizontal) {
                                    return {Horizontal: horizontal, TeamTypes: teamTypes};
                                }),
                            function (item) {
                                return item.Horizontal;
                            })
                    )
                }),
                displayField: 'Horizontal',
                value: me.ScopedHorizontal,
                listeners: {
                    change: function (combo, newval, oldval) {
                        if (newval.length === 0) combo.setValue(oldval);
                    },
                    select: me.horizontalGroupPickerSelected.bind(me)
                }
            });
        },
        renderTeamPicker: function () {
            var me = this;
            me.TeamPicker = Ext.getCmp('controlsContainer').add({
                xtype: 'intelcombobox',
                id: 'teampicker',
                labelWidth: 60,
                width: 240,
                fieldLabel: 'Team:',
                store: Ext.create('Ext.data.Store', {
                    fields: ['Type'],
                    data: me.getTeamPickerValues()
                }),
                displayField: 'Type',
                value: me.isHorizontalView ? me.ScopedTeamType : 'All',
                listeners: {
                    change: function (combo, newval, oldval) {
                        if (newval.length === 0) combo.setValue(oldval);
                    },
                    select: me.teamPickerSelected.bind(me)
                }
            });
        },

        /**
         MailTo link generating and rendering functions.
         */
        generateMailtoLink: function () {
            var me = this;
            var base = 'mailto:',
                subject = '&subject=Data%20Integrity%20Dashboard%20View',
                urlSegments = me.Overrides.decodedUrl.split('?'),
                options = [];

            // Push options that will always be present
            options.push('isStandalone=true');
            options.push('release=' + me.ReleaseRecord.data.Name);

            // Push variable options
            if (me.isHorizontalView) {
                if (me.ScopedTeamType !== '') options.push('team=' + me.ScopedTeamType);
                if (me.ScopedHorizontal) options.push('group=' + me.ScopedHorizontal);
            }
            else if (!me.isScopedToScrum) {
                if (me.ScopedTeamType !== '') options.push('team=' + me.ScopedTeamType);
            }

            // Create the correctly encoded app url
            var appUrl = urlSegments[0] + '%3F' + options.join('%26');
            appUrl = appUrl.replace(/\s/g, '%2520');

            // Create the full mailto url
            var body = '&body=' + appUrl,
                url = base + subject + body;
            return url;
        },
        setNewEmailLink: function () {
            var me = this;
            if (me.EmailLink) {
                me.EmailLink.setText('<a href="' + me.generateMailtoLink() + '">Email this view</a>', false);
            }
        },
        renderEmailLink: function () {
            var me = this;
            me.EmailLink = Ext.getCmp('emailLinkContainer').add({
                xtype: 'label',
                width: '100%',
                html: '<a href="' + me.generateMailtoLink() + '">Email this view</a>'
            });
        },
        renderCacheMessage: function () {
            var me = this;
            Ext.getCmp('cacheMessageContainer').add({
                xtype: 'label',
                width: '100%',
                html: 'You are looking at the cached version of the data, update last on: ' + '<span class = "modified-date">' + me.lastCacheModified + '</span>'
            });
        },
        /**
         Loads all nav controls
         */
        renderControlsAndEmailLink: function () {
            var me = this;

            // Conditionally loads controls
            //if(!me.DeleteCacheButton && !me.isScopedToScrum) me.renderDeleteCache();
            //if(!me.UpdateCacheButton && !me.isScopedToScrum) me.renderGetLiveDataButton();
            if (!me.ReleasePicker) me.renderReleasePicker();
            if (!me.ScopedHorizontalPicker && !me.isScopedToScrum && me.isHorizontalView) me.renderHorizontalGroupPicker();
            if (!me.TeamPicker && !me.isScopedToScrum) me.renderTeamPicker();
            if (me.isStandalone) {
                me.ReleasePicker.hide();
                if (me.UpdateCacheButton) me.UpdateCacheButton.hide();
                if (me.ScopedHorizontalPicker) me.ScopedHorizontalPicker.hide();
                if (me.TeamPicker) me.TeamPicker.hide();
            }
            if (!me.EmailLink) me.renderEmailLink();
        },

        /**
         Adds the click listener to the expand heatmap button
         */
        initializeExpandHeatmapButton: function () {
            var me = this;
            me.isPieHidden = false;

            // Add click listener to button
            me.down('#expand-heatmap-button').on('click', function () {
                var heatmap = $('#heatmap'),
                    ribbon = me.down('#ribbon');
                // Show pie chart
                if (me.isPieHidden) {
                    me.down('#pie').setWidth(480);
                    button = me.down('#expand-heatmap-button').setText('Expand Heatmap');
                }
                // Hide pie chart
                else {
                    me.down('#pie').setWidth(0);
                    button = me.down('#expand-heatmap-button').setText('Show Pie');
                }

                // Create heat map
                heatmap.empty();
                heatmap.highcharts(me.getHeatMapConfig());

                me.isPieHidden = !me.isPieHidden;
                me.hideHighchartsLinks();
            });
        },

        /**
         Creates and adds the overall indicator of integrity to the app
         */
        buildIntegrityIndicator: function () {
            var me = this;
            var userStoryGrids = _.filter(Ext.getCmp('gridsContainer').query('rallygrid'), function (grid) {
                return grid.originalConfig.model == 'UserStory' || grid.originalConfig.model == 'PortfolioItem/Epic';
            }).reverse();

            var storyNum = {};
            var storyDen = 0;
            var pointDen = 0;

            if (userStoryGrids.length > 0) {
                storyDen = userStoryGrids[0].originalConfig.totalCount;
                pointDen = userStoryGrids[0].originalConfig.totalPoints;
            }

            // Sums the point estimates and number of stories
            _.each(userStoryGrids, function (grid) {
                _.each(grid.originalConfig.data, function (item) {
                    storyNum[item.data.ObjectID] = item.data.LeafStoryPlanEstimateTotal || 0;
                });
            });
            var pointNum = (100 * (pointDen - _.reduce(storyNum, function (sum, planEstimate) {
                    return sum + planEstimate;
                }, 0)) >> 0) / 100;
            storyNum = storyDen - Object.keys(storyNum).length;
            var storyPer = (storyNum / storyDen * 10000 >> 0) / 100;
            var pointPer = (pointNum / pointDen * 10000 >> 0) / 100;

            // Creates the integrity scope label
            // Collective (Release) || Horizontal[/Team] (Release) || ScrumGroup[/Team] (Release) || Team (Release) || ProjectName (Release)
            var scopeLabel = '';
            if (me.isScopedToScrum) scopeLabel = me.ProjectRecord.data.Name;
            else if (me.isHorizontalView) {
                if (me.ScopedHorizontal && me.ScopedHorizontal !== 'All') {
                    scopeLabel = me.ScopedHorizontal;
                    if (me.ScopedTeamType !== '') scopeLabel = scopeLabel.concat('/' + me.ScopedTeamType);
                }
                else scopeLabel = 'Collective';
            }
            else {
                if (me.ScrumGroupRootRecords.length) {
                    scopeLabel = me.getScrumGroupName(me.ScrumGroupRootRecords[0]);
                    if (me.ScopedTeamType !== '') scopeLabel = scopeLabel.concat('/' + me.ScopedTeamType);
                }
                else scopeLabel = me.ProjectRecord.data.Name; //some random non-leaf, non-scrum-group project
            }
            scopeLabel = scopeLabel.concat(' (' + me.ReleaseRecord.data.Name + ')');

            // Creates and adds the integrity indicator
            Ext.getCmp('integrityIndicatorContainer').removeAll();
            me.IntegrityIndicator = Ext.getCmp('integrityIndicatorContainer').add({
                xtype: 'container',
                id: 'integrityIndicator',
                padding: '5px 20px 0 0',
                flex: 1,
                layout: {
                    type: 'hbox',
                    pack: 'end'
                },
                items: [{
                    xtype: 'container',
                    html: '<span class="integrity-inticator-title">' +
                    scopeLabel +
                    ' Integrity <em>(% Correct)</em></span><br/>' +
                    '<span class="integrity-indicator-value"><b>Epics: </b>' + storyNum + '/' + storyDen + ' <em>(' + storyPer + '%)</em></span><br/>' /*+
                     '<span class="integrity-indicator-value"><b>Points: </b>' + pointNum + '/' + pointDen + ' <em>(' + pointPer + '%)<em/></span>'*/
                }]
            });
        },

        /**
         Loads all data visuals
         */
        renderVisuals: function () {
            var me = this;
            me.setLoading('Loading Visuals');
            me.setNewEmailLink();
            me.removeAllItems();
            return me.buildGrids()
                .then(function () {
                    return Q.all([me.buildRibbon(), me.buildIntegrityIndicator()]);
                })
                .then(function () {
                    me.setLoading(false);
                });
        },

        /**        Loads all controls and visuals        */
        loadUI: function () {
            var me = this;
            me.renderControlsAndEmailLink();
            me.initializeExpandHeatmapButton();
            return me.renderVisuals();
        },

        /**************************************** Grids and Charts ********************************/
        getProjectStoriesForGrid: function (project, grid) {
            return _.filter(grid.originalConfig.data, function (story) {
                return story.data.Project.ObjectID == project.data.ObjectID;
            });
        },
        getProjectStoriesForRelease: function (project, grid) {
            return _.filter(grid.originalConfig.totalStories, function (story) {
                return story.data.Project.ObjectID == project.data.ObjectID;
            });
        },
        getProjectPointsForGrid: function (project, grid) {
            return _.reduce(this.getProjectStoriesForGrid(project, grid), function (sum, story) {
                return sum + story.data.LeafStoryPlanEstimateTotal;
            }, 0);
        },
        getProjectPointsForRelease: function (project, grid) {
            return _.reduce(this.getProjectStoriesForRelease(project, grid), function (sum, story) {
                return sum + story.data.LeafStoryPlanEstimateTotal;
            }, 0);
        },

        /**
         This is only necessary when we are scoped to a scrumGroupRootRecord or in horizontalMode, and we have
         the me.ScopedTeamType set to a value, in which case we need to filter the user stories we have loaded into memory
         */
        getEpicsForReport: function () {
            var me = this;
            return me.PortfolioEpicStore.data.getRange();
        },

        /**
         if in horizontal mode, it only gets the portfolio items attached to scrumGroups
         that have teams visibile in the DI Dashboard. (e.g.: if two 'H' horizontal teams
         are showing on the page, but they are in trains "Foo" and "Bar", then the portfolioItems
         for "Foo" and "Bar" will be returned.

         In Vertical mode, it returns whatever scrumGroup that is scoped to.
         */
        getFilteredLowestPortfolioItems: function () {
            var me = this, activeScrumGroups, activePortfolioOIDs;
            var portfolioItems = me.PortfolioItemStore.getRange();


            if (me.isScopedToScrum) return [];
            else {
                activeScrumGroups = _.filter(me.ScrumGroupConfig, function (sgc) {
                    //todo
                    return _.filter(me.LeafProjectsByScrumGroup[sgc.ScrumGroupRootProjectOID] || [], function (item1) {
                        return _.some(me.FilteredLeafProjects, function (item2) {
                            return item1.data.ObjectID == item2.data.ObjectID;
                        });
                    }).length;

                });
                activePortfolioOIDs = _.map(activeScrumGroups, function (sgc) {
                    return me.getPortfolioOIDForScrumGroupRootProjectRecord(me.createDummyProjectRecord({ObjectID: sgc.ScrumGroupRootProjectOID}));
                });
                return [].concat.apply([], _.map(activePortfolioOIDs, function (oid) {
                    return me.PortfolioProjectToPortfolioItemMap[oid];
                }));
            }
        },

        /************************************ Ribbon rendering ************************************/
        getPieChartConfig: function () {
            var me = this,
            // Create data for the chart using each grid's data
                chartData = _.map(Ext.getCmp('gridsContainer').query('rallygrid'), function (grid) {
                    return {
                        name: grid.originalConfig.title,
                        y: grid.originalConfig.data.length,
                        totalCount: grid.originalConfig.totalCount,
                        gridID: grid.originalConfig.id,
                        model: grid.originalConfig.model
                    };
                });

            // Change data if no problem stories are found
            if (_.every(chartData, function (item) {
                    return item.y === 0;
                })) {
                chartData = [{
                    name: 'Everything is correct!',
                    y: 1,
                    totalCount: 1,
                    color: '#2ECC40', //GREEN
                    model: ''
                }];
            }

            // Create the chart config
            return {
                chart: {
                    height: 370,
                    marginLeft: -15,
                    plotBackgroundColor: null,
                    plotBorderWidth: 0,
                    plotShadow: false
                },
                colors: me.chartColors,
                title: {text: null},
                tooltip: {enabled: false},
                plotOptions: {
                    pie: {
                        dataLabels: {
                            enabled: true,
                            distance: 25,
                            crop: false,
                            overflow: 'none',
                            formatter: function () {
                                var str = '<b>' + this.point.name + '</b>: ' + this.point.y;
                                return str + '/' + this.point.totalCount;
                            },
                            style: {
                                cursor: 'pointer',
                                color: 'black'
                            }
                        },
                        startAngle: 10,
                        endAngle: 170,
                        center: ['0%', '50%']
                    }
                },
                series: [{
                    type: 'pie',
                    name: 'Grid Count',
                    innerSize: '25%',
                    size: 260,
                    point: {
                        events: {
                            click: function (e) {
                                if (e.point.gridID) Ext.get(e.point.gridID).scrollIntoView(me.el);
                                e.preventDefault();
                            }
                        }
                    },
                    data: chartData
                }]
            };
        },
        getHeatMapConfig: function () {
            var me = this, finalProjects;
            highestNum = 0,
                userStoryGrids = _.filter(Ext.getCmp('gridsContainer').query('rallygrid'), function (grid) {
                    if (grid.originalConfig.model == 'UserStory' || grid.originalConfig.model == 'PortfolioItem/Epic' || grid.originalConfig.model == 'PortfolioItem/Feature')
                        return grid.originalConfig.model;
                });
            userStoryGrids.reverse();
            chartData = [],
                tempProjects = [];
            selectIdFunctionName = '_selectId' + (Math.random() * 10000 >> 0);
            //Filter the projects to make a list of the project with feature or Epic count. Remove the projects with zero count
            _.each(userStoryGrids, function (grid, gindex) {
                _.each(_.sortBy(me.FilteredAllProjectsAndEpicProjects, function (p) {
                    return p.data.Name;
                }), function (project, pindex) {
                    var gridCount = me.getProjectStoriesForGrid(project, grid).length;
                    highestNum = Math.max(gridCount, highestNum);
                    if (gridCount !== 0) {
                        tempProjects.push(project);
                    }
                });
            });
            me.finalProjects = (_.uniq(tempProjects, function (p) {
                return p.data.Name;
            }));

            // Get the data for each scrum from each grid
            _.each(userStoryGrids, function (grid, gindex) {
                _.each(_.sortBy(me.finalProjects, function (p) {
                    return p.data.Name;
                }), function (project, pindex) {
                    var gridCount = me.getProjectStoriesForGrid(project, grid).length;
                    highestNum = Math.max(gridCount, highestNum);
                    //only push the rows (rule categories) which are selected in the "Edit App Settings"

                    //if (me.rules[gindex]) {
                    chartData.push([pindex, gindex, gridCount]);
                    //} else {
                    //    console.log("skipping row index ", gindex);
                    //}
                });
            });


            // Function for scrolling to grid
            window[selectIdFunctionName] = function (gridId) {
                Ext.get(gridId).scrollIntoView(me.el);
            };

            //check the number of rules selected (which will be the rows) in order to set the height.
            var rowCount = 0;
            for (var k = 0; k < me.rules.length; k++) {
                if (me.rules[k]) {
                    rowCount++;
                }
            }
            //set height based on number of rows (rule categories)
            var height = (55 * rowCount) + 60;

            // Create the map config
            return {
                chart: {
                    type: 'heatmap',
                    height: height,
                    marginTop: 10,
                    marginLeft: 140,
                    marginBottom: 80
                },
                colors: ['#AAAAAA'],
                title: {text: null},
                xAxis: {
                    categories: _.sortBy(_.map(me.finalProjects,
                            //function(project){ return project[0].data.Name; }),
                            function (project) {
                                return project.data.Name;
                            }),
                        function (p) {
                            return p;
                        }),
                    labels: {
                        style: {width: 100},
                        formatter: function () {
                            var text = '<span title="' + this.value + '" class="heatmap-xlabel-text">' + this.value + '</span>';
                            return '<a class="heatmap-xlabel">' + text + '</a>';
                        },
                        useHTML: true,
                        rotation: -45
                    }
                },
                yAxis: {
                    categories: _.map(userStoryGrids, function (grid) {
                        return grid.originalConfig.title;
                    }),
                    title: null,
                    labels: {
                        formatter: function () {
                            var text = this.value;
                            var index = _.indexOf(this.axis.categories, text);
                            var gridID = userStoryGrids[index].originalConfig.id;
                            var rowCount = 0;
                            _.each(me.rules, function (rule) {
                                if (rule) {
                                    rowCount++;
                                }
                            });
                            var reverseIndex = rowCount - index - 1;
                            var styleAttr = 'style="background-color:' + me.chartColors[reverseIndex] + '"';
                            return '<div class="heatmap-ylabel"' + styleAttr + ' onclick="' +
                                selectIdFunctionName + '(\'' + gridID + '\')">' + text + '</div>';
                        },
                        useHTML: true
                    }
                },
                colorAxis: {
                    min: 0,
                    minColor: '#FFFFFF',
                    maxColor: highestNum ? '#ec5b5b' : '#FFFFFF' //if they are all 0 make white
                },
                plotOptions: {
                    series: {
                        point: {
                            events: {
                                click: function (e) {
                                    var point = this,
                                        scrum = _.sortBy(me.finalProjects, function (p) {
                                            return p.data.Name;
                                        })[point.x],
                                        grid = userStoryGrids[point.y];
                                    me.onHeatmapClick(point, scrum, grid);
                                }
                            }
                        }
                    }
                },
                legend: {enabled: false},
                tooltip: {enabled: false},
                series: [{
                    name: 'Errors per Violation per Scrum',
                    borderWidth: 1,
                    data: chartData,
                    dataLabels: {
                        enabled: true,
                        color: 'black',
                        style: {
                            textShadow: 'none'
                        }
                    }
                }]
            };
        },
        hideHighchartsLinks: function () {
            $('.highcharts-container > svg > text:last-child').hide();
        },
        buildRibbon: function () {
            var me = this;
            $('#pie').highcharts(me.getPieChartConfig());
            $('#heatmap').highcharts(me.getHeatMapConfig());
            me.hideHighchartsLinks();
        },

        /**
         Creates a Rally grid based on the given configuration
         */
        addGrid: function (gridConfig) {
            var me = this,
                lowestPortfolioItemType = me.PortfolioItemTypes[0],
                randFunctionName = '_scrollToTop' + (Math.random() * 10000 >> 0);

            window[randFunctionName] = function () {
                Ext.get('controlsContainer').scrollIntoView(me.el);
            };

            var getGridTitleLink = function (data, model) {
                    var hasData = !!data,
                        countNum = data && data.length,
                        countDen = gridConfig.totalCount,
                        pointNum = data && (100 * _.reduce(data, function (sum, item) {
                                item = item.data || item;//having issue due to caching so hacking it
                                return sum + (item.LeafStoryPlanEstimateTotal || 0);
                            }, 0) >> 0) / 100,
                        pointDen = gridConfig.totalPoints,
                        type = (model === 'UserStory' ? 'Epics' : lowestPortfolioItemType + 's');
                    return sprintf([
                            '<span class="data-integrity-grid-header-left">',
                            '%s',
                            '<span class="data-integrity-grid-header-stats">%s<br/>%s</span>',
                            '</span>',
                            '<span class="data-integrity-grid-header-top-link"><a onclick="%s()">Top</a></span>'
                        ].join(''),
                        gridConfig.title + (hasData ? '<br>' : ''),
                        hasData ? sprintf('<b>%s:</b> %s/%s (%s%%)', type, countNum, countDen, (countNum / countDen * 10000 >> 0) / 100) : '',
                        (hasData && model == 'Epics') ? sprintf('<b>Points:</b> %s/%s (%s%%)', pointNum, pointDen, (pointNum / pointDen * 10000 >> 0) / 100) : '',
                        randFunctionName);
                },
                storeModel = (gridConfig.model == 'UserStory') ? me.PortfolioEpicStore.model : me.PortfolioItemStore.model,
                grid = Ext.getCmp('grids' + gridConfig.side).add(gridConfig.data.length ?
                        Ext.create('Rally.ui.grid.Grid', {
                            title: getGridTitleLink(gridConfig.data, gridConfig.model),
                            id: gridConfig.id,
                            cls: 'grid-unhealthy data-integrity-grid rally-grid',
                            context: this.getContext(),
                            columnCfgs: gridConfig.columns,
                            enableBulkEdit: true,
                            emptyText: ' ',
                            originalConfig: gridConfig,
                            gridContainer: Ext.getCmp('grids' + gridConfig.side),
                            pagingToolbarCfg: {
                                pageSizes: [10, 15, 25, 100],
                                autoRender: true,
                                resizable: false,
                                changePageSize: function (combobox, newSize) {
                                    newSize = newSize[0].get('value');
                                    if (this._isCurrentPageSize(newSize)) return false;
                                    else {
                                        Ext.getCmp(gridConfig.id).reconfigure(Ext.create('Rally.data.custom.Store', {
                                            model: storeModel,
                                            pageSize: newSize,
                                            data: gridConfig.data,
                                            autoLoad: false
                                        }));
                                        this._reRender();
                                        return true;
                                    }
                                }
                            },
                            store: Ext.create('Rally.data.custom.Store', {
                                model: storeModel,
                                pageSize: 10,
                                data: gridConfig.data,
                                autoLoad: false
                            })
                        }) :
                        Ext.create('Rally.ui.grid.Grid', {
                            title: getGridTitleLink(),
                            id: gridConfig.id,
                            cls: ' data-integrity-grid grid-healthy',
                            context: this.getContext(),
                            showPagingToolbar: false,
                            showRowActionsColumn: false,
                            emptyText: '0 Problems!',
                            originalConfig: gridConfig,
                            gridContainer: Ext.getCmp('grids' + gridConfig.side),
                            store: Ext.create('Rally.data.custom.Store', {data: []})
                        })
                );
            return grid;
        },

        isUserStoryInRelease: function (userStoryRecord, releaseRecord) {
            var me = this,
                lowestPortfolioItem = me.PortfolioItemTypes[0];
            return ((userStoryRecord.data.Release || {}).Name === releaseRecord.data.Name) ||
                (!userStoryRecord.data.Release && ((userStoryRecord.data[lowestPortfolioItem] || {}).Release || {}).Name === releaseRecord.data.Name);
        },

        /**
         Creates grids with filtered results for the user stories/Portfolio items and adds them to the screen
         */
        buildGrids: function () {
            var me = this;
            midPortfolioItemType = me.PortfolioItemTypes[1],
                filteredEpics = me.getEpicsForReport(),
                filteredLowestPortfolioItems = me.getFilteredLowestPortfolioItems(),
                lowestPortfolioItemType = me.PortfolioItemTypes[0],
                releaseName = me.ReleaseRecord.data.Name,
                releaseDate = new Date(me.ReleaseRecord.data.ReleaseDate),
                releaseStartDate = new Date(me.ReleaseRecord.data.ReleaseStartDate),
                now = new Date(),
                defaultUserStoryColumns = [{
                    text: 'FormattedID',
                    dataIndex: 'FormattedID',
                    editor: false
                }, {
                    text: 'Name',
                    dataIndex: 'Name',
                    editor: false
                }].concat(!me.CurrentScrum ? [{
                        text: 'Portfolio',
                        dataIndex: 'Project',
                        editor: false
                    }] : []).concat([{
                        text: 'Owner',
                        dataIndex: 'Owner',
                        editor: false
                    }]),
                defaultLowestPortfolioItemColumns = [{
                    text: 'FormattedID',
                    dataIndex: 'FormattedID',
                    editor: false
                }, {
                    text: 'Name',
                    dataIndex: 'Name',
                    editor: false
                }, {
                    text: 'PlannedEndDate',
                    dataIndex: 'PlannedEndDate',
                    editor: false
                }, {
                    text: 'PlannedStartDate',
                    dataIndex: 'PlannedStartDate',
                    editor: false
                }].concat([{
                        text: 'Parent',
                        dataIndex: 'Parent',
                        editor: false
                    }]);
            var gridConfigs = [];
            /*
             To set the grid, check if each rule should be added to the gridConfigs object.
             This can't be in a loop, because each row has it's own unique properties
             */
            if (me.rules[0]) {
                //The checkbox is checked, so show this rule
                gridConfigs.push({
                    showIfLeafProject: true,
                    showIfHorizontalMode: true,
                    title: ruleCategories[0],
                    id: ruleCategorySelectors[0],
                    model: 'UserStory', //+ midPortfolioItemType,
                    columns: defaultUserStoryColumns.concat([{
                        text: 'Parent',
                        dataIndex: 'Parent',
                        editor: false
                    }]),
                    side: 'Left',
                    filterFn: function (item) {
                        if (!item.data.Parent)
                            return item.data.Name;
                    }
                });
            } else {
                //console.log("Skipping ", ruleCategories[0]);
            }

            if (me.rules[1]) {
                //The checkbox is checked, so show this rule
                gridConfigs.push({
                    showIfLeafProject: true,
                    showIfHorizontalMode: true,
                    title: ruleCategories[1],
                    id: ruleCategorySelectors[1],
                    model: 'UserStory',
                    columns: defaultUserStoryColumns.concat([{
                        text: 'Planned Start Date',
                        dataIndex: 'PlannedStartDate',
                        tdCls: 'editor-cell'
                    }, {
                        text: 'Planned End Date',
                        dataIndex: 'PlannedEndDate',
                        tdCls: 'editor-cell'
                    }]),
                    side: 'Left',
                    filterFn: function (item) {
                        if (item.data.FormattedID == "E3716") {
                            console.log(item.data.FormattedID);
                        }
                        if (item.data.PlannedStartDate && item.data.PlannedEndDate) return false;
                        return item.data.Name;
                    }
                });
            } else {
                //console.log("Skipping ", ruleCategories[1]);
            }

            if (me.rules[2]) {
                gridConfigs.push({
                    showIfLeafProject: true,
                    showIfHorizontalMode: true,
                    title: ruleCategories[2],
                    id: ruleCategorySelectors[2],
                    model: 'UserStory',
                    columns: defaultUserStoryColumns.concat([
                        {
                            text: 'ScheduleState',
                            dataIndex: 'ScheduleState',
                            tdCls: 'editor-cell'
                        }]),
                    side: 'Left',
                    filterFn: function (item) {
                        return new Date(item.data.PlannedEndDate) < now && item.data.ScheduleState != 'Accepted';
                    }
                });
            } else {
                //console.log("skipping ", ruleCategories[2]);
            }

            if (me.rules[3]) {
                gridConfigs.push({
                    showIfLeafProject: true,
                    showIfHorizontalMode: true,
                    title: ruleCategories[3],
                    id: ruleCategorySelectors[3],
                    model: 'PortfolioItem/' + lowestPortfolioItemType,
                    columns: defaultLowestPortfolioItemColumns.concat([
                        {
                            text: 'ScheduleState',
                            dataIndex: 'ScheduleState',
                            tdCls: 'editor-cell'
                        }]).concat(!me.CurrentScrum ? [{
                        text: 'Portfolio',
                        dataIndex: 'Project',
                        editor: false
                    }] : []),
                    side: 'Right',
                    filterFn: function (item) {
                        return new Date(item.data.PlannedEndDate) < now && item.data.ScheduleState != 'Accepted';
                    }
                });
            } else {
                //console.log("skipping ", ruleCategories[3]);
            }

            if (me.rules[4]) {
                gridConfigs.push({
                    showIfLeafProject: false,
                    showIfHorizontalMode: false,
                    title: ruleCategories[4],
                    id: ruleCategorySelectors[4],
                    model: 'PortfolioItem/' + lowestPortfolioItemType,
                    columns: defaultLowestPortfolioItemColumns.concat(!me.CurrentScrum ? [{
                        text: 'Portfolio',
                        dataIndex: 'Project',
                        editor: false
                    }] : []),
                    side: 'Right',
                    filterFn: function (item) {
                        if (!item.data.Parent)
                            return item.data.Name;
                    }
                });
            } else {
                //console.log("skipping ", ruleCategories[4]);
            }

            if (me.rules[5]) {
                gridConfigs.push({
                    showIfLeafProject: false,
                    showIfHorizontalMode: false,
                    title: ruleCategories[5],
                    id: ruleCategorySelectors[5],
                    model: 'PortfolioItem/' + lowestPortfolioItemType,
                    columns: defaultLowestPortfolioItemColumns.concat([
                        {
                            text: 'ScheduleState',
                            dataIndex: 'ScheduleState',
                            tdCls: 'editor-cell'
                        }]).concat(!me.CurrentScrum ? [{
                        text: 'Portfolio',
                        dataIndex: 'Project',
                        editor: false
                    }] : []),
                    side: 'Right',
                    filterFn: function (item) {
                        if (item.data.PlannedStartDate && item.data.PlannedEndDate) return false;
                        return item.data.Name;
                    }
                });
            } else {
                //console.log("skipping ", ruleCategories[5]);
            }

            if (me.rules[6]) {
                gridConfigs.push({
                    showIfLeafProject: false,
                    showIfHorizontalMode: false,
                    title: ruleCategories[6],
                    id: ruleCategorySelectors[6],
                    model: 'PortfolioItem/' + lowestPortfolioItemType,
                    columns: defaultLowestPortfolioItemColumns.concat([
                        {
                            text: 'ScheduleState',
                            dataIndex: 'ScheduleState',
                            tdCls: 'editor-cell'
                        }]).concat(!me.CurrentScrum ? [{
                        text: 'Portfolio',
                        dataIndex: 'Project',
                        editor: false
                    }] : []),
                    side: 'Right',
                    filterFn: function (item) {
                        item = item.data || item;//having issue due to caching so hacking it
                        if (!item.Release || item.Release.Name != releaseName) return false;
                        return !me.PortfolioUserStoryCount[item.ObjectID];
                    }

                });
            } else {
                //console.log("skipping ", ruleCategories[6]);
            }

            return Q.all(_.map(gridConfigs, function (gridConfig) {
                if (!gridConfig.showIfLeafProject && (me.isScopedToScrum || me.ScopedTeamType)) return Q();
                else if (!gridConfig.showIfHorizontalMode && me.isHorizontalView) return Q();
                else {
                    var list = gridConfig.model == 'UserStory' ? filteredEpics : filteredLowestPortfolioItems;
                    gridConfig.data = _.filter(list, gridConfig.filterFn);
                    gridConfig['total' + (gridConfig.model == 'UserStory' ? 'Epics' : lowestPortfolioItemType + 's')] = list;
                    gridConfig.totalCount = list.length;
                    /*gridConfig.totalPoints = (100*_.reduce(list, function(sum, item){
                     item = item.data || item; //having issue with cache
                     return sum + item.LeafStoryPlanEstimateTotal; }, 0)>>0)/100;*/
                    return me.addGrid(gridConfig);
                }
            }));
        },

        /**************************************** Event Handling **********************************/
        horizontalGroupPickerSelected: function (combo, records) {
            var me = this;
            me.clearTooltip();
            me.ScopedHorizontal = combo.getValue();
            me.ScopedTeamType = '';
            me.TeamPicker.setValue('All');
            me.setLoading(true);
            me.loadNonConfigDataFromCacheOrRally()
                .then(function () {
                    return me.renderVisuals();
                })
                .then(function () {
                    me.TeamPicker.bindStore(Ext.create('Ext.data.Store', {
                        fields: ['Type'],
                        data: me.getTeamPickerValues()
                    }));
                })
                .fail(function (reason) {
                    me.alert('ERROR', reason);
                })
                .then(function () {
                    me.setLoading(false);
                })
                .done();
        }

        ,
        releasePickerSelected: function (combo, records) {
            var me = this;
            me.clearTooltip();
            me.ReleaseRecord = _.find(me.ReleaseRecords, function (rr) {
                return rr.data.Name == records[0].data.Name;
            });
            me.setLoading(true);
            me.loadNonConfigDataFromCacheOrRally()
                .then(function () {
                    return me.renderVisuals();
                })
                .fail(function (reason) {
                    me.alert('ERROR', reason);
                })
                .then(function () {
                    me.setLoading(false);
                })
                .done();
        }
        ,
        teamPickerSelected: function (combo, records) {
            var me = this;
            me.clearTooltip();
            if (combo.getValue() !== 'All') me.ScopedTeamType = combo.getValue();
            else me.ScopedTeamType = '';
            me.setLoading(true);
            me.applyProjectFilters()
                .then(function () {
                    return me.renderVisuals();
                })
                .fail(function (reason) {
                    me.alert("ERROR", reason);
                })
                .then(function () {
                    me.setLoading(false);
                })
                .done();
        }
        ,

        /**
         Displays a tool tip when a point on the heat map is clicked
         */
        onHeatmapClick: function (point, scrum, grid) {
            var me = this,
                panelWidth = 320,
                rect = point.graphic.element.getBoundingClientRect(),
                leftSide = rect.left,
                rightSide = rect.right,
                topSide = rect.top,
                showLeft = leftSide - panelWidth > 0,
                x = point.x,
                y = point.y,
                storyDen = me.getProjectStoriesForRelease(scrum, grid).length,
                storyNum = me.getProjectStoriesForGrid(scrum, grid).length,
                pointDen = (100 * me.getProjectPointsForRelease(scrum, grid) >> 0) / 100,
                pointNum = (100 * me.getProjectPointsForGrid(scrum, grid) >> 0) / 100,
                storyPer = (10000 * storyNum / storyDen >> 0) / 100,
                pointPer = (10000 * pointNum / pointDen >> 0) / 100;

            // Clears tool tip and returns if the position hasn't changed
            if (me.tooltip && me.tooltip.x == x && me.tooltip.y == y) return me.clearTooltip();
            me.clearTooltip();

            // Builds the tool tip
            me.tooltip = {
                x: x,
                y: y,
                panel: Ext.widget('container', {
                    floating: true,
                    width: panelWidth,
                    autoScroll: false,
                    id: 'HeatmapTooltipPanel',
                    cls: 'intel-tooltip',
                    focusOnToFront: false,
                    shadow: false,
                    renderTo: Ext.getBody(),
                    items: [{
                        xtype: 'container',
                        layout: 'hbox',
                        cls: 'intel-tooltip-inner-container',
                        items: [{
                            xtype: 'container',
                            cls: 'intel-tooltip-inner-left-container',
                            flex: 1,
                            items: [{
                                xtype: 'rallygrid',
                                title: scrum.data.Name,
                                columnCfgs: [{
                                    dataIndex: 'Label',
                                    width: 60,
                                    draggable: false,
                                    sortable: false,
                                    resizable: false,
                                    editable: false
                                }, {
                                    text: 'Outstanding',
                                    dataIndex: 'Outstanding',
                                    width: 85,
                                    draggable: false,
                                    sortable: false,
                                    resizable: false,
                                    editable: false
                                }, {
                                    text: 'Total',
                                    dataIndex: 'Total',
                                    width: 60,
                                    draggable: false,
                                    sortable: false,
                                    resizable: false,
                                    editable: false
                                }, {
                                    text: '% Problem',
                                    dataIndex: 'Percent',
                                    width: 70,
                                    draggable: false,
                                    sortable: false,
                                    resizable: false,
                                    editable: false
                                }],
                                store: Ext.create('Rally.data.custom.Store', {
                                    data: [{
                                        Label: (grid.config.originalConfig.model == 'UserStory' ? 'Epics' : lowestPortfolioItemType + 's'),
                                        Outstanding: storyNum,
                                        Total: storyDen,
                                        Percent: storyPer + '%'
                                    }/*,{
                                     Label:'Points',
                                     Outstanding:pointNum,
                                     Total:pointDen,
                                     Percent:pointPer + '%'
                                     }*/]
                                }),
                                showPagingToolbar: false,
                                showRowActionsColumn: false
                            }, {
                                xtype: 'button',
                                id: 'heatmap-tooltip-goto-button',
                                text: 'GO TO THIS GRID',
                                handler: function () {
                                    me.clearTooltip();
                                    Ext.get(grid.originalConfig.id).scrollIntoView(me.el);
                                }
                            }]
                        }, {
                            xtype: 'button',
                            cls: 'intel-tooltip-close',
                            text: 'X',
                            width: 20,
                            handler: function () {
                                me.clearTooltip();
                            }
                        }]
                    }],
                    listeners: {
                        afterrender: function (panel) {
                            // Move tooltip to left or right depending on space
                            panel.setPosition(showLeft ? leftSide - panelWidth : rightSide, topSide);
                        }
                    }
                })
            };
            me.tooltip.triangle = Ext.widget('container', {
                floating: true,
                width: 0, height: 0,
                focusOnToFront: false,
                shadow: false,
                renderTo: Ext.getBody(),
                listeners: {
                    afterrender: function (panel) {
                        setTimeout(function () {
                            panel.addCls('intel-tooltip-triangle');
                            // Move tooltip to left or right depending on space
                            panel.setPosition(showLeft ? leftSide - 10 : rightSide - 10, topSide);
                        }, 10);
                    }
                }
            });
        }
        ,

        /**************************************** Tooltip Functions *******************************/
        clearTooltip: function () {
            var me = this;
            if (me.tooltip) {
                me.tooltip.panel.hide();
                me.tooltip.triangle.hide();
                me.tooltip.panel.destroy();
                me.tooltip.triangle.destroy();
                me.tooltip = null;
            }
        }
        ,
        initRemoveTooltipOnScroll: function () {
            var me = this;
            setTimeout(function addScrollListener() {
                if (me.getEl()) me.getEl().dom.addEventListener('scroll', function () {
                    me.clearTooltip();
                });
                else setTimeout(addScrollListener, 10);
            }, 0);
        }
        ,

        /**************************************** Utility Functions *******************************/
        /**
         Searches current URL for override arguments
         */
        processURLOverrides: function () {
            var me = this;
            // Create overrides object
            me.Overrides = {decodedUrl: decodeURI(window.parent.location.href)};
            // Determine if URL parameters should be used
            me.isStandalone = me.Overrides.decodedUrl.match('isStandalone=true') ? true : false;
            if (me.isStandalone) {
                // Process URL for possible parameters
                me.Overrides.TeamName = me.Overrides.decodedUrl.match('team=.*');
                me.Overrides.TeamName = (me.Overrides.TeamName ? me.Overrides.TeamName[0].slice(5).split('&')[0] : undefined);
                me.Overrides.ScopedHorizontal = me.Overrides.decodedUrl.match('group=.*');
                me.Overrides.ScopedHorizontal = (me.Overrides.ScopedHorizontal ? me.Overrides.ScopedHorizontal[0].slice(6).split('&')[0] : undefined);
                me.Overrides.ReleaseName = me.Overrides.decodedUrl.match('release=.*');
                me.Overrides.ReleaseName = (me.Overrides.ReleaseName ? me.Overrides.ReleaseName[0].slice(8).split('&')[0] : undefined);
            }
        }
        ,

        createDummyProjectRecord: function (dataObject) {
            return {data: dataObject};
        }
        ,

        /**
         Fixes the stories so that the sync request pulls the correct data.
         When Rally syncs edited data, the returned object uses the top level
         keys from the raw section of the model.
         */
        fixRawUserStoryAttributes: function () {
            var me = this,
                stories = me.UserStoryStore.getRange();
            for (var i in stories) {
                for (var j in me.UserStoryFetchFields) {
                    if (!stories[i].raw[me.UserStoryFetchFields[j]]) stories[i].raw[me.UserStoryFetchFields[j]] = 0;
                }
            }
        }
        ,

        /**
         Fixes the schedule state editor for grid editing so that bulk editing does
         not error out. This DOES still set Blocked and Ready appropriately.
         There is a line of code in the original implementation that depends on the ownerCt
         of the combobox to have a reference to the editingPlugin...which we can't give it.

         IMPORTANT! Bulk editing schedule state will not work without this
         */
        fixScheduleStateEditor: function () {
            var me = this;
            me.UserStory.getField('ScheduleState').editor = {
                xtype: 'rallyfieldvaluecombobox',
                autoExpand: true,
                field: me.UserStory.getField('ScheduleState'),
                selectOnFocus: false,
                editable: false,
                listeners: {
                    beforeselect: function () {
                        // Set all of the records Blocked and Ready to false
                    }
                },
                storeConfig: {
                    autoLoad: false
                }
            };
        }
    });
})();

            Rally.launchApp('Intel.PortfolioDataIntegrityDashboard', {
                name:"Portfolio Data Integrity Dashboard",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}
/************************************************ RALLY BUTTON STYLE *****************************************/
.intel-button {
  border-radius: 2px;
  background-color: #00a9e0;
  border-color: #00a9e0;
}
.intel-button:hover {
  background-color: #29beff;
  border-color: #29beff;
}
.intel-button * {
  font-size: 12px;
}

    </style>

    <style type="text/css">
        .intel-tooltip {
  padding: 10px;
  background-color: #C0D9FA;
  border-radius: 8px;
  z-index: 500;
  box-shadow: -3px 3px 3px;
}
.intel-tooltip p {
  margin: 2px 0 2px 0;
}
.intel-tooltip ol {
  margin: 2px 0 2px 0;
  padding-left: 20px;
}
.intel-tooltip-triangle {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-triangle-up {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-close {
  padding: 0 0 2px 0;
  font-weight: bold;
  margin-left: 5px;
  margin-top: -5px;
  border-radius: 10px;
}
.intel-tooltip-inner-container,
.intel-tooltip-inner-container * {
  overflow: visible;
}
.intel-tooltip-inner-left-container {
  overflow: hidden;
}

    </style>

    <style type="text/css">
        .app {
  margin: 0;
  padding: 0;
  width: 100%;
  overflow-x: hidden !important;
}
.ribbon {
  margin: 10px 0 0 0;
  padding: 0;
  width: 98%;
  height: 390px;
  border: 1px solid #AAA;
}
/*********************************** GRIDS  ****************************/
.grids-container {
  margin: 10px 0 0 0;
  padding: 0;
  position: relative !important;
  width: 98%;
}
.grids-container .grids-left {
  margin-right: 5px;
  position: absolute !important;
  left: 0;
}
.grids-container .grids-right {
  margin-left: 5px;
  position: absolute !important;
  right: 0;
}
.data-integrity-grid {
  border: 2px solid #AAA;
  padding: 0;
  margin: 0 0 5px 0;
}
.grid-healthy.data-integrity-grid .x-panel-header,
.grid-healthy.data-integrity-grid .x4-panel-header {
  font-weight: bold;
  background-color: rgba(0, 255, 0, 0.4) !important;
}
.grid-unhealthy.data-integrity-grid .x-panel-header,
.grid-unhealthy.data-integrity-grid .x4-panel-header {
  font-weight: bold;
  background-color: rgba(255, 0, 0, 0.4) !important;
}
.data-integrity-grid .grid-pager {
  margin: 3px !important;
}
.data-integrity-grid .editor-cell,
.data-integrity-grid .editor-cell * {
  cursor: pointer !important;
}
.data-integrity-grid.rally-grid .x-grid-row-over .editable.rally-edit-cell:not(.editor-cell):hover,
.data-integrity-grid.rally-grid .x4-grid-row-over .editable.rally-edit-cell:not(.editor-cell):hover {
  background-image: none;
}
.data-integrity-grid-header-left {
  float: left;
  font-size: 1rem;
}
.data-integrity-grid-header-stats {
  font-size: 12px;
}
.data-integrity-grid-header-top-link {
  float: right;
  cursor: pointer;
  font-weight: bold;
  font-size: 0.8rem;
}
.data-integrity-grid .x-grid-cell-inner,
.data-integrity-grid .x4-grid-cell-inner {
  white-space: normal;
}
/*********************************** HEATMAP  ****************************/
.highcharts-container {
  overflow: visible !important;
}
.my-heatmap-tooltip {
  z-index: 10000;
  border-radius: 2px;
  padding: 5px;
  border: 1px solid gray;
  background: lightgray;
}
.heatmap-xlabel {
  white-space: nowrap;
  z-index: 100;
}
.heatmap-xlabel:hover {
  color: blue;
}
.heatmap-xlabel .curscrum {
  font-weight: bolder;
  font-size: 1.1em;
}
.heatmap-xlabel-text {
  display: block;
  overflow: hidden;
}
#heatmap .highcharts-yaxis-labels > span {
  width: 134px !important;
}
.heatmap-ylabel {
  white-space: normal;
  width: 134px;
  height: 35px;
  text-align: center;
  display: flex;
  border-bottom-left-radius: 5px;
  border-top-left-radius: 5px;
  justify-content: center;
  align-items: center;
  font-size: 0.65rem;
  cursor: pointer;
  padding: 0 2px 0 2px;
  margin: 0;
}
/*********************************** integrity indicator ****************/
.integrity-inticator-title {
  font-size: 1.1rem;
  padding-right: 5px;
  text-decoration: underline;
}
.integrity-indicator-value {
  font-size: 1rem;
}
/*********************************** TOOLTIP ****************************/
#heatmap-tooltip-goto-button {
  margin-top: 5px;
}
.x-btn-default-small {
  margin-right: 5px;
}
.modified-date {
  color: green;
}

    </style>
</head>
<body>
</body>
</html>
