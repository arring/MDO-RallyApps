<!-- Build: F20013-mts-report:c8158bb4027958682585fc373b7f5f25d33a5bbb:2016-11-04T20:02:07.850Z --><!DOCTYPE html>
<html>
<head>
    <title>MTS</title>

    <script type="text/javascript" src="/apps/2.0/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
            /**
             SUMMARY:
             This extends Rally.app.app. All Intel Apps should extend from this if they want to use the functionality it provides,
             as well as numerous other lib/* files that require you to extend from this.

             If you extend from Intel.lib.IntelRallyApp, you have to call me.configureIntelRallyApp() before anything else in your launch()
             function. After you call me.configureIntelRallyApp, you will be able to access a lot of things, such as:
             - me.ScheduleStates: possible UserStory schedule States
             - me.PortfolioItemTypes: Ordered Array of PortfolioItem Types. e.g.: ['Feature', 'Milestone', 'Product']
             - me.ScrumGroupConfig: the scrum group portfolio location config for the workspace
             - me.HorizontalGroupingConfig: the horizontal scrum groupings by keywords
             - All the most-used Rally models, such as me.Project, me.UserStory, me.PortfolioItem, etc...

             DEPENDENCIES:
             Q promise library

             ISSUES:
             sdk 2.0 does not work with the project function due to a bug in the sdk. use sdk 2.0rc3
             */
            (function () {
                var Ext = window.Ext4 || window.Ext,
                        ScrumGroupConfigPrefName = 'intel-config-portfolio-locations', //preference to store portfolio locations config for workspace
                        HorizontalGroupingConfigPrefName = 'intel-config-horizontal-grouping',//preference to store map of keywords in project names to horizontal
                        TrainTypeGroupConfigPrefName = 'intel-traintype-grouping-config',//preference to store map of train type
                        EditPermissionListPrefName = 'intel-workspaceapp-permission-list',//preference to store list of people who can save changes
                        LastModifiedWorkspaceAppByPrefName = 'intel-workspaceapp-modifiedby-list';//preference to save people who last modified the preferences

                //increase timeouts to 5 minutes since rally can be slow sometimes
                var timeout = 300000;
                Ext.override(Ext.data.proxy.Ajax, {timeout: timeout});
                Ext.override(Ext.data.proxy.JsonP, {timeout: timeout});

                //rally's built-in jsonpproxy does not handle timeouts
                Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
                    setException: function (operation, response) {
                        var error = operation.getError() || {};
                        operation.setException(Ext.apply(error, {
                            errors: (response || {}).Errors || []
                        }));
                    }
                });

                Ext.define('Intel.lib.IntelRallyApp', {
                    extend: 'Rally.app.App',
                    minWidth: 910, //when Rally adds its own scrollbar anyways

                    projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
                    portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release', 'c_TeamCommits', 'c_MoSCoW',
                        'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal',
                        'PercentDoneByStoryPlanEstimate'],
                    userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
                        'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
                    releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],

                    /********************************************** APP CONFIGURATION **************************************/
                    _loadScheduleStates: function () {
                        var me = this, deferred = Q.defer();
                        Rally.data.ModelFactory.getModel({
                            type: 'UserStory',
                            success: function (model) {
                                model.getField('ScheduleState').getAllowedValueStore().load({
                                    callback: function (records, operation, success) {
                                        me.ScheduleStates = _.map(records, function (r) {
                                            return r.data.StringValue;
                                        });
                                        deferred.resolve();
                                    }
                                });
                            }
                        });
                        return deferred.promise;
                    },
                    _loadPortfolioItemStatesForEachType: function () {
                        var me = this;
                        me.PortfolioItemTypeStates = [];
                        return Q.all(_.map(me.PortfolioItemTypes, function (portfolioType, ordinal) {
                            var store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'State',
                                autoLoad: false,
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                fetch: ['Name', 'Enabled', 'OrderIndex'],
                                filters: [{
                                    property: 'TypeDef.Name',
                                    value: portfolioType
                                }, {
                                    property: 'Enabled',
                                    value: true
                                }]
                            });
                            return me.reloadStore(store).then(function (store) {
                                me.PortfolioItemTypeStates[ordinal] = store.getRange();
                            });
                        }));
                    },
                    _loadPortfolioItemTypes: function () {
                        /** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
                        var me = this,
                                deferred = Q.defer(),
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'TypeDefinition',
                                    autoLoad: true,
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    fetch: ['Ordinal', 'Name'],
                                    filters: [{
                                        property: 'Parent.Name',
                                        value: 'Portfolio Item'
                                    }, {
                                        property: 'Creatable',
                                        value: true
                                    }],
                                    listeners: {
                                        load: function (portfolioTypeStore) {
                                            me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(),
                                                                    function (item) {
                                                                        return {
                                                                            Name: item.data.Name,
                                                                            Ordinal: item.data.Ordinal
                                                                        };
                                                                    }),
                                                            function (item) {
                                                                return item.Ordinal;
                                                            }),
                                                    function (item) {
                                                        return item.Name;
                                                    });
                                            deferred.resolve();
                                        }
                                    }
                                });
                        return deferred.promise;
                    },
                    _loadModels: function () {
                        /** loads models for project, userstories, and all the portfolio items */
                        var me = this,
                                promises = [],
                                models = {
                                    User: 'User',
                                    Project: 'Project',
                                    UserStory: 'HierarchicalRequirement',
                                    PortfolioItem: 'PortfolioItem'
                                };
                        _.each(me.PortfolioItemTypes, function (name) {
                            models['PortfolioItem/' + name] = 'PortfolioItem/' + name;
                        });
                        _.each(models, function (modelType, modelName) {
                            var deferred = Q.defer();
                            Rally.data.WsapiModelFactory.getModel({
                                type: modelType,
                                success: function (loadedModel) {
                                    me[modelName] = loadedModel;
                                    deferred.resolve();
                                }
                            });
                            promises.push(deferred.promise);
                        });
                        return Q.all(promises);
                    },
                    _loadScrumGroupConfig: function () {
                        /** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
                        /** me.ScrumGroupConfig is an array of these objects:
                         {
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
                         */
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: ScrumGroupConfigPrefName,
                            success: function (prefs) {
                                var configString = prefs[ScrumGroupConfigPrefName], scrumGroupConfig;
                                try {
                                    scrumGroupConfig = JSON.parse(configString);
                                }
                                catch (e) {
                                    scrumGroupConfig = [];
                                }
                                me.ScrumGroupConfig = scrumGroupConfig;
                                deferred.resolve();
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    _loadHorizontalGroupingConfig: function () {
                        /** HorizontalGroupingConfig is this:
                         {
				enabled: boolean,
				groups: {
					<horizontal1Name>: ['keyword1', 'keyword2'],
					<horizontal2Name>: ['keyword1', 'keyword2'],
					...
				}
			}
                         */
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: HorizontalGroupingConfigPrefName,
                            success: function (prefs) {
                                var configString = prefs[HorizontalGroupingConfigPrefName], horizontalGroupingConfig;
                                try {
                                    horizontalGroupingConfig = JSON.parse(configString);
                                }
                                catch (e) {
                                    horizontalGroupingConfig = {enabled: false, groups: {}};
                                }
                                me.HorizontalGroupingConfig = horizontalGroupingConfig;
                                deferred.resolve();
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    _loadTrainTypeGroupingConfig: function () {
                        /** TrainTypeGroupingConfig is this:
                         {
				traintypes: {['keyword1', 'keyword2']}
			}
                         */
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: TrainTypeGroupConfigPrefName,
                            success: function (prefs) {
                                var configString = prefs[TrainTypeGroupConfigPrefName], trainTypeGroupingConfig;
                                try {
                                    trainTypeGroupingConfig = JSON.parse(configString);
                                }
                                catch (e) {
                                    trainTypeGroupingConfig = {traintypes: {}};
                                }
                                me.TrainTypeGroupingConfig = trainTypeGroupingConfig;
                                deferred.resolve();
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    _loadConfigEditPermissionList: function () {
                        /** ConfigEditPermissionList is this:
                         {
				username: {['keyword1', 'keyword2']}
			}
                         */
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: EditPermissionListPrefName,
                            success: function (prefs) {
                                var permissionListString = prefs[EditPermissionListPrefName], ConfigEditPermissionList;
                                try {
                                    configEditPermissionList = JSON.parse(permissionListString);
                                }
                                catch (e) {
                                    configEditPermissionList = {username: {}};
                                }
                                me.ConfigEditPermissionList = configEditPermissionList;
                                deferred.resolve();
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    _loadLastModifiedWorkspaceAppByPref: function () {
                        /**  */
                        /** me.LastModifiedWorkspaceAppBy is an array of these objects:
                         {
					KeyValueDatabase: {username:"",date:""},
					TrainTypeConfig: {username:"",date:""},
					ScrumGroupAndPortfolioConfig:{username:"",date:""},
					WorkspaceAppPermissionConfig:{username:"",date:""},
					EnableHorizontal: {username:"",date:""},
					HorizontalGroupingConfig:{username:"",date:""}
				}
                         */
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: LastModifiedWorkspaceAppByPrefName,
                            success: function (prefs) {
                                var configString = prefs[LastModifiedWorkspaceAppByPrefName], lastModifiedWorkspaceAppBy;
                                try {
                                    lastModifiedWorkspaceAppBy = JSON.parse(configString);
                                    if (_.isEmpty(lastModifiedWorkspaceAppBy))
                                        lastModifiedWorkspaceAppBy = {
                                            KeyValueDatabase: [],
                                            TrainTypeConfig: [],
                                            ScrumGroupAndPortfolioConfig: [],
                                            WorkspaceAppPermissionConfig: [],
                                            EnableHorizontal: [],
                                            HorizontalGroupingConfig: []
                                        };
                                }
                                catch (e) {
                                    lastModifiedWorkspaceAppBy = {
                                        KeyValueDatabase: [],
                                        TrainTypeConfig: [],
                                        ScrumGroupAndPortfolioConfig: [],
                                        WorkspaceAppPermissionConfig: [],
                                        EnableHorizontal: [],
                                        HorizontalGroupingConfig: []
                                    };
                                }
                                me.LastModifiedWorkspaceAppBy = lastModifiedWorkspaceAppBy;
                                deferred.resolve();
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveLastModifiedWorkspaceAppBy: function (lastModifiedByObj) {
                        var me = this, s = {}, deferred = Q.defer();
                        _.each(lastModifiedByObj, function (value, key) {
                            if (lastModifiedByObj[key].length > 10) {
                                lastModifiedByObj[key] = _.sortBy(lastModifiedByObj[key], function (o) {
                                    return new Date(o.date);
                                });
                                lastModifiedByObj[key].splice(0, lastModifiedByObj[key].length - 10);	//need to keep only 10 recent records			
                            }
                        });
                        s[LastModifiedWorkspaceAppByPrefName] = JSON.stringify(lastModifiedByObj);
                        Rally.data.PreferenceManager.update({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: LastModifiedWorkspaceAppByPrefName,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveScrumGroupConfig: function (scrumGroupConfig) {
                        var me = this, s = {}, deferred = Q.defer();
                        s[ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig);
                        Rally.data.PreferenceManager.update({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: ScrumGroupConfigPrefName,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveConfigEditPermissionList: function (userListObj) {
                        var me = this, s = {}, deferred = Q.defer();
                        s[EditPermissionListPrefName] = JSON.stringify(userListObj);
                        Rally.data.PreferenceManager.update({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: EditPermissionListPrefName,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveHorizontalGroupingConfig: function (horizontalGroupingConfig) {
                        var me = this, s = {}, deferred = Q.defer();
                        s[HorizontalGroupingConfigPrefName] = JSON.stringify(horizontalGroupingConfig);
                        Rally.data.PreferenceManager.update({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: HorizontalGroupingConfigPrefName,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveTrainTypeGroupingConfig: function (traintypeGroupingConfig) {
                        var me = this, s = {}, deferred = Q.defer();
                        s[TrainTypeGroupConfigPrefName] = JSON.stringify(traintypeGroupingConfig);
                        Rally.data.PreferenceManager.update({
                            workspace: me.getContext().getWorkspace()._ref,
                            filterByName: TrainTypeGroupConfigPrefName,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    configureIntelRallyApp: function () {
                        var me = this;
                        me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
                        return Q.all([
                            me._loadPortfolioItemTypes().then(function () {
                                me.userStoryFields.push(me.PortfolioItemTypes[0]);
                                return Q.all([
                                    me._loadModels(),
                                    me._loadPortfolioItemStatesForEachType()
                                ]);
                            }),
                            me._loadScrumGroupConfig(),
                            me._loadHorizontalGroupingConfig(),
                            me._loadTrainTypeGroupingConfig(),
                            me._loadScheduleStates()
                        ]);
                    },

                    /**************************** Generic store loading with Q wrapper, returns promise *************************************/
                    reloadStore: function (store) {
                        var deferred = Q.defer();
                        store.load({
                            callback: function (records, operation, success) {
                                if (!success) deferred.reject(operation.getError() || 'Could not load data');
                                else deferred.resolve(store);
                            }
                        });
                        return deferred.promise;
                    },

                    /********************************************** LOADING SINGLE MODELS **************************************/
                    loadProject: function (oid) {
                        var me = this, deferred = Q.defer();
                        if (!oid) return Q.reject('Invalid arguments: loadProject');
                        else if (!me.Project) return Q.reject('IntelRallyApp is not configured!');
                        else {
                            me.Project.load(oid, {
                                fetch: me.projectFields,
                                context: {
                                    workspace: me.getContext().getWorkspace()._ref,
                                    project: null
                                },
                                callback: deferred.resolve
                            });
                            return deferred.promise;
                        }
                    },
                    loadUserStory: function (oid, projectRecord) {
                        var me = this, deferred = Q.defer();
                        if (!oid) return Q.reject('Invalid arguments: loadUserStory');
                        else if (!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
                        else {
                            me.UserStory.load(oid, {
                                fetch: me.userStoryFields,
                                context: {
                                    workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
                                    project: projectRecord ? projectRecord.data._ref : null
                                },
                                callback: deferred.resolve
                            });
                            return deferred.promise;
                        }
                    },
                    loadPortfolioItemByType: function (oid, type) {
                        var me = this, deferred = Q.defer();
                        if (!oid || !type) return Q.reject('Invalid arguments: loadPortfolioItemByType');
                        else {
                            type = (type.indexOf('PortfolioItem/') === 0) ? type : ('PortfolioItem/' + type);
                            me[type].load(oid, {
                                fetch: me.portfolioItemFields,
                                context: {
                                    workspace: me.getContext().getWorkspace()._ref,
                                    project: null
                                },
                                callback: deferred.resolve
                            });
                            return deferred.promise;
                        }
                    },
                    loadPortfolioItemByOrdinal: function (oid, ordinal) {
                        var me = this, deferred = Q.defer(),
                                type = me.PortfolioItemTypes[ordinal];
                        return me.loadPortfolioItemByType(oid, type);
                    },

                    /**************************************** ScrumGroup Funcs ***************************************************/
                    projectInWhichScrumGroup: function (projectRecord) {
                        /** returns scrumgroup the projectRecord is in, otherwise null. */
                        if (!projectRecord) return Q();
                        else {
                            var me = this,
                                    foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function (scrumGroupConfig) {
                                        return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID;
                                    });
                            if (foundScrumGroupConfig) return Q(projectRecord);
                            else {
                                var parent = projectRecord.data.Parent;
                                if (!parent) return Q();
                                else {
                                    return me.loadProject(parent.ObjectID).then(function (parentRecord) {
                                        return me.projectInWhichScrumGroup(parentRecord);
                                    });
                                }
                            }
                        }
                    },
                    loadScrumGroupPortfolioProject: function (scrumGroupRootProjectRecord) {
                        if (!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: loadScrumGroupPortfolioProject');
                        var me = this,
                                foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function (scrumGroupConfig) {
                                    return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID;
                                });
                        if (!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
                        if (foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
                        else return me.loadProject(foundScrumGroupConfig.PortfolioProjectOID);
                    },
                    getScrumGroupName: function (scrumGroupRootProjectRecord) {
                        if (!scrumGroupRootProjectRecord) throw 'Invalid arguments: getScrumGroupName';
                        var me = this,
                                foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function (scrumGroupConfig) {
                                    return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID;
                                });
                        if (!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
                        if (foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
                        else return scrumGroupRootProjectRecord.data.Name;
                    },
                    loadAllScrumGroups: function () {
                        var me = this,
                                filter = _.reduce(me.ScrumGroupConfig, function (filter, scrumGroupConfig) {
                                    var newFilter = Ext.create('Rally.data.wsapi.Filter', {
                                        property: 'ObjectID',
                                        value: scrumGroupConfig.ScrumGroupRootProjectOID
                                    });
                                    return filter ? filter.or(newFilter) : newFilter;
                                }, null);
                        if (!filter) return Q([]);
                        else {
                            var store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'Project',
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                autoLoad: false,
                                fetch: me.projectFields,
                                filters: [filter],
                                context: {
                                    workspace: me.getContext().getWorkspace()._ref,
                                    project: null
                                }
                            });
                            return me.reloadStore(store).then(function (store) {
                                return store.getRange();
                            });
                        }
                    },
                    getScrumGroupPortfolioObjectIDs: function () {
                        return _.map(me.ScrumGroupConfig, function (item) {
                            return item.ScrumGroupAndPortfolioLocationTheSame ? item.ScrumGroupRootProjectOID : item.PortfolioProjectOID;
                        });
                    },
                    getPortfolioOIDForScrumGroupRootProjectRecord: function (scrumGroupRootProjectRecord) {
                        var configItem = _.find(this.ScrumGroupConfig, function (item) {
                            return item.ScrumGroupRootProjectOID === scrumGroupRootProjectRecord.data.ObjectID;
                        });
                        return configItem.ScrumGroupAndPortfolioLocationTheSame ? configItem.ScrumGroupRootProjectOID : configItem.PortfolioProjectOID;
                    },

                    /**************************************** UserStory Funcs ************************************************/
                    _getUserStoryInReleaseTimeFrameFilter: function (releaseRecord) {
                        /** only pull look at PortfolioItem Release if US.Release == null */
                        var me = this,
                                lowestPortfolioItem = me.PortfolioItemTypes[0],
                                twoWeeks = 1000 * 60 * 60 * 24 * 7 * 2,
                                releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate) * 1 + twoWeeks).toISOString(),
                                releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate) * 1 - twoWeeks).toISOString();
                        return Ext.create('Rally.data.wsapi.Filter', {
                            property: 'Release.ReleaseStartDate',
                            operator: '<',
                            value: releaseStartPadding
                        }).and(Ext.create('Rally.data.wsapi.Filter', {
                            property: 'Release.ReleaseDate',
                            operator: '>',
                            value: releaseEndPadding
                        })).or(
                                Ext.create('Rally.data.wsapi.Filter', {
                                    property: 'Release.ObjectID',
                                    value: null
                                }).and(
                                        Ext.create('Rally.data.wsapi.Filter', {
                                            property: lowestPortfolioItem + '.Release.ReleaseStartDate',
                                            operator: '<',
                                            value: releaseStartPadding
                                        }).and(Ext.create('Rally.data.wsapi.Filter', {
                                            property: lowestPortfolioItem + '.Release.ReleaseDate',
                                            operator: '>',
                                            value: releaseEndPadding
                                        }))
                                )
                        );
                    },
                    loadRandomUserStory: function (projectRecord) {
                        if (!projectRecord) return Q.reject('Invalid arguments: loadRandomUserStory');
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'HierarchicalRequirement',
                                    limit: 1,
                                    pageSize: 1,
                                    disableMetaChangeEvent: true,
                                    fetch: false,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    },
                                    filters: [{
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }]
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange().pop();
                        });
                    },
                    loadRandomUserStoryFromReleaseTimeframe: function (projectRecord, releaseRecord) {
                        if (!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: loadRandomUserStoryFromReleaseTimeframe');
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'HierarchicalRequirement',
                                    limit: 5,
                                    pageSize: 5,
                                    disableMetaChangeEvent: true,
                                    fetch: me.userStoryFields,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: undefined
                                    },
                                    sorters: [{
                                        property: 'CreationDate',
                                        direction: 'DESC'
                                    }],
                                    filters: [
                                        Ext.create('Rally.data.wsapi.Filter', {
                                            property: 'Project.ObjectID',
                                            value: projectRecord.data.ObjectID
                                        }).and(
                                                me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
                                    ]
                                });
                        return me.reloadStore(store).then(function (store) {
                            var records = store.data.items;
                            if (records.length) return Q(records[Math.floor(Math.random() * records.length)]);
                            else return Q(undefined);
                        });
                    },
                    loadUserStoryByFID: function (formattedID, projectRecord) {
                        if (!formattedID || !projectRecord) return Q.reject('Invalid arguments: loadUserStoryByFID');
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'HierarchicalRequirement',
                                    limit: 1,
                                    pageSize: 1,
                                    disableMetaChangeEvent: true,
                                    fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: undefined
                                    },
                                    filters: [{
                                        property: 'FormattedID',
                                        value: formattedID
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }]
                                });
                        return me.reloadStore(store).then(function (store) {
                            return Q(store.data.items.pop());
                        });
                    },

                    /**************************************** PortfolioItem Funcs ************************************************/
                    loadPortfolioItemsOfType: function (portfolioProject, type) {
                        if (!portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfType');
                        var me = this;
                        //US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
                        if (type == 'Business Objective') {
                            store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'PortfolioItem/' + type,
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                remoteSort: false,
                                fetch: me.portfolioItemFields,
                                context: {
                                    project: portfolioProject.data._ref,
                                    projectScopeDown: true,
                                    projectScopeUp: true
                                }
                            });
                        }
                        else {
                            store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'PortfolioItem/' + type,
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                remoteSort: false,
                                fetch: me.portfolioItemFields,
                                context: {
                                    project: portfolioProject.data._ref,
                                    projectScopeDown: true,
                                    projectScopeUp: false
                                }
                            });
                        }
                        return me.reloadStore(store);
                    },
                    loadPortfolioItemsOfTypeInRelease: function (releaseRecord, portfolioProject, type) {
                        if (!releaseRecord || !portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfTypeInRelease');
                        var me = this;
                        //US573673 Added the check to be able to scope up to the Parent level Business Objective for MVS ARTs, should work for every other Train as well
                        if (type == 'Business Objective') {
                            store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'PortfolioItem/' + type,
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                remoteSort: false,
                                fetch: me.portfolioItemFields,
                                filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
                                context: {
                                    project: portfolioProject.data._ref,
                                    projectScopeDown: true,
                                    projectScopeUp: true
                                }
                            });
                        }
                        else {
                            store = Ext.create('Rally.data.wsapi.Store', {
                                model: 'PortfolioItem/' + type,
                                limit: Infinity,
                                disableMetaChangeEvent: true,
                                remoteSort: false,
                                fetch: me.portfolioItemFields,
                                filters: [{property: 'Release.Name', value: releaseRecord.data.Name}],
                                context: {
                                    project: portfolioProject.data._ref,
                                    projectScopeDown: true,
                                    projectScopeUp: false
                                }
                            });
                        }
                        return me.reloadStore(store);
                    },
                    loadPortfolioItemsOfOrdinal: function (portfolioProject, ordinal) {
                        if (!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: loadPortfolioItemsOfOrdinal');
                        var me = this, type = me.PortfolioItemTypes[ordinal];
                        if (type) return me.loadPortfolioItemsOfType(portfolioProject, type);
                        else return Q.reject('Invalid PortfolioItem ordinal');
                    },
                    portfolioItemTypeToOrdinal: function (type) {
                        return this.PortfolioItemTypes.indexOf(type);
                    },
                    getPortfolioItemTypeStateByOrdinal: function (ordinal, stateName) {
                        return _.find(this.PortfolioItemTypeStates[ordinal], function (state) {
                            return state.data.Name == stateName;
                        });
                    },
                    getPortfolioItemTypeStateByName: function (portfolioType, stateName) {
                        return this.getPortfolioItemTypeStateByOrdinal(this.portfolioItemTypeToOrdinal(portfolioType), stateName);
                    },
                    createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap: function (portfolioItemStores) {
                        var portfolioItemMap = {};
                        _.each(portfolioItemStores[0].getRange(), function (lowPortfolioItemRecord) { //create the portfolioItem mapping
                            var ordinal = 0,
                                    parentPortfolioItemRecord = lowPortfolioItemRecord,
                                    getParentRecord = function (child, parentList) {
                                        return _.find(parentList, function (parent) {
                                            return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID;
                                        });
                                    };
                            while (ordinal < (portfolioItemStores.length - 1) && parentPortfolioItemRecord) {
                                parentPortfolioItemRecord = getParentRecord(parentPortfolioItemRecord, portfolioItemStores[ordinal + 1].getRange());
                                ++ordinal;
                            }
                            if (ordinal === (portfolioItemStores.length - 1) && parentPortfolioItemRecord) //has a mapping, so add it
                                portfolioItemMap[lowPortfolioItemRecord.data.ObjectID] = parentPortfolioItemRecord.data.Name;
                        });
                        return portfolioItemMap;
                    },

                    /********************************************** Project Funcs ********************************************/
                    /****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
                    _storeItemsToProjTree: function (projects) {
                        var me = this, projTree = {};
                        for (var i = 0, len = projects.length; i < len; ++i) {
                            var project = projects[i],
                                    thisRef = project.data.ObjectID,
                                    parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
                            if (!projTree[thisRef]) projTree[thisRef] = {};
                            projTree[thisRef].ProjectRecord = project;
                            if (parentRef) {
                                if (!projTree[parentRef]) projTree[parentRef] = {};
                                projTree[parentRef][thisRef] = projTree[thisRef];
                            }
                        }
                        return projTree;
                    },
                    _addProjectsWithTeamMembersToList: function (projTree, hash) {
                        var me = this, curProj = projTree.ProjectRecord;
                        if (curProj.data.TeamMembers.Count > 0)
                            hash[curProj.data.ObjectID] = curProj;
                        for (var childProjRef in projTree) {
                            if (childProjRef !== 'ProjectRecord')
                                me._addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
                        }
                    },
                    _allChildProjectToList: function (projTree, hash) {
                        var me = this, curProj = projTree.ProjectRecord;
                        hash[curProj.data.ObjectID] = curProj;
                        for (var childProjRef in projTree) {
                            if (childProjRef !== 'ProjectRecord')
                                me._allChildProjectToList(projTree[childProjRef], hash);
                        }
                    },
                    _allLeafProjectsToList: function (projTree, hash) {
                        var me = this, curProj = projTree.ProjectRecord;
                        if (curProj.data.Children.Count === 0)
                            hash[curProj.data.ObjectID] = curProj;
                        for (var childProjRef in projTree) {
                            if (childProjRef !== 'ProjectRecord')
                                me._allLeafProjectsToList(projTree[childProjRef], hash);
                        }
                    },
                    loadAllProjects: function () {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: "Project",
                                    fetch: me.projectFields,
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            var map = _.reduce(store.getRange(), function (map, project) {
                                map[project.data.ObjectID] = project;
                                return map;
                            }, {});
                            return map;
                        });
                    },
                    loadProjectsWithTeamMembers: function (rootProjectRecord) {
                        //rootProjectRecord is optional
                        var me = this,
                                projectsWithTeamMembers = {},
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: "Project",
                                    fetch: me.projectFields,
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            if (rootProjectRecord) {
                                var projTree = me._storeItemsToProjTree(store.getRange());
                                me._addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
                                return projectsWithTeamMembers;
                            } else {
                                return _.reduce(_.filter(store.getRange(),
                                                function (project) {
                                                    return project.data.TeamMembers.Count > 0;
                                                }),
                                        function (map, project) {
                                            map[project.data.ObjectID] = project;
                                            return map;
                                        }, {});
                            }
                        });
                    },
                    loadAllChildrenProjects: function (rootProjectRecord) {
                        //rootProjectRecord is optional
                        var me = this,
                                childrenProjects = {},
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: "Project",
                                    fetch: me.projectFields,
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            if (rootProjectRecord) {
                                var projTree = me._storeItemsToProjTree(store.getRange());
                                me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
                                return childrenProjects;
                            } else {
                                return _.reduce(store.getRange(), function (map, project) {
                                    map[project.data.ObjectID] = project;
                                    return map;
                                }, {});
                            }
                        });
                    },
                    getPorfolioProjectFilterQuery: function (rootProjectRecord) {
                        //filter out porfolio as project if train and porfolio is under same project
                        //rootProjectRecord is optional
                        var me = this,
                                deferred = Q.defer(),
                                filter = [];
                        me.ScrumGroupAndPortfolioConfig = _.filter(me.ScrumGroupConfig, function (train) {
                            return train.ScrumGroupRootProjectOID === rootProjectRecord.data.ObjectID;
                        })[0];
                        if (!rootProjectRecord || me.ScrumGroupAndPortfolioConfig.ScrumGroupAndPortfolioLocationTheSame) return Q();
                        if (me.ScrumGroupPortfolioProject) {
                            filter = Ext.create('Rally.data.wsapi.Filter', {
                                property: 'Parent.ObjectID',
                                operator: '!= ',
                                value: me.ScrumGroupPortfolioProject.data.ObjectID
                            });
                            return Q(filter);
                        } else {
                            return me.loadScrumGroupPortfolioProject(rootProjectRecord)
                                    .then(function (scrumGroupPortfolioProject) {
                                        me.ScrumGroupPortfolioProject = scrumGroupPortfolioProject;
                                        filter = Ext.create('Rally.data.wsapi.Filter', {
                                            property: 'Parent.ObjectID',
                                            operator: '!= ',
                                            value: me.ScrumGroupPortfolioProject.data.ObjectID
                                        });
                                        return Q(filter);
                                    });
                        }
                    },
                    loadAllLeafProjects: function (rootProjectRecord) {
                        //rootProjectRecord is optional
                        var me = this,
                                leafProjects = {};
                        return me.getPorfolioProjectFilterQuery(rootProjectRecord)
                                .then(function (filter) {
                                    var store = Ext.create('Rally.data.wsapi.Store', {
                                        model: "Project",
                                        fetch: me.projectFields,
                                        filters: filter ? [filter] : [],
                                        compact: false,
                                        limit: Infinity,
                                        disableMetaChangeEvent: true,
                                        context: {
                                            workspace: me.getContext().getWorkspace()._ref,
                                            project: null
                                        }
                                    });
                                    return me.reloadStore(store).then(function (store) {
                                        if (rootProjectRecord) {
                                            var projTree = me._storeItemsToProjTree(store.getRange());
                                            me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
                                            return leafProjects;
                                        } else {
                                            return _.reduce(_.filter(store.getRange(),
                                                            function (project) {
                                                                return project.data.Children.Count === 0;
                                                            }),
                                                    function (map, project) {
                                                        map[project.data.ObjectID] = project;
                                                        return map;
                                                    }, {});
                                        }
                                    });
                                });
                    },
                    loadProjectByName: function (projectName) {
                        if (!projectName) return Q.reject('Invalid arguments: LPBN');
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Project',
                                    limit: 1,
                                    pageSize: 1,
                                    fetch: ['Name', 'ObjectID'],
                                    disableMetaChangeEvent: true,
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    },
                                    filters: [{
                                        property: 'Name',
                                        value: projectName
                                    }]
                                });
                        return me.reloadStore(store).then(function (store) {
                            return Q(store.data.items.pop());
                        });
                    },

                    /********************************************** Release loading ********************************************/
                    loadAllReleases: function (projectRecord) {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleasesAfterGivenDate: function (projectRecord, givenDate) {
                        /** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'ReleaseDate',
                                        operator: '>=',
                                        value: new Date(givenDate).toISOString()
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleasesAfterGivenDateByProjectObjID: function (projectObjectID, givenDate) {
                        /** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'ReleaseDate',
                                        operator: '>=',
                                        value: new Date(givenDate).toISOString()
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleasesBeforeGivenDate: function (projectRecord, givenDate) {
                        /** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    autoLoad: false,
                                    disableMetaChangeEvent: true,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'ReleaseDate',
                                        operator: '<=',
                                        value: new Date(givenDate).toISOString()
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleasesBetweenDates: function (projectRecord, startDate, endDate) {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    autoLoad: false,
                                    fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    },
                                    filters: [{
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }, {
                                        property: 'ReleaseDate',
                                        operator: '>',
                                        value: new Date(startDate).toISOString()
                                    }, {
                                        property: 'ReleaseStartDate',
                                        operator: '<',
                                        value: new Date(endDate).toISOString()
                                    }]
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleasesInTheFuture: function (projectRecord) {
                        return this.loadReleasesAfterGivenDate(projectRecord, new Date());
                    },
                    loadReleasesByNameUnderProject: function (releaseName, projectRecord) {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'Name',
                                        value: releaseName
                                    }],
                                    context: {
                                        project: projectRecord.data._ref,
                                        projectScopeDown: true,
                                        projectScopeUp: false
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    loadReleaseByNameForProject: function (releaseName, projectRecord) {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'Name',
                                        value: releaseName
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange().pop();
                        });
                    },
                    loadReleasesByNameContainsForProject: function (releaseName, projectRecord) {
                        var me = this,
                                store = Ext.create('Rally.data.wsapi.Store', {
                                    model: 'Release',
                                    limit: Infinity,
                                    disableMetaChangeEvent: true,
                                    autoLoad: false,
                                    fetch: me.releaseFields,
                                    filters: [{
                                        property: 'Name',
                                        operator: 'contains',
                                        value: releaseName
                                    }, {
                                        property: 'Project.ObjectID',
                                        value: projectRecord.data.ObjectID
                                    }],
                                    context: {
                                        workspace: me.getContext().getWorkspace()._ref,
                                        project: null
                                    }
                                });
                        return me.reloadStore(store).then(function (store) {
                            return store.getRange();
                        });
                    },
                    getScopedRelease: function (releaseRecords, projectOID, appPrefs) {
                        /** gets the most likely release to scope to base on the following order:
                         1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need
                         to use preferences for this one)
                         2) if we are currently in one of the releases
                         3) the closest release planning date to the current date
                         */
                        var me = this,
                                d = new Date(),
                                rs = releaseRecords,
                                prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
                        return (prefOID && _.find(rs, function (r) {
                                    return r.data.ObjectID == prefOID;
                                })) ||
                                _.find(rs, function (r) {
                                    return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
                                }) ||
                                _.reduce(rs, function (best, r) {
                                    if (best === null) return r;
                                    else {
                                        var d1 = new Date(best.data.ReleaseStartDate) * 1, d2 = new Date(r.data.ReleaseStartDate) * 1, now = new Date() * 1;
                                        return (Math.abs(d1 - now) < Math.abs(d2 - now)) ? best : r;
                                    }
                                }, null);
                    }
                });
            }());
            /**
             This is a base class that renders an application based on a
             tabular display of per-scrum values organized by horizontals,
             scrum types and trains.

             Any descendant must override the following functions:
             - loadReportData()
             - setScrumDataValue()
             - getScrumTotalDataValue()
             - addScrumTotalDataValue()
             - getScrumDataValueFromScrumTotal()
             - scrumDataCellRenderer()
             - horizontalTotalCellRenderer()


             Source data is organized using this format:

             me.GridData = {
		<TrainName>: {
			<HorizontalName: ACD>: {
				<ScrumTeamType:MIO CLK 1>: {
					scrumTeamType:<ScrumTeamType: MIO CLK 1>,
					scrumName:<projectName>
					... Your own ScrumDataValue properties ...
				}
			}
		}
	}
             */
            (function () {
                var Ext = window.Ext4 || window.Ext,
                        COLUMN_DEFAULTS = {
                            text: '',
                            resizable: false,
                            draggable: false,
                            sortable: false,
                            editor: false,
                            menuDisabled: true,
                            renderer: function (val) {
                                return val || '-';
                            }
                        };

                Ext.define('Intel.lib.IntelRallyTrainsGridApp', {
                    extend: 'Intel.lib.IntelRallyApp',

                    layout: {
                        type: 'vbox',
                        align: 'stretch',
                        pack: 'start'
                    },
                    items: [{
                        xtype: 'container',
                        itemId: 'navbox'
                    }, {
                        xtype: 'container',
                        itemId: 'gridContainer',
                        cls: 'grid-container'
                    }],
                    minWidth: 910,

                    userAppsPref: 'intel-SAFe-apps-preference',


                    /**___________________________________ APP METHODS ___________________________________*/


                    loadReportData: function () {
                        // OVERLOAD ME //
                        // load here any data you may need for this app
                        return Q.resolve();
                    },
                    setScrumDataValue: function (container, scrumGroupName, projectName) {
                        // OVERLOAD ME //
                        // add any property you want to track to 'container'.
                        // this will be anything needed to show the value on each cell of the grid
                        container.value = 1;
                    },
                    getScrumTotalDataValue: function (scrumData) {
                        // OVERLOAD ME //
                        // returns a hash used to aggregate the data
                        // scrumData may be null for initialization. ScrumData refers
                        // to the container set in setScrumDataValue()
                        return scrumData == null ? {total: 0} : {total: scrumData.value};
                    },
                    addScrumTotalDataValue: function (current, scrumData) {
                        // OVERLOAD ME //
                        // aggregate values into the container for the total
                        current.total += scrumData.value;
                    },
                    getScrumDataValueFromScrumTotal: function (trainTotal) {
                        // OVERLOAD ME //
                        // map between the scrumData container and the scrumTotal container
                        return {
                            value: trainTotal.total
                        };
                    },
                    scrumDataCellRenderer: function (scrumData) {
                        // OVERLOAD ME //
                        // Ext renderer function for each cell.
                        // receives the scrumData container
                        var exists = (scrumData !== null);
                        return {
                            xtype: 'container',
                            items: {
                                xtype: 'component',
                                autoEl: {
                                    tag: 'a',
                                    html: exists ? '<span>' + scrumData.scrumName + '</span>' : '-'
                                }
                            }
                        };
                    },
                    horizontalTotalCellRenderer: function (horizontalData, meta) {
                        // OVERLOAD ME //
                        // Ext renderer function for each horizontal total
                        var hasData = horizontalData.total > 0;
                        return hasData ? '<span id="" title="' + horizontalData.HorizontalName + '">' + horizontalData.total + '</span>' : '-';
                    },


                    /**___________________________________ LOADING AND RELOADING ___________________________________*/
                    reloadEverything: function () {
                        var me = this;

                        me.setLoading('Loading Data');
                        return me.loadReportData()
                                .then(function () {
                                    me._createGridDataHash();
                                    if (!me.ReleasePicker) { //only draw the first time
                                        me.renderReleasePicker();
                                    }
                                    me.down('#gridContainer').removeAll();
                                    me.renderGrid();
                                })
                                .then(function () {
                                    me.setLoading(false);
                                });
                    },
                    _createGridDataHash: function () {
                        var me = this;
                        me.GridData = _.reduce(me.ScrumGroupConfig, function (hash, train, key) {
                            var projectNames = _.map(train.Scrums, function (scrum) {
                                return scrum.data.Name;
                            });
                            var horizontalMap = me.getAllHorizontalTeamTypeInfosFromProjectNames(projectNames);
                            hash[train.ScrumGroupName] = _.reduce(horizontalMap, function (hash, item, key) {
                                var horizontal = (item.horizontal === null) ? "Other" : item.horizontal;
                                hash[horizontal] = _.reduce(horizontalMap, function (hash, r, key) {
                                    var horizontal2 = (r.horizontal === null) ? "Other" : r.horizontal;
                                    if (horizontal === horizontal2) {
                                        var scrumTeamType = r.teamType + " " + r.number;
                                        var projectName = r.projectName;
                                        hash[scrumTeamType] = {
                                            scrumTeamType: scrumTeamType,
                                            scrumName: projectName
                                        };
                                        me.setScrumDataValue(hash[scrumTeamType], train.ScrumGroupName, projectName);
                                    }
                                    return hash;
                                }, {});
                                return hash;
                            }, {});
                            return hash;
                        }, {});
                    },
                    _loadTrainsAndScrums: function (me) {
                        // load all Trains and their scrums
                        me.projectFields = ["ObjectID", "Releases", "Children", "Parent", "Name"];
                        me.ScrumGroupConfig = _.filter(me.ScrumGroupConfig, function (item) {
                            return item.IsTrain;
                        });
                        return Q.all(
                                _.map(me.ScrumGroupConfig, function (cfg) {
                                    return me.loadAllLeafProjects({data: {ObjectID: cfg.ScrumGroupRootProjectOID}})
                                            .then(function (leafProjects) {
                                                cfg.Scrums = leafProjects;
                                            });
                                })
                        );
                    },
                    _loadCurrentRelease: function (me) {
                        //picking random Release as all the ScrumGroup share the same Release Name
                        me.ProjectRecord = me.ScrumGroupConfig[0];
                        return me.loadAppsPreference()
                                .then(function (appsPref) {
                                    me.AppsPref = appsPref;
                                    var twelveWeeks = 1000 * 60 * 60 * 24 * 7 * 12;
                                    return me.loadReleasesAfterGivenDateByProjectObjID(me.ProjectRecord.ScrumGroupRootProjectOID, (new Date() * 1 - twelveWeeks));
                                })
                                .then(function (releaseRecords) {
                                    me.ReleaseRecords = releaseRecords;
                                    var currentRelease = me.getScopedRelease(releaseRecords, me.ProjectRecord.ScrumGroupRootProjectOID, me.AppsPref);
                                    if (currentRelease) me.ReleaseRecord = currentRelease;
                                    else return Q.reject('This project has no releases.');
                                });
                    },


                    /**___________________________________ LAUNCH ___________________________________*/
                    launch: function () {
                        var me = this;
                        me.setLoading('Loading configuration');

                        if (!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())) {
                            me.setLoading(false);
                            me.alert('ERROR', 'You do not have permissions to edit this project');
                            return;
                        }
                        console.log("configuring rally app...");
                        me.configureIntelRallyApp()
                                .then(function () {
                                    console.log("loading trains and scrums...");
                                    return me._loadTrainsAndScrums(me);
                                })
                                .then(function () {
                                    console.log("loading current release...");
                                    return me._loadCurrentRelease(me);
                                })
                                .then(function () {
                                    console.log("loading data...");
                                    return me.reloadEverything();
                                })
                                .fail(function (reason) {
                                    me.alert('ERROR', reason);
                                })
                                .finally(function () {
                                    me.setLoading(false);
                                })
                                .done();
                    },

                    /**___________________________________ NAVIGATION AND STATE ___________________________________*/
                    releasePickerSelected: function (combo, records) {
                        var me = this, pid = me.ProjectRecord.ScrumGroupRootProjectOID;
                        if (me.ReleaseRecord.data.Name === records[0].data.Name) return;
                        me.setLoading("Saving Preference");
                        me.ReleaseRecord = _.find(me.ReleaseRecords, function (rr) {
                            return rr.data.Name == records[0].data.Name;
                        });
                        if (typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
                        me.AppsPref.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
                        me.saveAppsPreference(me.AppsPref)
                                .then(function () {
                                    return me.reloadEverything();
                                })
                                .fail(function (reason) {
                                    me.setLoading(false);
                                    me.alert('ERROR', reason);
                                })
                                .then(function () {
                                    me.setLoading(false);
                                })
                                .done();
                    },
                    renderReleasePicker: function () {
                        var me = this;
                        me.ReleasePicker = me.down('#navbox').add({
                            xtype: 'intelreleasepicker',
                            id: 'releasePicker',
                            labelWidth: 70,
                            width: 250,
                            releases: me.ReleaseRecords,
                            currentRelease: me.ReleaseRecord,
                            listeners: {select: me.releasePickerSelected.bind(me)}
                        });
                    },

                    /************************************************************* RENDER ********************************************************************/

                    _buildDataGrid: function (gridData) {
                        // generate a data structure in the expected format for rendering
                        var me = this,
                                trainTotals = {},
                                horizontalTotals = {},
                                horizontalTeamTypes = {};

                        _.each(gridData, function (trainData, trainName) {
                            trainTotals[trainName] = _.merge({TrainName: trainName}, me.getScrumTotalDataValue());
                            _.each(trainData, function (horizontalData, horizontalName) {
                                horizontalTotals[horizontalName] = horizontalTotals[horizontalName] || _.merge({HorizontalName: horizontalName}, me.getScrumTotalDataValue());
                                horizontalTeamTypes[horizontalName] = horizontalTeamTypes[horizontalName] || [];
                                _.each(horizontalData, function (scrumData, scrumTeamType) {
                                    me.addScrumTotalDataValue(horizontalTotals[horizontalName], scrumData);
                                    me.addScrumTotalDataValue(trainTotals[trainName], scrumData);
                                    horizontalTeamTypes[horizontalName].push(scrumTeamType);
                                });
                            });
                        }, []);

                        //build the rows for the table
                        var data = _.map(_.keys(horizontalTotals).sort(), function (horizontalTotalName) {
                            return {
                                horizontalData: horizontalTotals[horizontalTotalName],
                                horizontalTeamTypes: _.uniq(horizontalTeamTypes[horizontalTotalName]).sort()
                            };
                        });
                        //put 'Other' Row last
                        var otherRow = _.find(data, function (row) {
                            return row.horizontalData.HorizontalName == 'Other';
                        });
                        if (otherRow !== null) {
                            data = _.filter(data, function (row) {
                                return row.horizontalData.HorizontalName !== 'Other';
                            }).concat(otherRow);
                        }
                        _.each(trainTotals, function (trainTotal, trainName) {
                            _.each(data, function (row) {
                                row[trainName] = _.map(row.horizontalTeamTypes, function (teamType) {
                                    if ((gridData[trainName][row.horizontalData.HorizontalName] || {})[teamType])
                                        return gridData[trainName][row.horizontalData.HorizontalName][teamType];
                                    else
                                        return null;
                                });
                            });
                        });
                        //build the last row, with the train data 
                        data.push(_.merge({
                            horizontalData: _.merge({HorizontalName: ''}, me.getScrumTotalDataValue()),
                            horizontalTeamTypes: ['-']
                        }, _.reduce(trainTotals, function (map, trainTotal, trainName) {
                            map[trainName] = [
                                _.merge(
                                        {scrumName: trainName},
                                        me.getScrumDataValueFromScrumTotal(trainTotal)
                                )
                            ];
                            return map;
                        }, {})));

                        return data;
                    },

                    _buildGridColumns: function (trains) {
                        var me = this;
                        return [].concat(
                                [{
                                    text: ' ', //Horizontal Name Column
                                    dataIndex: 'horizontalData',
                                    tdCls: 'horizontal-name-cell',
                                    width: 100,
                                    sortable: false,
                                    renderer: function (horizontalData, meta) {
                                        return horizontalData.HorizontalName;
                                    }
                                }, {
                                    text: ' ', //Horizontal Team Types Column
                                    xtype: 'intelcomponentcolumn',
                                    dataIndex: 'horizontalTeamTypes',
                                    width: 100,
                                    tdCls: 'stdci-cell-container',
                                    sortable: false,
                                    renderer: function (horizontalTeamTypes) {
                                        return Ext.create('Ext.container.Container', {
                                            layout: {type: 'vbox'},
                                            width: '100%',
                                            items: _.map(horizontalTeamTypes, function (teamType) {
                                                return {
                                                    xtype: 'container',
                                                    flex: 1,
                                                    cls: 'team-type-cell',
                                                    html: teamType
                                                };
                                            })
                                        });
                                    }
                                }],
                                _.map(trains.sort(), function (trainName) {
                                    return {
                                        text: trainName, //Train Column
                                        xtype: 'intelcomponentcolumn',
                                        dataIndex: trainName,
                                        width: 100,
                                        cls: 'train-header-cls',
                                        tdCls: 'stdci-cell-container',
                                        sortable: false,
                                        renderer: function (scrumDataList) {
                                            return Ext.create('Ext.container.Container', {
                                                layout: {type: 'vbox'},
                                                width: '100%',
                                                padding: 0,
                                                margin: 0,
                                                flex: 1,
                                                items: _.map(scrumDataList, me.scrumDataCellRenderer)
                                            });
                                        }
                                    };
                                }),
                                [{
                                    text: ' ', //Horizontal % column
                                    dataIndex: 'horizontalData',
                                    tdCls: '',
                                    width: 100,
                                    sortable: false,
                                    renderer: me.horizontalTotalCellRenderer
                                }]
                        );
                    },

                    _getGridWidth: function (columns) {
                        var me = this;

                        return Math.min(
                                _.reduce(columns, function (sum, column) {
                                    return sum + column.width;
                                }, 2),
                                window.innerWidth - 2
                        );
                    },

                    renderGrid: function () {
                        var me = this;
                        console.log("building data grid...");

                        //preprocess the data so we can create the rows for the table
                        var data = me._buildDataGrid(me.GridData);

                        // get the list of trains
                        var trains = _.keys(me.GridData);

                        //create the store that will hold the rows in the table
                        var gridStore = Ext.create('Ext.data.Store', {
                            fields: [
                                {name: 'horizontalData', type: 'auto'},
                                {name: 'horizontalTeamTypes', type: 'auto'}
                            ]
                                    .concat(_.map(trains, function (train) {
                                        return {name: train, type: 'auto'};
                                    })),
                            data: data
                        });

                        //create the column definitions and renderers
                        console.log("building grid columns...");
                        var columns = me._buildGridColumns(trains);

                        //finally build the grid
                        console.log("rendering grid...");
                        me.down('#gridContainer').add({
                            xtype: 'grid',
                            scroll: 'both',
                            resizable: false,
                            viewConfig: {
                                stripeRows: false,
                                preserveScrollOnRefresh: true
                            },
                            width: me._getGridWidth(columns),

                            columns: {
                                defaults: COLUMN_DEFAULTS,
                                items: columns
                            },
                            store: gridStore,
                            enableEditing: false,
                            disableSelection: true
                        });
                        setTimeout(function () {
                            me.doLayout();
                            console.log("done");
                        }, 500);
                    }
                });
            }());
            /**
             SUMMARY:
             This mixin is used if you want to listen to events in the parent window (e.g. useful for rally apps that
             resize with browser screen vertically or things that need to know browser scroll position)
             You also can artificially fire the events and have the listeners run using fireParentWindowEvent
             */
            (function () {
                var Ext = window.Ext4 || window.Ext,
                        windowListeners = {};

                Ext.define('Intel.lib.mixin.WindowListener', {

                    _initWindowEventListener: function (eventName) {
                        if (!windowListeners) windowListeners = {};
                        windowListeners[eventName] = [];

                        window.parent['on' + eventName] = function (event) {
                            var listeners = windowListeners[eventName];
                            for (var i = 0, len = listeners.length; i < len; ++i)
                                listeners[i](event);
                        };
                    },

                    /** eventName is something like: resize, scroll, etc... */
                    addWindowEventListener: function (eventName, fn) {
                        if (!windowListeners || !windowListeners[eventName])
                            this._initWindowEventListener(eventName);
                        windowListeners[eventName].push(fn);
                    },

                    /** eventName is something like: resize, scroll, etc... */
                    fireParentWindowEvent: function (eventName) {
                        var me = this;
                        if (!windowListeners || !windowListeners[eventName]) return;
                        var listeners = windowListeners[eventName];
                        for (var i = 0, len = listeners.length; i < len; ++i) listeners[i]();
                    }
                });
            }());
            /**
             SUMMARY:
             this mixin is used to mess with the environment outside of the iframe that the rally app is put in.

             DEPENDENCIES:
             'Intel.lib.mixin.WindowListener' mixed in to app so listen for window events
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                var TOP_BAR_HEIGHT = 40,
                        BOTTOM_BAR_HEIGHT = 24,
                        BOTTOM_IFRAME_PADDING = 20,
                        TITLE_BAR_HEIGHT = 33,
                        IFRAME_HEADER_HEIGHT = 28;

                Ext.define('Intel.lib.mixin.IframeResize', {
                    requires: ['Intel.lib.mixin.WindowListener'],

                    /**
                     makes app as large as screen, without the padding/margin.
                     Makes it look more like a built-in rally app instead of a custom app.
                     NOTE: as rally changes their interface overtime, this mixin will have to change as well to compensate for it.
                     This changed once and all the classes names got changes. Thats why its commented out.
                     */
                    hideGearButtonAndCustomAppPanel: function () {
                        var me = this;
                        if (Ext.get(window.frameElement)) {
                            //hide the gear button for the first panel that has the App name
                            Ext.get(window.frameElement).up('#content').down('.smb-Header').dom.querySelectorAll('.smb-HeaderGroupContainer--right')[0].style.display = 'none';
                            //hides the whole custom html panel 
                            Ext.get(window.frameElement).up('#content').down('.smb-Grid').down('.smb-Header').dom.style.display = 'none';
                        }
                    },
                    _fixRallyDashboard: function () {
                        /*	if(window && window.frameElement){
                         var me=this,
                         bottomEl = Ext.get(window.frameElement),
                         portlet = bottomEl.up('.x-portlet'), 
                         dashboard = portlet.up('#mydash_portlet'), //has huge padding values
                         titleBar = dashboard.down('.titlebar'), //redundant with app header bar
                         domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
                         innerHeight = window.parent.innerHeight,
                         innerWidth = window.parent.innerWidth;

                         //remove vertical/horizontal scrolls from top window
                         window.parent.document.body.insertAdjacentHTML('afterend', '<style>html, body {overflow: hidden !important; }</style>');

                         //adjust widths
                         while(true){
                         domNodeW.style.width = (innerWidth - 10) + 'px';
                         domNodeW.style.padding = '0';
                         domNodeW.style.margin = '0';
                         if(domNodeW.id === 'mydash_portlet') break;
                         domNodeW = domNodeW.parentNode;
                         }

                         //adjust heights
                         while(true){
                         domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING) - 10) + 'px';
                         if(domNodeH.classList.contains('x-portlet')) break;
                         domNodeH = domNodeH.parentNode;
                         }
                         while(true){
                         domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
                         if(domNodeH.id == 'mydash_portlet') break;
                         domNodeH = domNodeH.parentNode;
                         }
                         dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';

                         //final touches LOL
                         dashboard.dom.style.padding = "0 2px 0 2px";
                         titleBar.dom.style.padding = "2px";
                         titleBar.dom.style.margin = "0";
                         } */
                    },
                    initFixRallyDashboard: function () {
                        /*		var me=this;
                         if(me.addWindowEventListener){
                         me.addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
                         }
                         me._fixRallyDashboard(); */
                    },

                    /**
                     hides the draggable resize handle from under the app
                     */
                    _disableResizeHandle: function () {
                        /*		var me=this, handle;
                         if(window && window.frameElement){
                         handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
                         if(handle) {
                         handle.hide();
                         handle.dom.onshow = function(){ if(handle) handle.hide(); };
                         }
                         } */
                    },
                    initDisableResizeHandle: function () {
                        /*		var me=this;
                         if(me.addWindowEventListener){
                         me.addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
                         }
                         me._disableResizeHandle(); */
                    }
                });
            }());
            /**
             DESCRIPTION:
             This mixin gives a window-centered alert or confirm dialog box that isn't ugly.

             ISSUES:
             Sometimes alert.setY() fails so we have to fallback to the ugly built-in alert
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.mixin.PrettyAlert', {
                    _getMessageBoxY: function () {
                        var me = this,
                                bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
                                ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
                                ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
                                ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
                                iyOffset = Math.floor(ph / 2 - ofy + ps - 50);
                        return iyOffset < 0 ? 0 : iyOffset;
                    },

                    _formatString: function (message) {
                        message = message || '';
                        return (typeof message === 'string') ?
                                message : (message.message ?
                                message.message : JSON.stringify(message, null, '\t'));
                    },

                    /** non-ugly alert dialog */
                    alert: function (title, message) {
                        if (arguments.length < 1) return;
                        if (arguments.length === 1) {
                            message = title;
                            title = '';
                        }

                        try {
                            Ext.MessageBox.alert(this._formatString(title), this._formatString(message)).setY(this._getMessageBoxY());
                            setTimeout(function () {
                                var x = Ext.MessageBox.down('button');
                                while (x.isHidden()) x = x.nextSibling();
                                x.focus();
                            }, 50);
                        }
                        catch (e) {
                            alert(this._formatString(message));
                        }
                    },

                    /** non-ugly confirm dialog */
                    confirm: function (title, message, fn) {
                        if (arguments.length < 2) return;
                        if (arguments.length === 2) {
                            fn = message;
                            message = title;
                            title = '';
                        }
                        if (typeof fn !== 'function') fn = function () {
                        };

                        try {
                            Ext.MessageBox.confirm(this._formatString(title), this._formatString(message), fn).setY(this._getMessageBoxY());
                            setTimeout(function () {
                                var x = Ext.MessageBox.down('button');
                                while (x.isHidden()) x = x.nextSibling();
                                x.focus();
                            }, 50);
                        }
                        catch (e) {
                            if (confirm(this._formatString(message))) fn('yes'); else fn('no');
                        }
                    }
                });
            }());
            /**
             SUMMARY:
             Use this mixin to load stores that have lots of records. it will load them in parallel instead of serially.
             what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.

             The config you pass to parallelLoadLookbackStore and parallelLoadWsapiStore are the same configs you would pass
             to Rally.data.lookback.Store (or something like that) and Rally.data.wsapi.Store.
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.mixin.ParallelLoader', {
                    parallelLoadWsapiStore: function (config) {
                        var me = this, data = [], model;

                        function doStoreLoad(page) {
                            var deferred = Q.defer(),
                                    store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
                                        pageSize: 200,
                                        listeners: {
                                            load: function (store, records, successful) {
                                                if (!successful) deferred.reject('could not load data from server');
                                                else deferred.resolve(store);
                                            }
                                        }
                                    }));
                            store.loadPage(page);
                            return deferred.promise;
                        }

                        function makeStore() {
                            return Ext.create('Rally.data.wsapi.Store', {
                                model: model,
                                totalCount: data.length,
                                data: data,
                                disableMetaChangeEvent: true,
                                load: function () {
                                }
                            });
                        }

                        return doStoreLoad(1).then(function (store) {
                            data = data.concat(store.getRange());
                            model = store.model;
                            var pages = ((store.totalCount / 200 >> 0) + (store.totalCount % 200 ? 1 : 0)) || 1;
                            if (pages === 1) return makeStore();
                            else return Q.all(_.times(pages - 1, function (pageNum) {
                                return doStoreLoad(pageNum + 2).then(function (store) {
                                    data = data.concat(store.getRange());
                                });
                            })).then(makeStore);
                        });
                    },
                    parallelLoadLookbackStore: function (config) {
                        var me = this, data = [], model;

                        function doStoreLoad(page) {
                            var deferred = Q.defer(),
                                    store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
                                        pageSize: 20000,
                                        listeners: {
                                            load: function (store, records, successful) {
                                                if (!successful) deferred.reject('could not load data from server');
                                                else deferred.resolve(store);
                                            }
                                        }
                                    }));
                            store.loadPage(page);
                            return deferred.promise;
                        }

                        function makeStore() {
                            return Ext.create('Rally.data.lookback.SnapshotStore', {
                                model: model,
                                totalCount: data.length,
                                data: data,
                                disableMetaChangeEvent: true,
                                load: function () {
                                }
                            });
                        }

                        return doStoreLoad(1).then(function (store) {
                            data = data.concat(store.getRange());
                            model = store.model;
                            var pages = ((store.totalCount / 20000 >> 0) + (store.totalCount % 20000 ? 1 : 0)) || 1;
                            if (pages === 1) return makeStore();
                            else return Q.all(_.times(pages - 1, function (pageNum) {
                                return doStoreLoad(pageNum + 2).then(function (store) {
                                    data = data.concat(store.getRange());
                                });
                            })).then(makeStore);
                        });
                    }
                });
            }());

            /**
             SUMMARY:
             This mixin is used to save user preferences per project, that can follow the user from app to app. So
             when you call saveAppsPreference it saves it to a preference filtered by user and the value of me.userAppsPref.

             Different apps can share the me.userAppsPref which is useful if you have 5 apps that should all scope to the same
             Release. So if the user scopes to Release R1 on one of the apps, when she goes to any of the other apps, it should
             scope to Release R1 as well.
             **/
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.mixin.UserAppsPreference', {

                    /** preference name SHOULD be overridden, unless you want all apps to share default preference-name */
                    userAppsPref: 'intel-user-apps-preference',

                    loadAppsPreference: function () {
                        var me = this, deferred = Q.defer();
                        Rally.data.PreferenceManager.load({
                            filterByUser: true,
                            filterByName: me.userAppsPref,
                            success: function (prefs) {
                                var appPrefs = prefs[me.userAppsPref];
                                try {
                                    appPrefs = JSON.parse(appPrefs);
                                }
                                catch (e) {
                                    appPrefs = {projs: {}, refresh: 0};
                                }
                                deferred.resolve(appPrefs);
                            },
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    },
                    saveAppsPreference: function (prefs) {
                        var me = this, s = {}, deferred = Q.defer();
                        prefs = {projs: prefs.projs, refresh: prefs.refresh};
                        s[me.userAppsPref] = JSON.stringify(prefs);
                        Rally.data.PreferenceManager.update({
                            filterByUser: true,
                            filterByName: me.userAppsPref,
                            settings: s,
                            success: deferred.resolve,
                            failure: deferred.reject
                        });
                        return deferred.promise;
                    }
                });
            }());
            /**
             This mixin exposes a few public methods that allow the caller to easily get
             info about the horizontal and teamTypeInfo for a list of projects.

             The reason that you should ALWAYS call getAllHorizontalTeamTypeInfos with multiple
             projects instead of getHorizontalTeamTypeInfo 1 project is because this allows the
             'number' field of the teamTypeInfo to be set correctly.
             For example:
             You have projects: ['MPV 1', 'MPV 2', 'MVP OR'],
             this will map to: ['MPV 1', 'MPV 2', 'MPV 3']
             but if you passed all three separately: ['MPV 1'], ['MPV 2'], ['MVP OR'],
             you would end up with 2 'MPV 1's: ['MPV 1'], ['MPV 2'], ['MVP 1'],

             The above example shows that the algorithm tries to set the numbers of teams
             with no numbers. the numbers assigned to these will be relative to the other
             projects passed in. That is why you will ALMOST ALWAYS WASNT TO PASS IN ALL
             PROJECTS OF A TRAIN AT ONCE!
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.mixin.HorizontalTeamTypes', {
                    requires: ['Intel.lib.IntelRallyApp'],

                    _getHorizontalTeamTypeInfo: function (projectRecord) {
                        var me = this,
                                scrumName = projectRecord.data.Name.split('-')[0].trim(), //.replace(/\(.*\)/g, '')
                                scrumTeamType = scrumName.split(/\d/)[0].trim(),
                                number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
                                notInHorizontalObject = {
                                    projectRecord: projectRecord,
                                    horizontal: null,
                                    teamType: scrumTeamType,
                                    teamTypeComponents: [],
                                    number: number
                                },
                                teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function (result, teamTypes, horizontal) {
                                    if (result) return result;
                                    else {
                                        var teamTypeMatches = _.reduce(teamTypes, function (teamTypeMatches, teamType) {
                                            /**
                                             If the teamType is in the name of the scrum, add it to teamTypeMatches.
                                             If there is another teamType already added that is a substring of this teamType,
                                             remove it from the teamType matches. If the current teamType is a substring of another
                                             teamType already matches, DO NOT add this teamType to the matched teamTypes

                                             Example:
                                             scrum name="ABC - Train"
                                             teamType options:["AB" "ABC" "ABCD"]

                                             the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
                                             */
                                            if (scrumName.indexOf(teamType) > -1) {
                                                for (var i = teamTypeMatches.length - 1; i >= 0; --i) {
                                                    if (teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
                                                    if (teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
                                                }
                                                teamTypeMatches.push(teamType);
                                            }
                                            return teamTypeMatches;
                                        }, []);
                                        return teamTypeMatches.length ? {
                                            projectRecord: projectRecord,
                                            horizontal: horizontal,
                                            teamType: teamTypeMatches.sort().join(' '),
                                            teamTypeComponents: teamTypeMatches.sort(),
                                            number: number
                                        } :
                                                null;
                                    }
                                }, null);
                        return teamTypeObject || notInHorizontalObject;
                    },
                    _resolveTeamTypeInfoConflicts: function (teamTypeInfos, startIndex) {
                        startIndex = startIndex || 1;
                        _.each(_.sortBy(teamTypeInfos,
                                        function (teamTypeInfo) {
                                            return teamTypeInfo.projectRecord.data.Name;
                                        }),
                                function (teamTypeInfo, index) {
                                    teamTypeInfo.number = index + startIndex;
                                    return teamTypeInfo;
                                });
                    },
                    getAllHorizontalTeamTypeInfos: function (projectRecords) {
                        var me = this;
                        return [].concat.apply([], _.map(_.groupBy(_.map(projectRecords,
                                                        function (projectRecord) {
                                                            return me._getHorizontalTeamTypeInfo(projectRecord);
                                                        }),
                                                function (teamTypeInfo) {
                                                    return teamTypeInfo.teamType;
                                                }),
                                        function (teamTypeInfos) {
                                            if (teamTypeInfos.length === 1) return teamTypeInfos;
                                            else {
                                                var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function (teamTypeInfo) {
                                                    return teamTypeInfo.number === 1;
                                                });
                                                if (teamTypeInfosWithNumber1.length > 1) {
                                                    var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function (teamTypeInfo) {
                                                                return teamTypeInfo.projectRecord.data.Name.indexOf('1') === -1;
                                                            }),
                                                            startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
                                                    me._resolveTeamTypeInfoConflicts(projectsWithoutExplicit1, startIndex);
                                                }
                                                return teamTypeInfos;
                                            }
                                        })
                        );
                    },
                    getHorizontalTeamTypeInfo: function (projectRecord) {
                        return this._getHorizontalTeamTypeInfo(projectRecord);
                    },
                    isProjectInHorizontal: function (projectRecord, horizontal) {
                        return this._getHorizontalTeamTypeInfo(projectRecord).horizontal === horizontal;
                    },

                    _getHorizontalTeamTypeInfoFromProjectName: function (projectName) {
                        var me = this,
                                scrumName = projectName.split('-')[0].trim(), //.replace(/\(.*\)/g, '')
                                scrumTeamType = scrumName.split(/\d/)[0].trim(),
                                number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
                                notInHorizontalObject = {
                                    projectName: projectName,
                                    horizontal: null,
                                    teamType: scrumTeamType,
                                    teamTypeComponents: [],
                                    number: number
                                },
                                teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function (result, teamTypes, horizontal) {
                                    if (result) return result;
                                    else {
                                        var teamTypeMatches = _.reduce(teamTypes, function (teamTypeMatches, teamType) {
                                            /**
                                             If the teamType is in the name of the scrum, add it to teamTypeMatches.
                                             If there is another teamType already added that is a substring of this teamType,
                                             remove it from the teamType matches. If the current teamType is a substring of another
                                             teamType already matches, DO NOT add this teamType to the matched teamTypes

                                             Example:
                                             scrum name="ABC - Train"
                                             teamType options:["AB" "ABC" "ABCD"]

                                             the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
                                             */
                                            if (scrumName.indexOf(teamType) > -1) {
                                                for (var i = teamTypeMatches.length - 1; i >= 0; --i) {
                                                    if (teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
                                                    if (teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
                                                }
                                                teamTypeMatches.push(teamType);
                                            }
                                            return teamTypeMatches;
                                        }, []);
                                        return teamTypeMatches.length ? {
                                            projectName: projectName,
                                            horizontal: horizontal,
                                            teamType: teamTypeMatches.sort().join(' '),
                                            teamTypeComponents: teamTypeMatches.sort(),
                                            number: number
                                        } :
                                                null;
                                    }
                                }, null);
                        return teamTypeObject || notInHorizontalObject;
                    },
                    _resolveTeamTypeInfoConflictsFromProjectNames: function (teamTypeInfos, startIndex) {
                        startIndex = startIndex || 1;
                        _.each(_.sortBy(teamTypeInfos,
                                        function (teamTypeInfo) {
                                            return teamTypeInfo.projectName;
                                        }),
                                function (teamTypeInfo, index) {
                                    teamTypeInfo.number = index + startIndex;
                                    return teamTypeInfo;
                                });
                    },
                    getAllHorizontalTeamTypeInfosFromProjectNames: function (projectNames) {
                        var me = this;
                        return [].concat.apply([], _.map(_.groupBy(_.map(projectNames,
                                                        function (projectName) {
                                                            return me._getHorizontalTeamTypeInfoFromProjectName(projectName);
                                                        }),
                                                function (teamTypeInfo) {
                                                    return teamTypeInfo.teamType;
                                                }),
                                        function (teamTypeInfos) {
                                            if (teamTypeInfos.length === 1) return teamTypeInfos;
                                            else {
                                                var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function (teamTypeInfo) {
                                                    return teamTypeInfo.number === 1;
                                                });
                                                if (teamTypeInfosWithNumber1.length > 1) {
                                                    var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function (teamTypeInfo) {
                                                                return teamTypeInfo.projectName.indexOf('1') === -1;
                                                            }),
                                                            startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
                                                    me._resolveTeamTypeInfoConflictsFromProjectNames(projectsWithoutExplicit1, startIndex);
                                                }
                                                return teamTypeInfos;
                                            }
                                        })
                        );
                    },
                    getHorizontalTeamTypeInfoFromProjectName: function (projectName) {
                        return this._getHorizontalTeamTypeInfoFromProjectName(projectName);
                    },
                    isProjectNameInHorizontal: function (projectName, horizontal) {
                        return this._getHorizontalTeamTypeInfoFromProjectName(projectName).horizontal === horizontal;
                    },

                    getAllHorizontalTeamTypeComponents: function () {
                        return [].concat.apply([], _.values(this.HorizontalGroupingConfig.groups));
                    },
                    getAllHorizontals: function () {
                        return _.keys(this.HorizontalGroupingConfig.groups);
                    },
                    teamTypeComponentInWhichHorizontal: function (teamType) {
                        var me = this;
                        return _.find(_.keys(me.HorizontalGroupingConfig.groups), function (hz) {
                            return _.contains(me.HorizontalGroupingConfig.groups[hz], teamType);
                        });
                    }
                });
            }());

            //TODO: find this on a CDN and remove it from here
            (function () {
                var Ext = window.Ext4 || window.Ext;

                var POLL_INTERVAL_MS = 10;

                /*!
                 * CTemplate
                 * Version 1.1
                 * Copyright(c) 2011-2013 Skirtle's Den
                 * License: http://skirtlesden.com/ux/ctemplate

                 MY NOTE: how this works. XTemplates use apply() to convert the template to the actual HTML. CTemplate converts XTemplate into a bunch
                 of <p> tags and stores the ids of them and then immediately starts polling for them in doPolling. do POlling calls injectComponents
                 after the poll interval and if injectComponents does not render all the components, it calls doPolling again.
                 injectComponents calls renderComponent for each component.
                 overwrite and doInsert call the XTemplate parent functions, which call CTemplate's apply, and then they call injectComponents.

                 NOTE: everytime apply() is called, the me.ids[] is generated, and when injectComponents is finished, me.ids[] is empty!
                 */
                Ext.define('Skirtle.CTemplate', {
                    extend: 'Ext.XTemplate',
                    statics: {AUTO_ID: 0},

                    copyDepth: 10,
                    cTpl: '<p id="ctemplate-{0}-{1}"></p>',
                    isCTemplate: true,

                    constructor: function () {
                        var me = this;
                        me.callParent(arguments);
                        me.id = ++me.statics().AUTO_ID;
                        me.reset();
                    },

                    copyValues: function (values, depth) {
                        /* Takes a recursive copy of the values provided, switching out components for placeholder values. The component ids
                         * are recorded and injectComponents() uses the ids to find the placeholder elements in the DOM and switch in the
                         * components.
                         */
                        var me = this,
                                id,
                                copy = {},
                                copyDepth = depth || me.copyDepth;

                        if (copyDepth === 1) return values;

                        if (Ext.isArray(values)) {
                            return Ext.Array.map(values, function (value) {
                                return me.copyValues(value, copyDepth - 1);
                            });
                        }

                        if (!Ext.isObject(values)) return values;

                        // This is the key sleight-of-hand that makes the whole thing work
                        if (values.isComponent) {
                            id = values.getId();
                            me.ids.push(id);
                            return Ext.String.format(me.cTpl, id, me.id);
                        }

                        Ext.Object.each(values, function (key, value) {
                            // $comp is a special value for a renderTpl that references the current component
                            copy[key] = key === '$comp' ? value : me.copyValues(value, copyDepth - 1);
                        });

                        return copy;
                    },
                    doInsert: function () { // Override
                        //(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
                        var ret = this.callParent(arguments);
                        this.injectComponents();// There's no guarantee this will succeed so we still need polling as well
                        return ret;
                    },
                    doPolling: function (interval) {
                        var me = this;
                        me.pollInterval = interval;
                        if (me.pollId) clearTimeout(me.pollId);
                        me.pollId = Ext.defer(me.injectComponents, interval, me);
                    },
                    getPlaceholderEl: function (id) {
                        return Ext.get('ctemplate-' + id + '-' + this.id);
                    },
                    injectComponents: function () {
                        /* Attempts to substitute all placeholder elements with the real components. If a component is successfully injected
                         * or it has been destroyed then it won't be attempted again. This method is repeatedly invoked by a polling
                         * mechanism until no components remain, however relying on the polling is not advised. Instead it is preferable to
                         * call this method directly as soon as the generated HTML is inserted into the DOM.
                         */
                        var me = this,
                                ids = me.ids,
                                index = ids.length - 1,
                                id,
                                cmp,
                                placeholderEl;

                        // Iterate backwards because we remove some elements in the loop
                        for (; index >= 0; --index) {
                            id = ids[index];
                            cmp = Ext.getCmp(id);
                            placeholderEl = me.getPlaceholderEl(id);
                            if (me.renderComponent(cmp, placeholderEl) || !cmp) {
                                // Either we've successfully done the switch or the component has been destroyed
                                Ext.Array.splice(ids, index, 1);
                                if (placeholderEl) placeholderEl.remove();
                            }
                        }
                        // Some components have not been injected. Polling acts both to do deferred injection and as a form of GC
                        if (ids.length) me.doPolling(me.pollInterval); //originally was me.pollInterval * 1.5
                    },
                    overwrite: function (el) { // Override 
                        //(calls this.apply() to convert ids to templates for XTemplate to put in the DOM
                        var dom,
                                firstChild,
                                ret;

                        /* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
                         * will fail as their DOM nodes will have been torn apart. We can't defend against external updates to the DOM
                         * but we can guard against the case where all updates come through this template.
                         */
                        if (Ext.isIE) {
                            dom = Ext.getDom(el);
                            while (dom.firstChild) {
                                dom.removeChild(dom.firstChild);
                            }
                        }
                        ret = this.callParent(arguments);
                        this.injectComponents(); // There's no guarantee this will succeed so we still need polling as well
                        return ret;
                    },
                    renderComponent: function (cmp, placeholderEl) {
                        if (cmp && placeholderEl) {
                            var parent = placeholderEl.parent();

                            // Move a component that has been rendered previously
                            if (cmp.rendered) cmp.getEl().replace(placeholderEl);
                            else cmp.render(parent, placeholderEl);

                            // Some components (mostly form fields) reserve space but fail to show up without a repaint in IE6
                            if (Ext.isIE6)    parent.repaint();
                            return true;
                        }
                        else return false;
                    },
                    reset: function () {
                        var me = this;
                        me.ids = [];// The ids of injected components that haven't yet been rendered
                        if (me.pollId) {
                            clearTimeout(me.pollId);
                            me.pollId = null;
                        }
                    }
                }, function (ctemplate) {
                    var apply = function () {
                        var me = this,
                                args = Ext.Array.slice(arguments);
                        args[0] = me.copyValues(args[0]);
                        me.doPolling(POLL_INTERVAL_MS); // As we're returning an HTML string/array we can't actually complete the injection here
                        return me.callParent(args);
                    };
                    // The main override is different depending on whether we're using ExtJS 4.0 or 4.1+
                    if (ctemplate.prototype.applyOut) ctemplate.override({applyOut: apply});// 4.1+
                    else {
                        ctemplate.override({applyTemplate: apply}); // 4.0
                        ctemplate.createAlias('apply', 'applyTemplate');
                    }
                });

                /*!
                 * Component Column
                 * Version 1.1
                 * Copyright(c) 2011-2013 Skirtle's Den
                 * License: http://skirtlesden.com/ux/component-column
                 */
                Ext.define('Skirtle.grid.column.Component', {
                            alias: 'widget.componentcolumn',
                            extend: 'Ext.grid.column.Column',
                            requires: ['Skirtle.CTemplate'],

                            autoWidthComponents: true, // Whether or not to automatically resize the components when the column resizes		
                            componentGC: true, // Whether or not to destroy components when they are removed from the DOM
                            hasCustomRenderer: true, // Override the superclass - this must always be true or odd things happen, especially in IE
                            lastFrameWidth: 12, // The estimated size of the cell frame. This is updated once there is a cell where it can be measured

                            /* Defer durations for updating the component width when a column resizes. Required when a component has an animated
                             * resize that causes the scrollbar to appear/disappear. Otherwise the animated component can end up the wrong size.
                             *
                             * For ExtJS 4.0 both delays are required. For 4.1 just having the 10ms delay seems to be sufficient.
                             */
                            widthUpdateDelay: [10, 400],

                            constructor: function (cfg) {
                                var me = this;

                                me.callParent(arguments);

                                // Array of component ids for both component queries and GC
                                me.compIds = [];

                                // We need a dataIndex, even if it doesn't correspond to a real field
                                me.dataIndex = me.dataIndex || Ext.id(null, 'cc-dataIndex-');
                                me.tpl = me.createTemplate(me.tpl);
                                me.renderer = me.createRenderer(me.renderer);
                                me.registerColumnListeners();
                            },
                            addRefOwner: function (child) {
                                var me = this,
                                        fn = me.refOwnerFn || (me.refOwnerFn = function () {
                                                    return me;
                                                });
                                if (me.extVersion < 40200) child.getBubbleTarget = fn; // Component queries for ancestors use getBubbleTarget in 4.1 ...
                                else child.getRefOwner = fn; // ... and getRefOwner in 4.2+
                            },
                            applyTemplate: function (data, value) {
                                if (Ext.isDefined(value)) data[this.dataIndex] = value;
                                return this.tpl.apply(data);
                            },
                            beforeViewRefresh: function () {
                                /* In IE setting the innerHTML will destroy the nodes for the previous content. If we try to reuse components it
                                 * will fail as their DOM nodes will have been torn apart. To defend against this we must remove the components
                                 * from the DOM just before the grid view is refreshed.
                                 */
                                if (Ext.isIE) {
                                    var ids = this.compIds,
                                            index = 0,
                                            len = ids.length,
                                            item,
                                            el,
                                            parentEl;

                                    for (; index < len; index++) {
                                        if ((item = Ext.getCmp(ids[index])) && (el = item.getEl()) && (el = el.dom) && (parentEl = el.parentNode)) {
                                            parentEl.removeChild(el);
                                        }
                                    }
                                }
                            },
                            calculateFrameWidth: function (component) {
                                var el = component.getEl(),
                                        parentDiv = el && el.parent(),
                                // By default the TD has no padding but it is quite common to add some via a tdCls
                                        parentTd = parentDiv && parentDiv.parent();

                                if (parentTd) {
                                    // Cache the frame width so that it can be used as a 'best guess' in cases where we don't have the elements
                                    this.lastFrameWidth = parentDiv.getFrameWidth('lr') + parentTd.getFrameWidth('lr');
                                    return this.lastFrameWidth;
                                }
                            },
                            createRenderer: function (renderer) {
                                var me = this;
                                return function (value, p, record) {
                                    var data = Ext.apply({}, record.data, record.getAssociatedData());
                                    if (renderer) value = renderer.apply(this, arguments); // Scope must be this, not me
                                    // Process the value even with no renderer defined as the record may contain a component config
                                    value = me.processValue(value);
                                    return me.applyTemplate(data, value);
                                };
                            },
                            createTemplate: function (tpl) {
                                return tpl && tpl.isTemplate ? tpl : Ext.create('Skirtle.CTemplate', tpl || ['{', this.dataIndex, '}']);
                            },
                            destroyChild: function (child) {
                                child.destroy();
                            },
                            getRefItems: function (deep) {
                                var items = this.callParent([deep]),
                                        ids = this.compIds,
                                        index = 0,
                                        len = ids.length,
                                        item;

                                for (; index < len; index++) {
                                    item = Ext.getCmp(ids[index]);
                                    if (item) {
                                        items.push(item);
                                        if (deep && item.getRefItems) items.push.apply(items, item.getRefItems(true));
                                    }
                                }
                                return items;
                            },
                            onChildAfterRender: function (child) {
                                this.resizeChild(child);
                            },
                            onChildBoxReady: function (child) {
                                // Pass false to avoid triggering deferred resize, the afterrender listener will already cover those cases
                                this.resizeChild(child, false);
                            },
                            onChildDestroy: function (child) {
                                Ext.Array.remove(this.compIds, child.getId());
                            },
                            onChildResize: function () {
                                this.redoScrollbars();
                            },
                            onColumnResize: function (column) {
                                column.resizeAll();
                            },
                            onColumnShow: function (column) {
                                column.resizeAll();
                            },
                            onColumnVisibilityChange: function (column) {
                                // This is called in IE 6/7 as the components can still be seen even when a column is hidden
                                var items = column.getRefItems(),
                                        index = 0,
                                        length = items.length,
                                        visible = !column.isHidden();

                                // In practice this probably won't help but it shouldn't hurt either
                                if (Ext.suspendLayouts) Ext.suspendLayouts();

                                for (; index < length; ++index) {
                                    items[index].setVisible(visible);
                                }
                                if (Ext.resumeLayouts) Ext.resumeLayouts(true);
                            },
                            onDestroy: function () {
                                Ext.destroy(this.getRefItems());

                                this.callParent();
                            },
                            onRender: function () { // Override
                                this.registerViewListeners();
                                this.callParent(arguments);
                            },
                            onViewChange: function () {
                                // View has changed, may be a full refresh or just a single row
                                var me = this,
                                        tpl = me.tpl;

                                // Batch the resizing of child components until after they've all been injected
                                me.suspendResizing();

                                if (tpl.isCTemplate) {
                                    // No need to wait for the polling, the sooner we inject the less painful it is
                                    tpl.injectComponents();
                                    // If the template picked up other components in the data we can just ignore them, they're not for us
                                    tpl.reset();
                                }
                                // A view change could mean scrollbar problems. Note this won't actually do anything till we call resumeResizing
                                me.redoScrollbars();
                                me.resumeResizing();
                                me.performGC();
                            },
                            performGC: function () {
                                // Component GC, try to stop components leaking
                                var compIds = this.compIds,
                                        index = compIds.length - 1,
                                        comp,
                                        el;

                                for (; index >= 0; --index) {
                                    // Could just assume that the component id is the el id but that seems risky
                                    comp = Ext.getCmp(compIds[index]);
                                    el = comp && comp.getEl();

                                    if (!el || (this.componentGC && (!el.dom || Ext.getDom(Ext.id(el)) !== el.dom))) {
                                        // The component is no longer in the DOM
                                        if (comp && !comp.isDestroyed) comp.destroy();
                                    }
                                }
                            },
                            processValue: function (value) {
                                var me = this,
                                        compIds = me.compIds,
                                        id, initialWidth, dom, parent;

                                if (Ext.isObject(value) && !value.isComponent && value.xtype) {
                                    // Do not default to a panel, not only would it be an odd default but it makes future enhancements trickier
                                    value = Ext.widget(value.xtype, value);
                                }

                                if (value && value.isComponent) {
                                    id = value.getId();
                                    // When the view is refreshed the renderer could return a component that's already in the list
                                    if (!Ext.Array.contains(compIds, id)) compIds.push(id);
                                    me.addRefOwner(value);
                                    me.registerListeners(value);
                                    if (value.rendered) {
                                        /* This is only necessary in IE because it is just another manifestation of the innerHTML problems.
                                         * The problem occurs when a record value is changed and the components in that same row are being
                                         * reused. The view doesn't go through a full refresh, instead it performs a quick update on just the
                                         * one row. Unfortunately this nukes the existing components so we need to remove them first.
                                         */
                                        if (Ext.isIE) {
                                            // TODO: Should this be promoted to CTemplate?
                                            dom = value.el.dom;
                                            parent = dom.parentNode;

                                            if (parent) {
                                                if (me.extVersion === 40101) {
                                                    // Workaround for the bugs in Element.syncContent - p tag matches CTemplate.cTpl
                                                    Ext.core.DomHelper.insertBefore(dom, {tag: 'p'});
                                                }
                                                // TODO: Removing the element like this could fall foul of Element GC
                                                parent.removeChild(dom);
                                            }
                                        }
                                    }
                                    else if (me.autoWidthComponents) {
                                        /* Set the width to a 'best guess' before the component is rendered to ensure that the component's
                                         * layout is using a configured width and not natural width. This avoids problems with 4.1.1 where
                                         * subsequent calls to setWidth are ignored because it believes the width is already correct but only
                                         * the outermost element is actually sized correctly. We could use an arbitrary width but instead we
                                         * make a reasonable guess at what the actual width will be to try to avoid extra resizing.
                                         */
                                        initialWidth = me.getWidth() - me.lastFrameWidth;

                                        // Impose a minimum width of 4, we really don't want negatives values or NaN slipping through
                                        initialWidth = initialWidth > 4 ? initialWidth : 4;

                                        value.setWidth(initialWidth);
                                    }
                                    // Part of the same IE 6/7 hack as onColumnVisibilityChange
                                    if ((Ext.isIE6 || Ext.isIE7) && me.isHidden()) value.hide();
                                }

                                return value;
                            },
                            redoScrollbars: function () {
                                var me = this,
                                        grid = me.up('tablepanel');

                                if (grid) {
                                    // The presence of a resizeQueue signifies that we are currently suspended
                                    if (me.resizeQueue) {
                                        me.redoScrollbarsRequired = true;
                                        return;
                                    }

                                    // After components are injected the need for a grid scrollbar may need redetermining
                                    if (me.extVersion < 40100) { // 4.0	
                                        grid.invalidateScroller();
                                        grid.determineScrollbars();
                                    }
                                    else grid.doLayout(); // 4.1+
                                }
                            },
                            registerColumnListeners: function () {
                                var me = this;

                                if (me.autoWidthComponents) {
                                    // Need to resize children when the column resizes
                                    me.on('resize', me.onColumnResize);
                                    // Need to resize children when the column is shown as they can't be resized correctly while it is hidden
                                    me.on('show', me.onColumnShow);
                                }
                                if (Ext.isIE6 || Ext.isIE7) {
                                    me.on({
                                        hide: me.onColumnVisibilityChange,
                                        show: me.onColumnVisibilityChange
                                    });
                                }
                            },
                            registerListeners: function (component) {
                                var me = this;

                                // Remove the component from the child list when it is destroyed
                                component.on('destroy', me.onChildDestroy, me);
                                if (me.autoWidthComponents) {
                                    // Need to resize children after render as some components (e.g. comboboxes) get it wrong otherwise
                                    component.on('afterrender', me.onChildAfterRender, me, {single: true});

                                    // With 4.1 boxready gives more reliable results than afterrender as it occurs after the initial sizing
                                    if (me.extVersion >= 40100) component.on('boxready', me.onChildBoxReady, me, {single: true});
                                }

                                // Need to redo scrollbars when a child resizes
                                component.on('resize', me.onChildResize, me);
                            },
                            registerViewListeners: function () {
                                var me = this,
                                        view = me.up('tablepanel').getView();
                                me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
                                me.mon(view, 'refresh', me.onViewChange, me);
                                me.mon(view, 'itemupdate', me.onViewChange, me);
                                me.mon(view, 'itemadd', me.onViewChange, me);
                                me.mon(view, 'itemremove', me.onViewChange, me);
                            },
                            resizeAll: function () {
                                var me = this;
                                me.suspendResizing();
                                me.resizeQueue = me.getRefItems();
                                me.resumeResizing();
                            },
                            resizeChild: function (component, defer) {
                                var me = this,
                                        frameWidth,
                                        newWidth,
                                        oldWidth,
                                        resizeQueue;

                                if (me.resizingSuspended) {
                                    resizeQueue = me.resizeQueue;
                                    if (!Ext.Array.contains(resizeQueue, component)) resizeQueue.push(component);
                                    return;
                                }
                                frameWidth = me.calculateFrameWidth(component);

                                // TODO: Should we destroy the component here if it doesn't have a parent element? Already picked up anyway?
                                if (Ext.isNumber(frameWidth)) {
                                    newWidth = me.getWidth() - frameWidth;
                                    oldWidth = component.getWidth();

                                    // Returns true if a resize actually happened
                                    if (me.setChildWidth(component, newWidth, oldWidth)) {
                                        // Avoid an infinite resizing loop, deferring will only happen once
                                        if (defer !== false) {
                                            // Do the sizing again after a delay. This is because child panel collapse animations undo our sizing
                                            Ext.each(me.widthUpdateDelay, function (delay) {
                                                Ext.defer(me.resizeChild, delay, me, [component, false]);
                                            });
                                        }
                                    }
                                }
                            },
                            resumeResizing: function () {
                                var me = this,
                                        index = 0,
                                        resizeQueue = me.resizeQueue,
                                        len = resizeQueue.length;

                                if (!--me.resizingSuspended) {
                                    for (; index < len; ++index) {
                                        me.resizeChild(resizeQueue[index]);
                                    }
                                    me.resizeQueue = null;
                                    if (me.redoScrollbarsRequired) me.redoScrollbars();
                                }
                            },
                            setChildWidth: function (component, newWidth, oldWidth) {
                                if (oldWidth === newWidth) return false;
                                component.setWidth(newWidth);
                                return true;
                            },
                            suspendResizing: function () {
                                var me = this;
                                me.resizingSuspended = (me.resizingSuspended || 0) + 1;
                                if (!me.resizeQueue) me.resizeQueue = [];
                            }
                        },
                        function (cls) {
                            var proto = cls.prototype,
                                    version = Ext.getVersion();
                            proto.extVersion = (version.getMajor() * 100 + version.getMinor()) * 100 + version.getPatch(); // ExtJS version detection
                            // 4.1.1 initially reported its version as 4.1.0
                            if (Ext.Element.prototype.syncContent && version.toString() === '4.1.0') proto.extVersion = 40101;
                        });
            }());

            /**
             SUMMARY:
             This combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
             (although there is some arrow key scrolling bug)
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.ComboBox', {
                    extend: 'Ext.form.field.ComboBox',
                    alias: ['widget.intelcombo', 'widget.intelcombobox'],

                    constructor: function (options) {
                        options = options || {};
                        options = Ext.merge({
                            enableKeyEvents: true,
                            queryMode: 'local',
                            ignoreNoChange: true,
                            allowBlank: true,
                            listeners: {
                                change: function (a, b) {
                                    if (!b || (b.keyCode >= 37 && b.keyCode <= 40)) return; //arrow keys
                                    var combo = this;
                                    combo.store.clearFilter();
                                    combo.store.filterBy(function (item) {
                                        var escapedValue = combo.getRawValue().replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
                                        return item.data[combo.displayField].match(new RegExp(escapedValue, 'i')) !== null;
                                    });
                                },
                                focus: function (combo) {
                                    combo.store.clearFilter();
                                    combo.setValue('');
                                    combo.expand();
                                }
                            }
                        }, options);
                        this.callParent([options]);
                    }
                });
            }());
            /**
             SUMMARY:
             This combo has some built in defaults for static-comboboxes (which means you dont type into it, you just select from it)
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.FixedComboBox', {
                    extend: 'Ext.form.field.ComboBox',
                    alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],

                    editable: false,
                    allowBlank: true,
                    queryMode: 'local',
                    matchFieldWidth: false,
                    listeners: {
                        change: function (combo, newval, oldval) {
                            if (newval.length === 0) combo.setValue(oldval || '');
                        },
                        focus: function (combo) {
                            if (combo.store.findExact(combo.valueField, combo.getValue()) === -1) combo.setValue('');
                            combo.expand();
                        }
                    }
                });
            }());
            /**
             SUMMARY:
             This component is an easy release picker based off Intel.lib.component.FixedComboBox. You supply the
             Release Records to it on construction.

             YOU MUST PASS IT 2 THINGS IN THE CONFIG
             1: releases (array of release records)
             2: currentRelease (what to show as initial value
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.ReleasePicker', {
                    extend: 'Intel.lib.component.FixedComboBox',
                    alias: ['widget.intelreleasepicker'],

                    constructor: function (options) {
                        if (!options.releases || !options.currentRelease) return;

                        options.displayField = 'Name';
                        options.value = options.currentRelease.data.Name;
                        options.store = Ext.create('Ext.data.Store', {
                            fields: ['Name'],
                            data: _.map(options.releases, function (r) {
                                return {Name: r.data.Name};
                            })
                        });

                        options.fieldLabel = options.fieldLabel || 'Release:';
                        options.editable = options.editable || false;
                        options.width = options.width || 240;
                        options.labelWidth = options.labelWidth || 50;

                        this.callParent([options]); //now that we have the extra stuff added
                    }
                });
            }());

            /**
             SUMMARY:
             This override improves performance for sessionStorage proxy mostly by removing redundant page refreshes.

             The regular proxy calls record.commit() and later on, datarefresh event is called. since these both cause a rerender,
             we make the record edits SILENT, so only the datarefresh actually re-render the page
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.SessionStorage', {
                    extend: 'Ext.data.proxy.SessionStorage',
                    alias: ['proxy.intelsessionstorage'],
                    constructor: function (cfg) {
                        this.callParent(arguments);
                    },

                    create: function (operation, callback, scope) {
                        var me = this,
                                records = operation.records,
                                length = records.length,
                                ids = me.getIds(),
                                id, record, i;

                        operation.setStarted();
                        if (me.isHierarchical === undefined) {


                            me.isHierarchical = !!records[0].isNode;
                            if (me.isHierarchical) {
                                me.getStorageObject().setItem(me.getTreeKey(), true);
                            }
                        }
                        for (i = 0; i < length; i++) {
                            record = records[i];

                            if (record.phantom) {
                                record.phantom = false;
                                id = me.getNextId();
                            } else {
                                id = record.getId();
                            }

                            record.beginEdit();
                            me.setRecord(record, id);
                            record.endEdit(true); //SILENT!!!
                            record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

                            ids.push(id);
                        }
                        me.setIds(ids);

                        operation.setCompleted();
                        operation.setSuccessful();

                        if (typeof callback == 'function') {
                            callback.call(scope || me, operation);
                        }
                    },

                    update: function (operation, callback, scope) {
                        var records = operation.records,
                                length = records.length,
                                ids = this.getIds(),
                                record, id, i;

                        operation.setStarted();
                        for (i = 0; i < length; i++) {
                            record = records[i];
                            this.setRecord(record);

                            record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

                            id = record.getId();
                            if (id !== undefined && Ext.Array.indexOf(ids, id) == -1) ids.push(id);
                        }
                        this.setIds(ids);

                        operation.setCompleted();
                        operation.setSuccessful();
                        if (typeof callback == 'function') callback.call(scope || this, operation);
                    }
                });
            }());
            /**
             SUMMARY:
             performance optimized Ext.data.Store. Improvements found using Chrome Profiling.
             Improvements include removing redundant call to me.sync() which triggers another grid refresh
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.Store', {
                    extend: 'Ext.data.Store',
                    alias: ['store.intelstore'],

                    afterEdit: function (record, modifiedFieldNames) {
                        var me = this, i, shouldSync;
                        if (me.autoSync && !me.autoSyncSuspended) {
                            for (i = modifiedFieldNames.length; i--;) {
                                if (record.fields.get(modifiedFieldNames[i]).persist) {
                                    me.sync();  //all rendering changes made here
                                    break;
                                }
                            }
                        }
                        me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
                        //me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames); //redundant with me.sync()
                    }
                });
            }());
            /**
             SUMMARY:
             Overrides Ext.view.Table to make the scrollbar not jump on grid refreshes. Also it has some
             permormance optimizations included in it (which should be commented)
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.TableView', {
                    extend: 'Ext.view.Table',
                    alias: ['widget.inteltableview'],

                    refresh: function () {
                        var me = this,
                                targetEl,
                                targetParent,
                                oldDisplay,
                                nextSibling,
                                dom,
                                records,
                                el = me.getEl(), //edit
                                scroll = el && el.getScrollTop();//edit

                        if (!me.rendered || me.isDestroyed) return;

                        if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
                            targetEl = me.getTargetEl();
                            records = me.getViewRange();
                            dom = targetEl.dom;
                            if (!me.preserveScrollOnRefresh) {
                                targetParent = dom.parentNode;
                                oldDisplay = dom.style.display;
                                dom.style.display = 'none';
                                nextSibling = dom.nextSibling;
                                targetParent.removeChild(dom);
                            }
                            if (me.refreshCounter) me.clearViewEl();
                            else {
                                me.fixedNodes = targetEl.dom.childNodes.length;
                                me.refreshCounter = 1;
                            }
                            me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));

                            if (records.length < 1) {
                                if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
                                    Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
                                }
                                me.all.clear();
                            } else {
                                me.collectNodes(targetEl.dom);
                                me.updateIndexes(0);
                            }
                            if (me.hasFirstRefresh) {
                                if (me.refreshSelmodelOnRefresh !== false) {
                                    me.selModel.refresh();
                                } else {
                                    me.selModel.pruneIf();
                                }
                            }
                            me.hasFirstRefresh = true;

                            if (!me.preserveScrollOnRefresh) {
                                targetParent.insertBefore(dom, nextSibling);
                                dom.style.display = oldDisplay;
                            }

                            Ext.suspendLayouts();
                            this.refreshSize();
                            me.fireEvent('refresh', me);
                            Ext.resumeLayouts(true);

                            if (!me.viewReady) {
                                me.viewReady = true;
                                me.fireEvent('viewready', me);
                            }
                        }

                        if (scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
                    },

                    onRemove: function (ds, records, indexes) {
                        var me = this,
                                fireItemRemove = me.hasListeners.itemremove,
                                i,
                                record,
                                index,
                                el = me.getEl(),//edit
                                scroll = el && el.getScrollTop();//edit

                        if (me.all.getCount()) {
                            if (me.dataSource.getCount() === 0) {
                                if (fireItemRemove) {
                                    for (i = indexes.length - 1; i >= 0; --i) {
                                        me.fireEvent('itemremove', records[i], indexes[i]);
                                    }
                                }
                                //me.refresh();
                            } else {
                                for (i = indexes.length - 1; i >= 0; --i) {
                                    record = records[i];
                                    index = indexes[i];
                                    me.doRemove(record, index);
                                    if (fireItemRemove) {
                                        me.fireEvent('itemremove', record, index);
                                    }
                                }
                                me.updateIndexes(indexes[0]);
                            }
                            this.refreshSize();
                            if (scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
                        }
                    },

                    onUpdate: function (ds, record) {
                        var me = this,
                                index,
                                node,
                                el = me.getEl(),//edit
                                scroll = el && el.getScrollTop();//edit

                        if (me.viewReady) {
                            index = me.dataSource.indexOf(record);
                            if (index > -1) {
                                node = me.bufferRender([record], index)[0];
                                if (me.getNode(record)) {
                                    me.all.replaceElement(index, node, true);
                                    me.updateIndexes(index, index);
                                    me.selModel.onUpdate(record);
                                    if (me.hasListeners.itemupdate) {
                                        me.fireEvent('itemupdate', record, index, node);
                                    }
                                    return node;
                                }
                            }
                            if (scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
                        }
                    },

                    onAdd: function (store, records, index) {
                        var me = this,
                                nodes,
                                el = me.getEl(),
                                scroll = el && el.getScrollTop();

                        if (me.rendered) {
                            if (me.all.getCount() === 0) {
                                me.refresh();
                                nodes = me.all.slice();
                            } else {
                                nodes = me.doAdd(records, index);
                                if (me.refreshSelmodelOnRefresh !== false) {
                                    me.selModel.refresh();
                                }
                                me.updateIndexes(index);
                                //me.refreshSize(); //already being refreshed by store.sync()
                            }

                            if (me.hasListeners.itemadd) {
                                me.fireEvent('itemadd', records, index, nodes);
                            }
                            if (scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
                        }
                    },

                    scrollRowIntoView: function (row) {
                        if (row === 0) {
                            this.getEl().setScrollTop(0);
                            return;
                        }
                        row = this.getNode(row, true);
                        if (row) {
                            Ext.fly(row).scrollIntoView(this.el, false);
                        }
                    }
                });
            }());
            /**
             SUMMARY:
             This override makes the ComponentColumn component much more performant. Edits found using Chrome profiling
             */
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.lib.component.ComponentColumn', {
                    extend: 'Skirtle.grid.column.Component',
                    alias: 'widget.intelcomponentcolumn',

                    autoWidthComponents: false,
                    componentGC: true,
                    hasCustomRenderer: true,
                    lastFrameWidth: 12,
                    constructor: function (cfg) {
                        var me = this;
                        me.callParent(arguments);
                    },
                    registerViewListeners: function () {
                        var me = this,
                                view = me.up('tablepanel').getView();

                        me.mon(view, 'beforerefresh', me.beforeViewRefresh, me);
                        me.mon(view, 'refresh', me.onViewChange, me);
                        //me.mon(view, 'itemupdate', me.onViewChange, me); //why are these necessary...
                        //me.mon(view, 'itemadd', me.onViewChange, me);
                        //me.mon(view, 'itemremove', me.onViewChange, me);
                    },
                    onViewChange: function () {
                        var me = this, tpl = me.tpl;
                        me.suspendResizing();
                        if (tpl.isCTemplate) {
                            tpl.injectComponents();
                            tpl.reset();
                        }
                        //me.redoScrollbars();
                        me.resumeResizing();
                        me.performGC();
                    },
                    resumeResizing: function () {
                        var me = this,
                                index = 0,
                                resizeQueue = me.resizeQueue,
                                len = resizeQueue.length;
                        if (!--me.resizingSuspended) {
                            for (; index < len; ++index) me.resizeChild(resizeQueue[index]);
                            me.resizeQueue = null;
                            /* if (me.redoScrollbarsRequired) {
                             me.redoScrollbars();
                             } */
                        }
                    },
                    onChildResize: function () {
                        //this.redoScrollbars();
                    }
                });
            }());
            (function () {
                var Ext = window.Ext4 || window.Ext;

                Ext.define('Intel.MTS', {
                    extend: 'Intel.lib.IntelRallyTrainsGridApp',
                    mixins: [
                        'Intel.lib.mixin.WindowListener',
                        'Intel.lib.mixin.PrettyAlert',
                        'Intel.lib.mixin.IframeResize',
                        'Intel.lib.mixin.ParallelLoader',
                        'Intel.lib.mixin.UserAppsPreference',
                        'Intel.lib.mixin.HorizontalTeamTypes'
                    ],

                    /**___________________________________ DATA STORE METHODS ___________________________________*/

                    /*
                     - Get all user stories and classify by train and scrum team
                     - from the user stories, get the distinct features
                     - From all features (in release)  get the Train to which they belong to
                     - Given a train and scrum team, show the number of features (from user stories) that belong to that train
                     */

                    loadReportData: function () {
                        var me = this;
                        return Q.all([
                            me._loadFeatures(),
                            me._loadUserStories()
                        ]);
                    },
                    setScrumDataValue: function (container, scrumGroupName, projectName) {
                        // get stories for train/scrum
                        // if feature of story belongs to this train then add 1
                        var me = this;
                        container.featureCount = 0;
                        container.features = [];
                        var featuresInProject = me.projectFeatureMap[scrumGroupName][projectName];
                        _.each(featuresInProject, function (featureID) {
                            var f = me.trainFeatureMap[featureID];
                            if (f && f.train == scrumGroupName) {
                                container.features.push(f.featureID + ": " + f.feature);
                                container.featureCount++;
                            }
                        });
                    },
                    getScrumTotalDataValue: function (scrumData) {
                        return scrumData === null ? {total: 0} : {total: scrumData.featureCount};
                    },
                    addScrumTotalDataValue: function (current, scrumData) {
                        current.total += scrumData.featureCount;
                    },
                    getScrumDataValueFromScrumTotal: function (trainTotal) {
                        return {
                            featureCount: trainTotal.total
                        };
                    },
                    scrumDataCellRenderer: function (scrumData) {
                        var exists = (scrumData !== null && scrumData.featureCount > 0);
                        var tooltip_text = exists ? scrumData.features.join("\n") : "";

                        return {
                            xtype: 'container',
                            items: {
                                xtype: 'component',
                                autoEl: {
                                    tag: 'a',
                                    html: exists ? '<span title="' + tooltip_text + '">' + scrumData.featureCount + '</span>' : '-'
                                }
                            }
                        };
                    },
                    horizontalTotalCellRenderer: function (horizontalData, meta) {
                        var hasData = horizontalData.total > 0;
                        return hasData ? '<span>' + horizontalData.total + '</span>' : '-';
                    },


                    _loadFeatures: function () {
                        var me = this,
                                map = {},
                                releaseFilter = Ext.create('Rally.data.wsapi.Filter', {
                                    property: 'Release.Name',
                                    value: me.ReleaseRecord.data.Name
                                });

                        return Q.all(_.map(me.ScrumGroupConfig, function (train) {
                            var trainName = train.ScrumGroupName,
                                    trainObjectID = train.ScrumGroupRootProjectOID,
                                    config = {
                                        model: 'PortfolioItem/Feature',
                                        compact: false,
                                        filters: releaseFilter,
                                        fetch: ['ObjectID', 'Name', 'Project'],
                                        context: {
                                            workspace: null,
                                            project: '/project/' + trainObjectID,
                                            projectScopeDown: true,
                                            projectScopeUp: false
                                        }
                                    };
                            return me.parallelLoadWsapiStore(config).then(function (store) {
                                _.each(store.getRange(), function (featureRecord) {
                                    map[featureRecord.data.ObjectID] = {
                                        feature: featureRecord.data.Name,
                                        featureID: featureRecord.data.ObjectID,
                                        train: trainName
                                    };
                                });
                                store.destroyStore();
                            });
                        }))
                                .then(function () {
                                    me.trainFeatureMap = map;
                                });
                    },

                    _loadUserStories: function () {
                        var me = this,
                                map = {};

                        return Q.all(_.map(me.ScrumGroupConfig, function (train) {
                            var trainName = train.ScrumGroupName,
                                    trainObjectID = train.ScrumGroupRootProjectOID,
                                    config = {
                                        model: 'HierarchicalRequirement',
                                        compact: false,
                                        filters: me._getUserStoriesFilter(),
                                        fetch: ['ObjectID', 'Name', 'Feature', 'Project'],
                                        context: {
                                            workspace: null,
                                            project: '/project/' + trainObjectID,
                                            projectScopeDown: true,
                                            projectScopeUp: false
                                        }
                                    };

                            map[trainName] = {};
                            return me.parallelLoadWsapiStore(config)
                                    .then(function (store) {
                                        _.each(store.getRange(), function (storyRecord) {
                                            var projectName = storyRecord.data.Project.Name,
                                                    projectOID = storyRecord.data.Project.ObjectID;
                                            if (!map[trainName][projectName]) {
                                                map[trainName][projectName] = [];
                                            }
                                            if (storyRecord.data.Feature) {
                                                // only track unique occurrences of the feature per train per project
                                                if (_.indexOf(map[trainName][projectName], storyRecord.data.Feature.ObjectID) === -1) {
                                                    map[trainName][projectName].push(storyRecord.data.Feature.ObjectID);
                                                }
                                            }
                                        });
                                        store.destroyStore();
                                    });
                        }))
                                .then(function () {
                                    me.projectFeatureMap = map;
                                });
                    },

                    _getUserStoriesFilter: function () {
                        // get all leaf stories in this release for the leaf projects under the train
                        var me = this,
                                leafFilter = Ext.create('Rally.data.wsapi.Filter', {
                                    property: 'DirectChildrenCount',
                                    value: 0
                                }),
                                releaseFilter = Ext.create('Rally.data.wsapi.Filter', {
                                    property: 'Release.Name',
                                    value: me.ReleaseRecord.data.Name
                                }),
                                projectFilter = Ext.create('Rally.data.wsapi.Filter', {
                                    property: 'Project.Children.Name',
                                    value: null
                                });
                        return releaseFilter.and(leafFilter).and(projectFilter);
                    }

                });
            }());

            Rally.launchApp('Intel.MTS', {
                name: "MTS",
                parentRepos: ""
            });

        });
    </script>


    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
        .x4-grid-cell.intel-editor-cell *,
        .intel-editor-cell {
            cursor: pointer !important;
        }

        .fa.fa-md {
            font-size: 1.05rem;
            line-height: .75em;
            vertical-align: -15%;
        }

        /************************************************ RALLY BUTTON STYLE *****************************************/
        .intel-button {
            border-radius: 2px;
            background-color: #00a9e0;
            border-color: #00a9e0;
        }

        .intel-button:hover {
            background-color: #29beff;
            border-color: #29beff;
        }

        .intel-button * {
            font-size: 12px;
        }

    </style>

    <style type="text/css">
        /*********	*************************************** NAVBAR/CONTAINERS *****************************************/
        #navbar {
            padding: 0 10px 0 10px;
        }

        #releasePicker {
            margin: 4px 0 0 0;
        }

        /************************************************ GRID STUFF *****************************************/
        .x-grid-cell-inner {
            padding: 0 !important;
        }

        .x-grid-cell .x-box-inner,
        .x-grid-cell .x-box-inner .x-box-target,
        .team-type-cell,
        .stdci-cell,
        .bad-stdci-cell,
        .good-stdci-cell {
            width: 100% !important;
        }

        .team-type-cell,
        .stdci-cell,
        .bad-stdci-cell,
        .good-stdci-cell,
        .stdci-cell *,
        .bad-stdci-cell *,
        .good-stdci-cell * {
            text-align: center !important;
        }

        .x-grid-cell.bad-stdci-cell,
        .bad-stdci-cell {
            flex: 1;
            /* background-color:rgba(255, 0, 0, 0.50) !important;  */
            background-color: pink !important;
        }

        .x-grid-cell.good-stdci-cell,
        .good-stdci-cell {
            flex: 1;
            background-color: rgba(0, 255, 0, 0.5) !important;
        }

        .stdci-cell-container,
        .horizontal-name-cell {
            border-right: 1px solid lightgrey;
            width: 100%;
            height: 100%;
        }

        .stdci-cell-container .x-container,
        .horizontal-name-cell > .x-grid-cell-inner {
            display: flex;
            text-align: center;
            justify-content: center;
            align-items: stretch;
        }

        .train-header-cls {
            text-align: center;
        }

        .team-type-cell {
            border-right: 1px solid black;
        }

        .x-grid-table tbody > tr:last-child > td {
            border-top: 1px solid black;
        }

        .x-grid-table tbody > tr:not(:last-child):not(:first-child) > td {
            border-top: 1px solid gray;
        }

        .x-grid-table tbody > tr > td:last-child {
            border-left: 1px solid black;
        }

        .grid-container > span > div {
            display: flex !important;
            justify-content: center;
        }

        a:visited {
            color: #337ec6;
        }

        a:link {
            color: #000000;
        }

        /* 
.stdci-cell-container  .x-box-inner {
	height: 100% !important;
}

.stdci-cell-container .x-box-target {
	display: flex;
	justify-content: center;
	align-items: stretch;
	height: 100% !important;
} */

    </style>
</head>
<body>
</body>
</html>
