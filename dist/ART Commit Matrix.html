<!DOCTYPE html>
<html>
<head>
    <title>ART Commit Matrix</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.4.1/q.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/lodash.js/3.10.1/lodash.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** 
	SUMMARY:
		This extends Rally.app.app. All Intel Apps should extend from this if they want to use the functionality it provides,
		as well as numerous other lib/* files that require you to extend from this.
		
		If you extend from Intel.lib.IntelRallyApp, you have to call me.configureIntelRallyApp() before anything else in your launch() 
		function. After you call me.configureIntelRallyApp, you will be able to access a lot of things, such as:
			- me.ScheduleStates: possible UserStory schedule States
			- me.PortfolioItemTypes: Ordered Array of PortfolioItem Types. e.g.: ['Feature', 'Milestone', 'Product']
			- me.ScrumGroupConfig: the scrum group portfolio location config for the workspace
			- me.HorizontalGroupingConfig: the horizontal scrum groupings by keywords
			- All the most-used Rally models, such as me.Project, me.UserStory, me.PortfolioItem, etc... 
		
	DEPENDENCIES:
		Q promise library
		
	ISSUES:
		sdk 2.0 does not work with the project function due to a bug in the sdk. use sdk 2.0rc3
	*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		ScrumGroupConfigPrefName = 'intel-portfolio-locations-config', //preference to store portfolio locations config for workspace
		HorizontalGroupingConfigPrefName = 'intel-horizontal-grouping-config'; //preference to store map of keywords in project names to horizontal
	
	//increase timeouts to 2 minutes since rally can be slow sometimes
	var timeout = 120000;
	Ext.override(Ext.data.proxy.Ajax, { timeout: timeout });
	Ext.override(Ext.data.proxy.JsonP, { timeout: timeout });
	
	//rally's built-in jsonpproxy does not handle timeouts
	Ext.override(Rally.sdk.data.lookback.JsonPProxy, {
		setException: function(operation, response){
			var error = operation.getError() || {};
			operation.setException(Ext.apply(error, {
				errors:(response || {}).Errors || []
			}));
		}
	});
				
	Ext.define('Intel.lib.IntelRallyApp', {
		extend: 'Rally.app.App',
		minWidth:910, //when Rally adds its own scrollbar anyways
		
		projectFields: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name', 'TeamMembers'],
		portfolioItemFields: ['Name', 'ObjectID', 'FormattedID', 'Release','c_TeamCommits', 'c_MoSCoW', 
			'c_Risks', 'Project', 'PlannedEndDate', 'Parent', 'Children', 'PortfolioItemType', 'Ordinal',
			'PercentDoneByStoryPlanEstimate'],
		userStoryFields: ['Name', 'ObjectID', 'Release', 'Project', 'PortfolioItem', 'PlannedEndDate', 'ActualEndDate',
			'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
		releaseFields: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
		
		/********************************************** APP CONFIGURATION **************************************/
		_loadScheduleStates: function(){ 
			var me=this, deferred = Q.defer();
			Rally.data.ModelFactory.getModel({
				type: 'UserStory',
				success: function(model) {
					model.getField('ScheduleState').getAllowedValueStore().load({
						callback: function(records, operation, success) {
							me.ScheduleStates = _.map(records, function(r){ return r.data.StringValue; });
							deferred.resolve();
						}
					});
				}
			});
			return deferred.promise;
		},
		_loadPortfolioItemStatesForEachType: function(){ 
			var me=this;
			me.PortfolioItemTypeStates = [];
			return Q.all(_.map(me.PortfolioItemTypes, function(portfolioType, ordinal){
				var store = Ext.create('Rally.data.wsapi.Store', {
					model: 'State',
					autoLoad:false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Name', 'Enabled', 'OrderIndex'],
					filters: [{
						property: 'TypeDef.Name',
						value: portfolioType
					},{
						property: 'Enabled',
						value: true
					}]
				});
				return me.reloadStore(store).then(function(store){
					me.PortfolioItemTypeStates[ordinal] = store.getRange();
				});
			}));
		},
		_loadPortfolioItemTypes: function(){ 
			/** loads all the portfolioitem names into sorted array [smallest ordinal --> biggest ordinal] */
			var me=this,
				deferred = Q.defer(),
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'TypeDefinition',
					autoLoad:true,
					limit:Infinity,
					disableMetaChangeEvent: true,
					fetch:['Ordinal', 'Name'],
					filters: [{
						property: 'Parent.Name',
						value: 'Portfolio Item'
					},{
						property: 'Creatable',
						value: true
					}],
					listeners:{
						load:function(portfolioTypeStore){
							me.PortfolioItemTypes = _.map(_.sortBy(_.map(portfolioTypeStore.getRange(), 
								function(item){ return {Name: item.data.Name, Ordinal: item.data.Ordinal}; }),
								function(item){ return item.Ordinal; }),
								function(item){ return item.Name; });
							deferred.resolve();
						}
					}
				});
			return deferred.promise;
		},
		_loadModels: function(){ 
			/** loads models for project, userstories, and all the portfolio items */
			var me=this, 
				promises = [],
				models = {
					User: 'User',
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					PortfolioItem: 'PortfolioItem'
				};
			_.each(me.PortfolioItemTypes, function(name){ models['PortfolioItem/' + name] = 'PortfolioItem/' + name; });
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},
		_loadScrumGroupConfig: function(){
			/** scrum-groups are groups of scrums that share the same portfolio. The group of scrums may or may not be a train */
			/** me.ScrumGroupConfig is an array of these objects: 
				{
					ScrumGroupRootProjectOID: configItem.ScrumGroupRootProjectOID || 0,
					ScrumGroupName: configItem.ScrumGroupName || '',
					ScrumGroupAndPortfolioLocationTheSame: configItem.ScrumGroupAndPortfolioLocationTheSame ? true : false,
					PortfolioProjectOID: configItem.PortfolioProjectOID || 0,
					IsTrain: configItem.IsTrain ? true : false
				}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				success: function(prefs) {
					var configString = prefs[ScrumGroupConfigPrefName], scrumGroupConfig;
					try{ scrumGroupConfig = JSON.parse(configString); }
					catch(e){ scrumGroupConfig = []; }
					me.ScrumGroupConfig = scrumGroupConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_loadHorizontalGroupingConfig: function(){
			/** HorizontalGroupingConfig is this:
			{
				enabled: boolean,
				groups: {
					<horizontal1Name>: ['keyword1', 'keyword2'],
					<horizontal2Name>: ['keyword1', 'keyword2'],
					...
				}
			}
			*/
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				success: function(prefs) {
					var configString = prefs[HorizontalGroupingConfigPrefName], horizontalGroupingConfig;
					try{ horizontalGroupingConfig = JSON.parse(configString); }
					catch(e){ horizontalGroupingConfig = {enabled:false, groups:{}}; }
					me.HorizontalGroupingConfig = horizontalGroupingConfig;
					deferred.resolve();
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveScrumGroupConfig: function(scrumGroupConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[ScrumGroupConfigPrefName] = JSON.stringify(scrumGroupConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: ScrumGroupConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveHorizontalGroupingConfig: function(horizontalGroupingConfig){
			var me=this, s = {}, deferred = Q.defer();
			s[HorizontalGroupingConfigPrefName] = JSON.stringify(horizontalGroupingConfig); 
			Rally.data.PreferenceManager.update({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: HorizontalGroupingConfigPrefName,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		},
		configureIntelRallyApp: function(){
			var me=this;
			me.BaseUrl = Rally.environment.getServer().getBaseUrl(); //is "" when in custom app iframe
			return Q.all([
				me._loadPortfolioItemTypes().then(function(){ 
					me.userStoryFields.push(me.PortfolioItemTypes[0]);  
					return Q.all([
						me._loadModels(),
						me._loadPortfolioItemStatesForEachType()
					]);
				}),
				me._loadScrumGroupConfig(),
				me._loadHorizontalGroupingConfig(),
				me._loadScheduleStates()
			]);
		},
				
		/**************************** Generic store loading with Q wrapper, returns promise *************************************/		
		reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		},
		
		/********************************************** LOADING SINGLE MODELS **************************************/	
		loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadProject');
			else if(!me.Project) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.Project.load(oid, {
					fetch: me.projectFields,
					context: { 
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadUserStory: function(oid, projectRecord){
			var me = this, deferred = Q.defer();
			if(!oid) return Q.reject('Invalid arguments: loadUserStory');
			else if(!me.UserStory) return Q.reject('IntelRallyApp is not configured!');
			else {
				me.UserStory.load(oid, {
					fetch: me.userStoryFields,
					context: {
						workspace: projectRecord ? null : me.getContext().getWorkspace()._ref,
						project: projectRecord ? projectRecord.data._ref : null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByType: function(oid, type){
			var me = this, deferred = Q.defer();
			if(!oid || !type) return Q.reject('Invalid arguments: loadPortfolioItemByType');
			else {
				type = (type.indexOf('PortfolioItem/') === 0) ? type : ('PortfolioItem/' + type);	
				me[type].load(oid, {
					fetch: me.portfolioItemFields,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		loadPortfolioItemByOrdinal: function(oid, ordinal){
			var me = this, deferred = Q.defer(),
				type = me.PortfolioItemTypes[ordinal];
			return me.loadPortfolioItemByType(oid, type);
		},	
		
		/**************************************** ScrumGroup Funcs ***************************************************/
		projectInWhichScrumGroup: function(projectRecord){ 
			/** returns scrumgroup the projectRecord is in, otherwise null. */
			if(!projectRecord) return Q();
			else {
				var me=this,
					foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
						return scrumGroupConfig.ScrumGroupRootProjectOID == projectRecord.data.ObjectID; 
					});
				if(foundScrumGroupConfig) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q();
					else {
						return me.loadProject(parent.ObjectID).then(function(parentRecord){
							return me.projectInWhichScrumGroup(parentRecord);
						});
					}
				}
			}
		},
		loadScrumGroupPortfolioProject: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) return Q.reject('Invalid arguments: loadScrumGroupPortfolioProject');
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) return Q.reject('Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum group!');
			if(foundScrumGroupConfig.ScrumGroupAndPortfolioLocationTheSame) return Q(scrumGroupRootProjectRecord);
			else return me.loadProject(foundScrumGroupConfig.PortfolioProjectOID);
		},
		getScrumGroupName: function(scrumGroupRootProjectRecord){
			if(!scrumGroupRootProjectRecord) throw 'Invalid arguments: getScrumGroupName';
			var me=this,
				foundScrumGroupConfig = _.find(me.ScrumGroupConfig, function(scrumGroupConfig){ 
					return scrumGroupConfig.ScrumGroupRootProjectOID == scrumGroupRootProjectRecord.data.ObjectID; 
				});
			if(!foundScrumGroupConfig) throw 'Project ' + scrumGroupRootProjectRecord.data.Name + ' is not a scrum-group!';
			if(foundScrumGroupConfig.ScrumGroupName) return foundScrumGroupConfig.ScrumGroupName;
			else return scrumGroupRootProjectRecord.data.Name;
		},
		loadAllScrumGroups: function(){
			var me=this,
				filter = _.reduce(me.ScrumGroupConfig, function(filter, scrumGroupConfig){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', { property:'ObjectID', value: scrumGroupConfig.ScrumGroupRootProjectOID });
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			if(!filter) return Q([]);
			else {
				var store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.projectFields,
					filters:[filter],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
				return me.reloadStore(store).then(function(store){ return store.getRange(); });
			}
		},
		getScrumGroupPortfolioObjectIDs: function(){
			return _.map(me.ScrumGroupConfig, function(item){
				return item.ScrumGroupAndPortfolioLocationTheSame ? item.ScrumGroupRootProjectOID : item.PortfolioProjectOID;
			});
		},
		getPortfolioOIDForScrumGroupRootProjectRecord: function(scrumGroupRootProjectRecord){
			var configItem = _.find(this.ScrumGroupConfig, function(item){ 
				return item.ScrumGroupRootProjectOID === scrumGroupRootProjectRecord.data.ObjectID; 
			});
			return configItem.ScrumGroupAndPortfolioLocationTheSame ? configItem.ScrumGroupRootProjectOID : configItem.PortfolioProjectOID;
		},
		
		/**************************************** UserStory Funcs ************************************************/
		_getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ 
			/** only pull look at PortfolioItem Release if US.Release == null */
			var me=this,
				lowestPortfolioItem = me.PortfolioItemTypes[0],
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.ObjectID',
					value: null
				}).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItem + '.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property: lowestPortfolioItem + '.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				)
			);
		},
		loadRandomUserStory: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: loadRandomUserStory');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: false,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{ 
						property:'Project.ObjectID', 
						value: projectRecord.data.ObjectID 
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadRandomUserStoryFromReleaseTimeframe: function(projectRecord, releaseRecord){
			if(!projectRecord || !releaseRecord) return Q.reject('Invalid arguments: loadRandomUserStoryFromReleaseTimeframe');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					disableMetaChangeEvent: true,
					fetch: me.userStoryFields,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project.ObjectID', value: projectRecord.data.ObjectID }).and(
						me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me.reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		loadUserStoryByFID: function(formattedID, projectRecord){
			if(!formattedID || !projectRecord) return Q.reject('Invalid arguments: loadUserStoryByFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					disableMetaChangeEvent: true,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		
		/**************************************** PortfolioItem Funcs ************************************************/
		loadPortfolioItemsOfType: function(portfolioProject, type){
			if(!portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfType');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me.portfolioItemFields,
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store);
		},		
		loadPortfolioItemsOfTypeInRelease: function(releaseRecord, portfolioProject, type){
			if(!releaseRecord || !portfolioProject || !type) return Q.reject('Invalid arguments: loadPortfolioItemsOfTypeInRelease');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: 'PortfolioItem/' + type,
					limit:Infinity,
					disableMetaChangeEvent: true,
					remoteSort:false,
					fetch: me.portfolioItemFields,
					filters:[{ property:'Release.Name', value:releaseRecord.data.Name}],
					context:{
						project: portfolioProject.data._ref,
						projectScopeDown: true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store);
		},
		loadPortfolioItemsOfOrdinal: function(portfolioProject, ordinal){
			if(!portfolioProject || typeof ordinal === 'undefined') return Q.reject('Invalid arguments: loadPortfolioItemsOfOrdinal');
			var me=this, type = me.PortfolioItemTypes[ordinal];
			if(type) return me.loadPortfolioItemsOfType(portfolioProject, type);
			else return Q.reject('Invalid PortfolioItem ordinal');
		},
		portfolioItemTypeToOrdinal: function(type){
			return this.PortfolioItemTypes.indexOf(type);
		},
		getPortfolioItemTypeStateByOrdinal: function(ordinal, stateName){
			return _.find(this.PortfolioItemTypeStates[ordinal], function(state){ return state.data.Name == stateName; });
		},
		getPortfolioItemTypeStateByName: function(portfolioType, stateName){
			return this.getPortfolioItemTypeStateByOrdinal(this.portfolioItemTypeToOrdinal(portfolioType), stateName);
		},
		createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap: function(portfolioItemStores){
			var portfolioItemMap = {};
			_.each(portfolioItemStores[0].getRange(), function(lowPortfolioItemRecord){ //create the portfolioItem mapping
				var ordinal = 0, 
					parentPortfolioItemRecord = lowPortfolioItemRecord,
					getParentRecord = function(child, parentList){
						return _.find(parentList, function(parent){ 
							return child.data.Parent && parent.data.ObjectID == child.data.Parent.ObjectID; 
						});
					};
				while(ordinal < (portfolioItemStores.length-1) && parentPortfolioItemRecord){
					parentPortfolioItemRecord = getParentRecord(parentPortfolioItemRecord, portfolioItemStores[ordinal+1].getRange());
					++ordinal;
				}
				if(ordinal === (portfolioItemStores.length-1) && parentPortfolioItemRecord) //has a mapping, so add it
					portfolioItemMap[lowPortfolioItemRecord.data.ObjectID] = parentPortfolioItemRecord.data.Name;
			});
			return portfolioItemMap;
		},
			
		/********************************************** Project Funcs ********************************************/
		/****************************** THESE DO NOT WORK WITH sdk 2.0. USE SDK 2.0rc3 *******************/
		_storeItemsToProjTree: function(projects){
			var me=this, projTree = {};
			for(var i=0, len=projects.length; i<len; ++i){
				var project = projects[i],
					thisRef = project.data.ObjectID, 
					parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
				if(!projTree[thisRef]) projTree[thisRef] = {};
				projTree[thisRef].ProjectRecord = project;
				if(parentRef){
					if(!projTree[parentRef]) projTree[parentRef] = {};
					projTree[parentRef][thisRef] = projTree[thisRef];
				}
			}
			return projTree;
		},
		_addProjectsWithTeamMembersToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._addProjectsWithTeamMembersToList(projTree[childProjRef], hash);
			}
		},	
		_allChildProjectToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_allLeafProjectsToList: function(projTree, hash){
			var me=this, curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		loadAllProjects: function(){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				var map = _.reduce(store.getRange(), function(map, project){
					map[project.data.ObjectID] = project;
					return map;
				}, {});
				return map;
			});	
		},
		loadProjectsWithTeamMembers: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				projectsWithTeamMembers = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._addProjectsWithTeamMembersToList(projTree[rootProjectRecord.data.ObjectID], projectsWithTeamMembers);
					return projectsWithTeamMembers;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.TeamMembers.Count > 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},	
		loadAllChildrenProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				childrenProjects = {},
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
					return childrenProjects;
				} else {
					return _.reduce(store.getRange(), function(map, project){
						map[project.data.ObjectID] = project;
						return map;
					}, {});
				}
			});
		},
		loadAllLeafProjects: function(rootProjectRecord){
			//rootProjectRecord is optional
			var me=this,
				leafProjects = {}, 
				store = Ext.create('Rally.data.wsapi.Store', {
					model: "Project",
					fetch: me.projectFields,
					compact: false,
					limit:Infinity,
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){
				if(rootProjectRecord){
					var projTree = me._storeItemsToProjTree(store.getRange());
					me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], leafProjects);
					return leafProjects;
				} else {
					return _.reduce(_.filter(store.getRange(),
						function(project){ return project.data.Children.Count === 0; }),
						function(map, project){
							map[project.data.ObjectID] = project;
							return map;
						}, {});
				}
			});
		},
		loadProjectByName: function(projectName){
			if(!projectName) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					disableMetaChangeEvent: true,
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [{
						property:'Name',
						value:projectName
					}]
				});
			return me.reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** Release loading ********************************************/	
		loadAllReleases: function(projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesAfterGivenDateByProjectObjID: function(projectObjectID, givenDate){
			/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},		
		loadReleasesBeforeGivenDate: function(projectRecord, givenDate){
			/** gets releases for this project that have release date <= givenDate. returns promise that resolves to the releaseStore */
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					autoLoad:false,
					disableMetaChangeEvent: true,
					fetch: me.releaseFields,
					filters:[{
						property:'ReleaseDate',
						operator:'<=',
						value: new Date(givenDate).toISOString()
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit: Infinity,
					autoLoad:false,
					fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>',
						value: new Date(startDate).toISOString()
					},{
						property:'ReleaseStartDate',
						operator:'<',
						value: new Date(endDate).toISOString()
					}]
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		loadReleasesInTheFuture: function(projectRecord){
			return this.loadReleasesAfterGivenDate(projectRecord, new Date());
		},
		loadReleasesByNameUnderProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					}],
					context:{
						project:projectRecord.data._ref,
						projectScopeDown:true,
						projectScopeUp:false
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},	
		loadReleaseByNameForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange().pop(); });
		},
		loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Release',
					limit:Infinity,
					disableMetaChangeEvent: true,
					autoLoad:false,
					fetch: me.releaseFields,
					filters:[{
						property:'Name',
						operator:'contains',
						value: releaseName
					},{
						property:'Project.ObjectID',
						value:projectRecord.data.ObjectID
					}],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project:null
					}
				});
			return me.reloadStore(store).then(function(store){ return store.getRange(); });
		},
		getScopedRelease: function(releaseRecords, projectOID, appPrefs){			
			/** gets the most likely release to scope to base on the following order:
				1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need 
								to use preferences for this one)
				2) if we are currently in one of the releases
				3) the closest release planning date to the current date
			*/
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate)*1, d2 = new Date(r.data.ReleaseStartDate)*1, now = new Date()*1;
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());
                /** 
	SUMMARY:
		This mixin is used if you want to listen to events in the parent window (e.g. useful for rally apps that 
		resize with browser screen vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run using fireParentWindowEvent
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		windowListeners = {};

	Ext.define('Intel.lib.mixin.WindowListener', {

		_initWindowEventListener: function(eventName){
			if(!windowListeners) windowListeners = {};
			windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		/** eventName is something like: resize, scroll, etc... */
		addWindowEventListener: function(eventName, fn){
			if(!windowListeners || !windowListeners[eventName]) 
				this._initWindowEventListener(eventName);
			windowListeners[eventName].push(fn);
		},
		
		/** eventName is something like: resize, scroll, etc... */
		fireParentWindowEvent: function(eventName){
			var me=this;
			if(!windowListeners || !windowListeners[eventName]) return;
			var listeners = windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                /** 
	SUMMARY:
		this mixin is used to mess with the environment outside of the iframe that the rally app is put in. 
		
	DEPENDENCIES:
		'Intel.lib.mixin.WindowListener' mixed in to app so listen for window events
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	var TOP_BAR_HEIGHT = 40,
		BOTTOM_BAR_HEIGHT = 24,
		BOTTOM_IFRAME_PADDING = 20,
		TITLE_BAR_HEIGHT = 33,
		IFRAME_HEADER_HEIGHT = 28;
		
	Ext.define('Intel.lib.mixin.IframeResize', {
		requires: ['Intel.lib.mixin.WindowListener'],
		
		/**
			makes app as large as screen, without the padding/margin. 
			Makes it look more like a built-in rally app instead of a custom app.
			NOTE: as rally changes their interface overtime, this mixin will have to change as well to compensate for it.
		*/
		_fixRallyDashboard: function(){ 
			if(window && window.frameElement){
				var me=this,
					bottomEl = Ext.get(window.frameElement),
					portlet = bottomEl.up('.x-portlet'), 
					dashboard = portlet.up('#mydash_portlet'), //has huge padding values
					titleBar = dashboard.down('.titlebar'), //redundant with app header bar
					domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
					innerHeight = window.parent.innerHeight,
					innerWidth = window.parent.innerWidth;
				
				//remove vertical/horizontal scrolls from top window
				window.parent.document.body.insertAdjacentHTML('afterend', '<style>html, body {overflow: hidden !important; }</style>');
				
				//adjust widths
				while(true){
					domNodeW.style.width = (innerWidth - 10) + 'px';
					domNodeW.style.padding = '0';
					domNodeW.style.margin = '0';
					if(domNodeW.id === 'mydash_portlet') break;
					domNodeW = domNodeW.parentNode;
				}
				
				//adjust heights
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT + IFRAME_HEADER_HEIGHT + BOTTOM_IFRAME_PADDING) - 10) + 'px';
					if(domNodeH.classList.contains('x-portlet')) break;
					domNodeH = domNodeH.parentNode;
				}
				while(true){
					domNodeH.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT + TITLE_BAR_HEIGHT)) + 'px';
					if(domNodeH.id == 'mydash_portlet') break;
					domNodeH = domNodeH.parentNode;
				}
				dashboard.dom.style.height = (innerHeight - (TOP_BAR_HEIGHT + BOTTOM_BAR_HEIGHT)) + 'px';
				
				//final touches LOL
				dashboard.dom.style.padding = "0 2px 0 2px";
				titleBar.dom.style.padding = "2px";
				titleBar.dom.style.margin = "0";
			}
		},		
		initFixRallyDashboard: function(){ 
			var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		/** 
			hides the draggable resize handle from under the app 
		*/
		_disableResizeHandle: function(){ 
			var me=this, handle;
			if(window && window.frameElement){
				handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
				if(handle) {
					handle.hide();
					handle.dom.onshow = function(){ if(handle) handle.hide(); };
				}
			}
		},	
		initDisableResizeHandle: function(){
			var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                /**  
	DESCRIPTION:
		This mixin gives a window-centered alert or confirm dialog box that isn't ugly. 
		
	ISSUES:
		Sometimes alert.setY() fails so we have to fallback to the ugly built-in alert
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.PrettyAlert', {	
		_getMessageBoxY: function(){ 
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.frameElement ? window.parent.getWindowHeight() : window.innerHeight,
				ps = window.frameElement ? window.parent.getScrollY() : window.scrollY,
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},
		
		_formatString: function(message){
			message = message || '';
			return (typeof message === 'string') ? 
				message : (message.message ? 
				message.message : JSON.stringify(message, null, '\t'));
		},

		/** non-ugly alert dialog */
		alert: function(title, message){
			if(arguments.length<1) return;
			if(arguments.length===1){
				message = title;
				title = '';
			}
			
			try {
				Ext.MessageBox.alert(this._formatString(title), this._formatString(message)).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ alert(this._formatString(message)); }
		},
		
		/** non-ugly confirm dialog */
		confirm: function(title, message, fn){
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = message;
				message = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			
			try {
				Ext.MessageBox.confirm(this._formatString(title), this._formatString(message), fn).setY(this._getMessageBoxY());
				setTimeout(function(){
					var x = Ext.MessageBox.down('button');
					while(x.isHidden()) x = x.nextSibling();
					x.focus();
				}, 50);
			}
			catch(e){ if(confirm(this._formatString(message))) fn('yes'); else fn('no'); }
		}
	});
}());
                /** 
	intel workweek utility module. you can pass in Date objects, strings, or numbers.
	do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
**/
(function(){
	var Ext = window.Ext4 || window.Ext,
		intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('Intel.lib.mixin.IntelWorkweek', {
		/** calculates intel workweek, returns integer */
		getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		getWeekCount: function(_date){
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of Date()'s for each week start between start and end date*/
		getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this.roundDateDownToWeekStart(startDate),
				endWeekDate = this.roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		/** gets the Date() object of this ww and year */
		workweekToDate: function(ww, year){ 
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/** assumes DropDown uses Intel.lib.data.WorkweekDropdown model */
		getWorkweeksForDropdown: function(releaseStartDate, releaseEndDate){ 
			var workweeks = this.getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this.getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                /** 
	given named queues, only allows one function at a time in each queue to execute. 
	
	This is just a locking implementation. you call enqueue and then when its your function's turn
	you do stuff and then you call the callback passed to you so the next function can execute.
	
	It will always perfom your queued function wrapped in a setTimeout. 
	
	Mix this in to your app: call me.enqueue(function(){...}, 'queue-name') 
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		QueueOfFuncs = {};
	
	function dequeue(queueName){
		queueName = queueName || 'undefined';
		if(QueueOfFuncs[queueName]){
			QueueOfFuncs[queueName].shift();
			if(!QueueOfFuncs[queueName].length) return;
			else {
				setTimeout(function(){
					QueueOfFuncs[queueName][0].call(null, dequeue.bind(null, queueName));
				}, 0);
			}
		}
	}
	
	Ext.define('Intel.lib.mixin.AsyncQueue', {
		/**
			input callback(done): make sure you call done when you are finished
			input queueName: name of queue to use, if not specified uses default
		*/
		enqueue: function(callback, queueName){
			queueName = queueName || 'undefined';
			if(typeof callback !== 'function') throw new Error('Not a function');
			if(!QueueOfFuncs[queueName] || !QueueOfFuncs[queueName].length){
				QueueOfFuncs[queueName] = [callback];
				setTimeout(function(){
					callback.call(null, dequeue.bind(null, queueName));
				}, 0);
			}
			else QueueOfFuncs[queueName].push(callback);
		}
	});
}());
                /** 
	SUMMARY:
		Use this mixin to load stores that have lots of records. it will load them in parallel instead of serially.
		what it does is loads 1 page and then based on the totalCount it loads the rest of the pages in parallel.
		
		The config you pass to parallelLoadLookbackStore and parallelLoadWsapiStore are the same configs you would pass
		to Rally.data.lookback.Store (or something like that) and Rally.data.wsapi.Store.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.mixin.ParallelLoader', {		
		parallelLoadWsapiStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.wsapi.Store', _.merge({}, config, {
						pageSize:200,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.wsapi.Store', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/200>>0) + (store.totalCount%200 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		},
		parallelLoadLookbackStore: function(config){
			var me=this, data = [], model;
			function doStoreLoad(page){
				var deferred = Q.defer(),
					store = Ext.create('Rally.data.lookback.SnapshotStore', _.merge({}, config, {
						pageSize:20000,
						listeners:{ 
							load: function(store, records, successful){
								if(!successful) deferred.reject('could not load data from server');
								else deferred.resolve(store);
							}
						}
					}));
				store.loadPage(page);
				return deferred.promise;
			}
			function makeStore(){
				return Ext.create('Rally.data.lookback.SnapshotStore', {
					model: model,
					totalCount: data.length,
					data: data,
					disableMetaChangeEvent: true,
					load: function(){}
				});
			}
			return doStoreLoad(1).then(function(store){
				data = data.concat(store.getRange());
				model = store.model;
				var pages = ((store.totalCount/20000>>0) + (store.totalCount%20000 ? 1 : 0)) || 1;
				if(pages === 1) return makeStore();
				else return Q.all(_.times(pages-1, function(pageNum){
					return doStoreLoad(pageNum + 2).then(function(store){ data = data.concat(store.getRange()); });
				})).then(makeStore);
			});
		}
	});
}());

                /** 
	SUMMARY: 
		This mixin is used to save user preferences per project, that can follow the user from app to app. So 
		when you call saveAppsPreference it saves it to a preference filtered by user and the value of me.userAppsPref.
		
		Different apps can share the me.userAppsPref which is useful if you have 5 apps that should all scope to the same
		Release. So if the user scopes to Release R1 on one of the apps, when she goes to any of the other apps, it should
		scope to Release R1 as well.
**/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.UserAppsPreference', {
		
		/** preference name SHOULD be overridden, unless you want all apps to share default preference-name */
		userAppsPref: 'intel-user-apps-preference',
		
		loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName: me.userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me.userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:0};}
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me.userAppsPref] = JSON.stringify(prefs); 
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName: me.userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                /** 
	SUMMARY:
		This mixin is used to communicate between apps the objectID of eachother, so they can link to eachother
		by saving their ObjectIDs in a preference tied to the workspace. 
		
		To get the ObjectID of an app in teh workspace, you need to pass the ClassName of the app,
		which is the string that you pass you Ext.define(<className>, {appConfigObject})
	
	DEPENDENCIES:
		Q promise library
**/
(function(){
	var Ext = window.Ext4 || window.Ext,
		customAppRegisterObjectIdPref = 'intel-custom-app-objectid-register-preference';

	Ext.define('Intel.lib.mixin.CustomAppObjectIDRegister', {
		_loadCustomAppObjectIDSettings: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				workspace: me.getContext().getWorkspace()._ref,
				filterByName: customAppRegisterObjectIdPref,
				success: function(prefs){
					var map;
					try{ map = JSON.parse(prefs[customAppRegisterObjectIdPref]); }
					catch(e){ map = {}; }
					deferred.resolve(map);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		
		getCustomAppObjectID: function(appClassName){
			var me=this;
			return me._loadCustomAppObjectIDSettings().then(function(customAppOIDSettings){
				return customAppOIDSettings[appClassName] || null;
			});
		},
		setCustomAppObjectID: function(appClassName){
			var me=this, s = {},
				objectID = window.parent.location.hash.split("/").pop();
			
			if(!appClassName) return Q.reject('invalid appClassName');
			return me._loadCustomAppObjectIDSettings().then(function(customAppOIDSettings){
				var deferred = Q.defer();
				customAppOIDSettings[appClassName] = objectID;
				s[customAppRegisterObjectIdPref] = JSON.stringify(customAppOIDSettings, null, '  ');
				Rally.data.PreferenceManager.update({
					workspace: me.getContext().getWorkspace()._ref,
					filterByName: customAppRegisterObjectIdPref,
					settings: s,
					success: deferred.resolve,
					failure: deferred.reject
				});
				return deferred.promise;
			});
		}
	});
}());
                /**
	this mixin takes in a releaseRecord and points for the release and returns the color
	that it would be in Rally based on this algorithm (same defaults are used):
		https://help.rallydev.com/track-portfolio-items#coloralg
*/
(function() {
	var Ext = window.Ext4 || window.Ext,
		RED_X_INTERCEPT = 40,	
		RED_X_SLOPE = 100/(100-RED_X_INTERCEPT),
		YELLOW_X_INTERCEPT = 20,
		YELLOW_X_SLOPE = 100/(100-YELLOW_X_INTERCEPT);
		
	Ext.define('Intel.lib.mixin.RallyReleaseColor', {
		
		/**
			Since releasePercentComplete (x value) and planEstimatePercentAccepted (y value) are between 0-100, 
			we set up are algorithm in the x and y ranges of 0-100 as well 
		*/
		getRallyReleaseColor: function(releaseRecord, completedPoints, totalPoints){
			var curDate = new Date()*1, 
				relStartDate = new Date(releaseRecord.data.ReleaseStartDate)*1,
				relEndDate = new Date(releaseRecord.data.ReleaseDate)*1,
				releasePercentComplete = 100*(curDate - relStartDate)/(relEndDate - relStartDate),
				planEstimatePercentAccepted = totalPoints === 0 ? 0 : 100*(completedPoints/totalPoints),
				redLineYValueAtX = (releasePercentComplete - RED_X_INTERCEPT)*RED_X_SLOPE,
				yellowLineYValueAtX = (releasePercentComplete - YELLOW_X_INTERCEPT)*YELLOW_X_SLOPE;
				
			releasePercentComplete = (releasePercentComplete > 100 ? 100 : (releasePercentComplete < 0 ? 0 : releasePercentComplete));
			redLineYValueAtX = redLineYValueAtX < 0 ? 0 : redLineYValueAtX;
			yellowLineYValueAtX = yellowLineYValueAtX < 0 ? 0 : yellowLineYValueAtX;
			
			if(planEstimatePercentAccepted === 0) return 'white';
			if(planEstimatePercentAccepted > 0 && releasePercentComplete < 0) return 'lightgray';
			if(planEstimatePercentAccepted === 100) return 'gray';
			if(planEstimatePercentAccepted > yellowLineYValueAtX) return 'green';
			if(planEstimatePercentAccepted <= yellowLineYValueAtX && planEstimatePercentAccepted > redLineYValueAtX) return 'yellow';
			if(planEstimatePercentAccepted <= redLineYValueAtX) return 'red';
			throw new Error('invalid getRallyColor input');
		}
	});
})();

                /**
	This mixin exposes a few public methods that allow the caller to easily get 
	info about the horizontal and teamTypeInfo for a list of projects.
	
	The reason that you should ALWAYS call getAllHorizontalTeamTypeInfos with multiple 
	projects instead of getHorizontalTeamTypeInfo 1 project is because this allows the 
	'number' field of the teamTypeInfo to be set correctly.
	For example:
		You have projects: ['MPV 1', 'MPV 2', 'MVP OR'],
		this will map to: ['MPV 1', 'MPV 2', 'MPV 3']
		but if you passed all three separately: ['MPV 1'], ['MPV 2'], ['MVP OR'],
		you would end up with 2 'MPV 1's: ['MPV 1'], ['MPV 2'], ['MVP 1'],
		
	The above example shows that the algorithm tries to set the numbers of teams
	with no numbers. the numbers assigned to these will be relative to the other
	projects passed in. That is why you will ALMOST ALWAYS WASNT TO PASS IN ALL
	PROJECTS OF A TRAIN AT ONCE!
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.mixin.HorizontalTeamTypes', {
		requires:['Intel.lib.IntelRallyApp'],
		
		_getHorizontalTeamTypeInfo: function(projectRecord){
			var me=this,
				scrumName = projectRecord.data.Name.split('-')[0].replace(/\(.*\)/g, '').trim(),
				scrumTeamType = scrumName.split(/\d/)[0].trim(),
				number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
				notInHorizontalObject = {
					projectRecord: projectRecord,
					horizontal:null, 
					teamType:scrumTeamType,
					teamTypeComponents: [],
					number:number
				},
				teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function(result, teamTypes, horizontal){
					if(result) return result; 
					else {
						var teamTypeMatches = _.reduce(teamTypes, function(teamTypeMatches, teamType){
							/**
								If the teamType is in the name of the scrum, add it to teamTypeMatches.
								If there is another teamType already added that is a substring of this teamType,
								remove it from the teamType matches. If the current teamType is a substring of another
								teamType already matches, DO NOT add this teamType to the matched teamTypes
								
								Example:	
									scrum name="ABC - Train"
									teamType options:["AB" "ABC" "ABCD"]
											
									the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
							*/
							if(scrumName.indexOf(teamType) > -1){
								for(var i=teamTypeMatches.length-1;i>=0;--i){
									if(teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
									if(teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
								}
								teamTypeMatches.push(teamType);
							}
							return teamTypeMatches;
						}, []);
						return teamTypeMatches.length ? {
								projectRecord: projectRecord,
								horizontal:horizontal, 
								teamType: teamTypeMatches.sort().join(' '), 
								teamTypeComponents: teamTypeMatches.sort(),
								number:number
							} : 
							null;
					}
				}, null);
			return teamTypeObject || notInHorizontalObject;
		},	
		_resolveTeamTypeInfoConflicts: function(teamTypeInfos, startIndex){
			startIndex = startIndex || 1;
			_.each(_.sortBy(teamTypeInfos, 
				function(teamTypeInfo){ return teamTypeInfo.projectRecord.data.Name; }),
				function(teamTypeInfo, index){ teamTypeInfo.number = index + startIndex; return teamTypeInfo; });
		},
		getAllHorizontalTeamTypeInfos: function(projectRecords){
			var me = this;
			return [].concat.apply([], _.map(_.groupBy(_.map(projectRecords, 
				function(projectRecord){ return me._getHorizontalTeamTypeInfo(projectRecord); }),
				function(teamTypeInfo){ return teamTypeInfo.teamType; }),
				function(teamTypeInfos){
					if(teamTypeInfos.length === 1) return teamTypeInfos; 
					else {
						var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function(teamTypeInfo){ return teamTypeInfo.number === 1; });
						if(teamTypeInfosWithNumber1.length > 1){
							var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function(teamTypeInfo){ 
									return teamTypeInfo.projectRecord.data.Name.indexOf('1') === -1; 
								}),
								startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
							me._resolveTeamTypeInfoConflicts(projectsWithoutExplicit1, startIndex);
						}
						return teamTypeInfos;
					}
				})
			);
		},
		getHorizontalTeamTypeInfo: function(projectRecord){
			return this._getHorizontalTeamTypeInfo(projectRecord);
		},
		isProjectInHorizontal: function(projectRecord, horizontal){
			return this._getHorizontalTeamTypeInfo(projectRecord).horizontal === horizontal;
		},
		
		_getHorizontalTeamTypeInfoFromProjectName: function(projectName){
			var me=this,
				scrumName = projectName.split('-')[0].replace(/\(.*\)/g, '').trim(),
				scrumTeamType = scrumName.split(/\d/)[0].trim(),
				number = (scrumTeamType === scrumName ? 1 : parseInt(scrumName.split(scrumTeamType)[1], 10)),
				notInHorizontalObject = {
					projectName: projectName,
					horizontal:null, 
					teamType:scrumTeamType,
					teamTypeComponents: [],
					number:number
				},
				teamTypeObject = _.reduce(this.HorizontalGroupingConfig.groups, function(result, teamTypes, horizontal){
					if(result) return result; 
					else {
						var teamTypeMatches = _.reduce(teamTypes, function(teamTypeMatches, teamType){
							/**
								If the teamType is in the name of the scrum, add it to teamTypeMatches.
								If there is another teamType already added that is a substring of this teamType,
								remove it from the teamType matches. If the current teamType is a substring of another
								teamType already matches, DO NOT add this teamType to the matched teamTypes
								
								Example:	
									scrum name="ABC - Train"
									teamType options:["AB" "ABC" "ABCD"]
											
									the above scrum name will match "AB" and "ABC", but will only return ["ABC"]
							*/
							if(scrumName.indexOf(teamType) > -1){
								for(var i=teamTypeMatches.length-1;i>=0;--i){
									if(teamTypeMatches[i].indexOf(teamType) > -1) return teamTypeMatches;
									if(teamType.indexOf(teamTypeMatches[i]) > -1) teamTypeMatches.splice(i, 1);
								}
								teamTypeMatches.push(teamType);
							}
							return teamTypeMatches;
						}, []);
						return teamTypeMatches.length ? {
								projectName: projectName,
								horizontal:horizontal, 
								teamType: teamTypeMatches.sort().join(' '), 
								teamTypeComponents: teamTypeMatches.sort(),
								number:number
							} : 
							null;
					}
				}, null);
			return teamTypeObject || notInHorizontalObject;
		},
		_resolveTeamTypeInfoConflictsFromProjectNames: function(teamTypeInfos, startIndex){
			startIndex = startIndex || 1;
			_.each(_.sortBy(teamTypeInfos, 
				function(teamTypeInfo){ return teamTypeInfo.projectName; }),
				function(teamTypeInfo, index){ teamTypeInfo.number = index + startIndex; return teamTypeInfo; });
		},	
		getAllHorizontalTeamTypeInfosFromProjectNames: function(projectNames){
			var me = this;
			return [].concat.apply([], _.map(_.groupBy(_.map(projectNames, 
				function(projectName){ return me._getHorizontalTeamTypeInfoFromProjectName(projectName); }),
				function(teamTypeInfo){ return teamTypeInfo.teamType; }),
				function(teamTypeInfos){
					if(teamTypeInfos.length === 1) return teamTypeInfos; 
					else {
						var teamTypeInfosWithNumber1 = _.filter(teamTypeInfos, function(teamTypeInfo){ return teamTypeInfo.number === 1; });
						if(teamTypeInfosWithNumber1.length > 1){
							var projectsWithoutExplicit1 = _.filter(teamTypeInfosWithNumber1, function(teamTypeInfo){ 
									return teamTypeInfo.projectName.indexOf('1') === -1; 
								}),
								startIndex = Math.max.apply(Math, _.pluck(teamTypeInfos, 'number')) + 1;
							me._resolveTeamTypeInfoConflictsFromProjectNames(projectsWithoutExplicit1, startIndex);
						}
						return teamTypeInfos;
					}
				})
			);
		},		
		getHorizontalTeamTypeInfoFromProjectName: function(projectName){
			return this._getHorizontalTeamTypeInfoFromProjectName(projectName);
		},
		isProjectNameInHorizontal: function(projectName, horizontal){
			return this._getHorizontalTeamTypeInfoFromProjectName(projectName).horizontal === horizontal;
		},
		
		getAllHorizontalTeamTypeComponents: function(){
			return [].concat.apply([], _.values(this.HorizontalGroupingConfig.groups));
		},
		getAllHorizontals: function(){
			return _.keys(this.HorizontalGroupingConfig.groups);
		},
		teamTypeComponentInWhichHorizontal: function(teamType){
			var me=this;
			return _.find(_.keys(me.HorizontalGroupingConfig.groups), function(hz){ 
				return _.contains(me.HorizontalGroupingConfig.groups[hz], teamType);
			});
		}
	});
}());

                /** 
	SUMMARY:
		This combo has filter-as-you-type and drops down on click. it also lets you navigate with arrow keys
		(although there is some arrow key scrolling bug) 
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.component.ComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelcombo', 'widget.intelcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				enableKeyEvents:true,
				queryMode:'local',
				ignoreNoChange:true,
				allowBlank:true,
				listeners: {
					change: function(a,b){
						if(!b || (b.keyCode>=37 && b.keyCode <=40)) return; //arrow keys
						var combo = this;
						combo.store.clearFilter();
						combo.store.filterBy(function(item){
							var escapedValue = combo.getRawValue().replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, "\\$&");
							return item.data[combo.displayField].match(new RegExp(escapedValue, 'i')) !== null;
						});
					},
					focus: function(combo) {
						combo.store.clearFilter();
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}
	});
}());
                /** 
	SUMMARY:
		This combo has some built in defaults for static-comboboxes (which means you dont type into it, you just select from it)
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.FixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		editable: false,	
		allowBlank:true,
		queryMode:'local',
		matchFieldWidth: false,
		listeners: {
			change:function(combo, newval, oldval){ 
				if(newval.length===0) combo.setValue(oldval || ''); 
			},
			focus: function(combo) {
				if(combo.store.findExact(combo.valueField, combo.getValue()) === -1) combo.setValue('');
				combo.expand();
			}
		}
	});
}());
                /** 
	SUMMARY:
		This component is an easy release picker based off Intel.lib.component.FixedComboBox. You supply the 
		Release Records to it on construction.
		
		YOU MUST PASS IT 2 THINGS IN THE CONFIG
			1: releases (array of release records)
			2: currentRelease (what to show as initial value
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.ReleasePicker', {
		extend: 'Intel.lib.component.FixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                /**
	SUMMARY:
		Textarea with some defaults built into it.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.lib.component.TextArea', {
		extend: 'Ext.form.field.TextArea',
		alias: ['widget.inteltextarea'],
		
		grow:true,
		growMin:20,
		growMax:160,
		maxLength:150,
		enforceMaxLength:true,
		enterIsSpecial:true
	});
}());
                /** 
	SUMMARY:
		This is used in grid column configs in the items: [] field for the column. It is a fancy grid column filter component.
		
	DEPENDENCIES:
		Intel.lib.component.FixedComboBox OR <whatever your filterXtype is>
		Intel.lib.mixin.PrettyAlert
		
		Q
		lodash
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;	
	
	Ext.define('Intel.lib.component.GridColumnFilter', {
		extend:'Ext.container.Container',
		cls: 'intel-grid-column-filter',
		alias: ['widget.intelgridcolumnfilter'],
		mixins: [
			'Intel.lib.mixin.PrettyAlert'
		],
		
		layout: 'hbox',
		border:0,
		flex:1,
		
		/**************************************** caller CAN override these **********************************************/
		filterXtype: 'intelfixedcombo',
		valueField: null,
		displayField: null,
		multiSelect: true,
		convertDisplayFn: function(value, field, record){ return value; },			//can return promise
		convertValueFn: function(value, field, record){ return value; },				//can return promise
		sortFn: function(valueFieldValue, displayFieldValue, record){ return valueFieldValue; },
		filterFn: function(filterValue, recordValue, valueField, record){ return filterValue === recordValue; },
		
		/**************************************** INITIALIZE/PRIVATE METHODS **********************************************/
		initComponent: function(){
			var colFilter = this;
			colFilter.filterValues = [];
			colFilter.hideClass = 'grid-column-filter-hide-' + (Math.random()*1000000>>0);
			Ext.DomHelper.append(Ext.getBody(), '<style>.' + colFilter.hideClass + ' { display: none; }</style>');
			Ext.DomHelper.append(Ext.getBody(), '<style>.intel-grid-column-filter > * { border: none !important; }</style>');
			colFilter.on('added', function(){ colFilter._initColFilter(); });
			colFilter.callParent();
		},
		
		_initColFilter: function(){
			var colFilter = this, 
				column = colFilter.ownerCt,
				valueField = colFilter.valueField || column.dataIndex,
				displayField = colFilter.displayField || valueField;
			setTimeout(function waitForGrid(){
				var grid = column.up('grid');
				if(grid){ 
					var gridStore = grid.getStore();
				
					grid.view.getRowClass = colFilter._createGetRowClassIntercepter(grid.view.getRowClass);
					colFilter._addItems(gridStore, valueField, displayField);
					gridStore.on('datachanged', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					gridStore.on('refresh', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					grid.on('edit', function(){ colFilter._updateStoreOptions(gridStore, valueField, displayField); });
					grid.on('sortchange', function(){ colFilter.applyFilters(); });
				}
				else setTimeout(waitForGrid, 20);
			}, 20);
		},
		_addItems: function(gridStore, valueField, displayField){
			var colFilter = this;
			colFilter._getStoreOptions(gridStore, valueField, displayField).then(function(storeOptions){
				colFilter.add([{
					xtype: colFilter.filterXtype,
					flex:1,
					emptyText: 'Add Filter',
					store: Ext.create('Ext.data.Store', {
						fields:[
							{name:'Display', type:'auto'}, 
							{name:'Value', type:'auto'}
						],
						data: storeOptions
					}),
					displayField: 'Display',
					valueField: 'Value',
					multiSelect: colFilter.multiSelect,
					listeners:{
						select: function(combo, selected){
							if(_.find(selected, function(s){ return s.data.Display === 'Clear'; })) colFilter.clearFilters();
							else colFilter.setFilterValues(_.map(selected, function(s){ return s.data.Value; }));
							var store = colFilter.up('grid').store;
							store.fireEvent('refresh', store);
						}
					}
				}, {xtype:'container', width:5}]);
				colFilter.doLayout();
			})
			.fail(function(reason){ colFilter.alert('ERROR', reason); })
			.done();
		},	
		_getStoreOptions: function(gridStore, valueField, displayField){
			var grid = this;
			return Q.all(_.map(gridStore.getRange(), function(record){
				return Q.all([
					Q(grid.convertDisplayFn(record.get(displayField), displayField, record)),
					Q(grid.convertValueFn(record.get(valueField), valueField, record)),
					Q(record)
				]);
			}))
			.then(function(options){	
				return [{Display:'Clear', Value: null}].concat(_.sortBy(_.unique(_.map(_.filter(options, 
					function(option){ return option[0] !== undefined && option[1] !== undefined; }),
					function(option){ return {Display: option[0], Value: option[1], Record: option[2]}; }),
					function(option){ return option.Value; }),
					function(option){ return grid.sortFn(option.Value, option.Display, option.Record); })); 
			});
		},
		_updateStoreOptions: function(gridStore, valueField, displayField){
			var colFilter = this;
			colFilter._getStoreOptions(gridStore, valueField, displayField).then(function(newComboOptions){
				var comboFilter = colFilter.down(colFilter.filterXtype),
					comboFilterStore = comboFilter.getStore(),
					oldFilterValues = colFilter.getFilterValues(),
					newFilterValues = _.filter(oldFilterValues, function(oldFilterValue){
						return _.find(newComboOptions, function(option){ return option.Value === oldFilterValue; });
					});
				
				comboFilter.store.removeAll();
				comboFilter.store.add(newComboOptions);
				colFilter.setFilterValues(newFilterValues);
			})
			.fail(function(reason){ colFilter.alert('ERROR', reason); })
			.done();
		},
		
		_createGetRowClassIntercepter: function(fn){
			var colFilter = this, column = colFilter.ownerCt;
			
			return function(record){
				var originalCls = (fn || function(){}).apply(null, arguments) || '',
					valueField = colFilter.valueField || column.dataIndex,
					isVisible = !colFilter.filterValues.length || _.any(colFilter.filterValues, function(filterValue){ 
						return colFilter.filterFn(filterValue, record.get(valueField), valueField, record);
					}); 
				if(!isVisible) return originalCls + ' ' + colFilter.hideClass;
				else return originalCls;
			};
		},
		
		_applyToGridView: function(grid, fn, args){
			var view = grid.getView(), lockingPartner = view.lockingPartner;
			view[fn].apply(view, args);
			if(lockingPartner) lockingPartner[fn].apply(lockingPartner, args);
		},
		
		/****************************************PUBLIC METHODS **********************************************/
		applyFilters: function(){
			var colFilter = this,
				column = colFilter.ownerCt,
				grid = colFilter.up('grid'),
				valueField = colFilter.valueField || column.dataIndex;
			_.each(grid.store.getRange(), function(record, index){
				var isVisible = !colFilter.filterValues.length || _.any(colFilter.filterValues, function(filterValue){ 
						return colFilter.filterFn(filterValue, record.get(valueField), valueField, record);
					}); 
				if(isVisible) colFilter._applyToGridView(grid, 'removeRowCls', [index, colFilter.hideClass]); 
				else colFilter._applyToGridView(grid, 'addRowCls', [index, colFilter.hideClass]); 
			});
		},
		getFilterValues: function(){
			return this.filterValues;
		},
		setFilterValues: function(values){
			var colFilter = this,
				comboFilter = colFilter.down(colFilter.filterXtype);
				
			comboFilter.setValue(values);
			colFilter.filterValues = values;
			colFilter.applyFilters();
		},
		clearFilters: function(){
			var colFilter = this,
				grid = colFilter.up('grid'),
				comboFilter = colFilter.down(colFilter.filterXtype),
				recordCount = grid.store.getCount();
				
			comboFilter.setValue();
			colFilter.filterValues = [];
			while(recordCount--) colFilter._applyToGridView(grid, 'removeRowCls', [recordCount, colFilter.hideClass]); 
		}
	});
}());
	
                /**
	SUMMARY:
		This override improves performance for sessionStorage proxy mostly by removing redundant page refreshes.
		
		The regular proxy calls record.commit() and later on, datarefresh event is called. since these both cause a rerender, 
		we make the record edits SILENT, so only the datarefresh actually re-render the page
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.component.SessionStorage', {
		extend: 'Ext.data.proxy.SessionStorage',
		alias: ['proxy.intelsessionstorage'],
		constructor: function(cfg) {
			this.callParent(arguments);
		},
		
		create: function(operation, callback, scope) {
			var me = this,
				records = operation.records,
				length = records.length,
				ids = me.getIds(),
				id, record, i;

			operation.setStarted();
			if(me.isHierarchical === undefined) {
					
					
				me.isHierarchical = !!records[0].isNode;
				if(me.isHierarchical) {
					me.getStorageObject().setItem(me.getTreeKey(), true);
				}
			}
			for (i = 0; i < length; i++) {
				record = records[i];

				if (record.phantom) {
					record.phantom = false;
					id = me.getNextId();
				} else {
					id = record.getId();
				}
				
				record.beginEdit();
				me.setRecord(record, id);
				record.endEdit(true); //SILENT!!!
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!
				
				ids.push(id);
			}
			me.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();

			if (typeof callback == 'function') {
				callback.call(scope || me, operation);
			}
		},
		
		update: function(operation, callback, scope) {
			var records = operation.records,
				length = records.length,
				ids = this.getIds(),
				record, id, i;
				
			operation.setStarted();
			for (i = 0; i < length; i++) {
				record = records[i];
				this.setRecord(record);
			
				record.commit(true); //SILENT, dataview refresh will get called anyways!!!!!!!!!!!

				id = record.getId();
				if (id !== undefined && Ext.Array.indexOf(ids, id) == -1) ids.push(id);
			}
			this.setIds(ids);

			operation.setCompleted();
			operation.setSuccessful();
			if (typeof callback == 'function') callback.call(scope || this, operation);
		}
	});
}());
                /**
	SUMMARY:
		performance optimized Ext.data.Store. Improvements found using Chrome Profiling.
		Improvements include removing redundant call to me.sync() which triggers another grid refresh
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.lib.component.Store', {
		extend: 'Ext.data.Store',
		alias: ['store.intelstore'],
		
		afterEdit: function(record, modifiedFieldNames) {
			var me = this, i, shouldSync;
			if (me.autoSync && !me.autoSyncSuspended) {
				for (i = modifiedFieldNames.length; i--;) {
					if (record.fields.get(modifiedFieldNames[i]).persist) {
						me.sync();  //all rendering changes made here
						break;
					}
				}
			}
			me.onUpdate(record, Ext.data.Model.EDIT, modifiedFieldNames);
			//me.fireEvent('update', me, record, Ext.data.Model.EDIT, modifiedFieldNames); //redundant with me.sync()
		}
	});
}());
                /**
	SUMMARY:
		Cell editing has redundant calls to store.afterEdit, which in turn renders the page multiple times per edit. 
		fastcellediting solves this by wrapping all the calls in beginEdit and endEdit, so store.afterEdit is called only once
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('Intel.lib.component.CellEditing', {
		extend: 'Ext.grid.plugin.CellEditing',
		alias: ['plugin.intelcellediting'],

		triggerEvent:'cellclick',
		
		onEditComplete : function(ed, value, startValue) {
			var me = this,
				activeColumn = me.getActiveColumn(),
				context = me.context,
				record;
			if (activeColumn) {
				record = context.record;

				me.setActiveEditor(null);
				me.setActiveColumn(null);
				me.setActiveRecord(null);

				context.value = value;
				if (!me.validateEdit()) {
						me.editing = false;
						return;
				}
				record.beginEdit(); //only call store.AfterEdit at the very End 
				if (!record.isEqual(value, startValue)) 
						record.set(activeColumn.dataIndex, value); //dont call store.AfterEdit

				context.view.focusRow(context.rowIdx, 100);
				me.fireEvent('edit', me, context); //dont call store.AfterEdit if record.set() is called in here
				record.endEdit(); //now call store.AfterEdit!
				me.editing = false;
			}
		}
	});
}());
                /**
	SUMMARY:
		Overrides Ext.view.Table to make the scrollbar not jump on grid refreshes. Also it has some 
		permormance optimizations included in it (which should be commented)
*/
(function(){
	var Ext = window.Ext4 || window.Ext;
		
	Ext.define('Intel.lib.component.TableView', {
		extend: 'Ext.view.Table',		
		alias: ['widget.inteltableview'],
		
		refresh: function() {
			var me = this,
				targetEl,
				targetParent,
				oldDisplay,
				nextSibling,
				dom,
				records,
				el = me.getEl(), //edit
				scroll = el && el.getScrollTop();//edit
				
			if (!me.rendered || me.isDestroyed) return;

			if (!me.hasListeners.beforerefresh || me.fireEvent('beforerefresh', me) !== false) {
				targetEl = me.getTargetEl();
				records = me.getViewRange();
				dom = targetEl.dom;
				if (!me.preserveScrollOnRefresh) {
					targetParent = dom.parentNode;
					oldDisplay = dom.style.display;
					dom.style.display = 'none';
					nextSibling = dom.nextSibling;
					targetParent.removeChild(dom);
				}
				if (me.refreshCounter) me.clearViewEl();
				else {
					me.fixedNodes = targetEl.dom.childNodes.length;
					me.refreshCounter = 1;
				}
				me.tpl.append(targetEl, me.collectData(records, me.all.startIndex));

				if (records.length < 1) {
					if (!this.store.loading && (!me.deferEmptyText || me.hasFirstRefresh)) {
						Ext.core.DomHelper.insertHtml('beforeEnd', targetEl.dom, me.emptyText);
					}
					me.all.clear();
				} else {
					me.collectNodes(targetEl.dom);
					me.updateIndexes(0);
				}
				if (me.hasFirstRefresh) {
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					} else {
						me.selModel.pruneIf();
					}
				}
				me.hasFirstRefresh = true;

				if (!me.preserveScrollOnRefresh) {
					targetParent.insertBefore(dom, nextSibling);
					dom.style.display = oldDisplay;
				}

				Ext.suspendLayouts();
				this.refreshSize();
				me.fireEvent('refresh', me);
				Ext.resumeLayouts(true);
				
				if (!me.viewReady) {
					me.viewReady = true;
					me.fireEvent('viewready', me);
				}
			}
			
			if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
		},
		
		onRemove : function(ds, records, indexes) {
			var me = this,
				fireItemRemove = me.hasListeners.itemremove,
				i,
				record,
				index,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.all.getCount()) {
				if (me.dataSource.getCount() === 0) {
					if (fireItemRemove) {
						for (i = indexes.length - 1; i >= 0; --i) {
							me.fireEvent('itemremove', records[i], indexes[i]);
						}
					}
					//me.refresh();
				} else {
					for (i = indexes.length - 1; i >= 0; --i) {
						record = records[i];
						index = indexes[i];
						me.doRemove(record, index);
						if (fireItemRemove) {
							me.fireEvent('itemremove', record, index);
						}
					}
					me.updateIndexes(indexes[0]);
				}
				this.refreshSize();
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onUpdate : function(ds, record){
			var me = this,
				index,
				node,
				el = me.getEl(),//edit
				scroll = el && el.getScrollTop();//edit

			if (me.viewReady) {
				index = me.dataSource.indexOf(record);
				if (index > -1) {
					node = me.bufferRender([record], index)[0];
					if (me.getNode(record)) {
						me.all.replaceElement(index, node, true);
						me.updateIndexes(index, index);
						me.selModel.onUpdate(record);
						if (me.hasListeners.itemupdate) {
							me.fireEvent('itemupdate', record, index, node);
						}
						return node;
					}
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},
		
		onAdd : function(store, records, index) {
			var me = this,
				nodes,
				el = me.getEl(),
				scroll = el && el.getScrollTop();

			if (me.rendered) {
				if (me.all.getCount() === 0) {
					me.refresh();
					nodes = me.all.slice();
				} else {
					nodes = me.doAdd(records, index);
					if (me.refreshSelmodelOnRefresh !== false) {
						me.selModel.refresh();
					}
					me.updateIndexes(index);
					//me.refreshSize(); //already being refreshed by store.sync()
				}

				if (me.hasListeners.itemadd) {
					me.fireEvent('itemadd', records, index, nodes);
				}
				if(scroll && me.preserveScrollOnRefresh) el.setScrollTop(scroll);//edit
			}
		},

		scrollRowIntoView: function(row) {
			if(row===0){
				this.getEl().setScrollTop(0);
				return;
			}
			row = this.getNode(row, true);
			if (row) {
				Ext.fly(row).scrollIntoView(this.el, false);
			}
		}
	});
}());
                //TODO: move these models into their own files and name them appropriately (e.g.: Intel.SAFe.lib.model.<model name>)

(function(){
	var Ext = window.Ext4 || window.Ext;
	
	/************************* USED FOR PROGRAM-BOARD VIEW *********************************************/
	Ext.define('IntelVelocity', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Name', type: 'string'},
			{name: 'PlannedVelocity', type: 'number'},
			{name: 'RealVelocity', type:'number'}
		]
	});
	Ext.define('IntelTeamCommits', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemMoSCoW', type:'string'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'Commitment', type: 'string'},
			{name: 'Expected', type: 'boolean'},
			{name: 'FeatureStatus', type: 'boolean'},
			{name: 'Objective', type:'string'},
			{name: 'PortfolioItemRank', type: 'number'}
		]
	});

	Ext.define('IntelPredecessorItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PredecessorItemID',  type: 'string'}, 
			{name: 'PredecessorUserStoryObjectID', type: 'number'},
			{name: 'PredecessorProjectObjectID',  type: 'number'},
			{name: 'Supported', type: 'string'},
			{name: 'Assigned', type: 'boolean'} 
		]
	});

	Ext.define('IntelPredecessorDependency', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'UserStoryName',  type: 'string'}, //can be different than UserStoryObjectID
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Plan', type:'string'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		
		
	Ext.define('IntelSuccessorDependency', { 
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'SuccessorUserStoryObjectID', type: 'string' },
			{name: 'SuccessorProjectObjectID', type: 'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'UserStoryName', type: 'string'}, //can be different than UserStoryObjectID (or null)
			{name: 'Description', type: 'string'}, 
			{name: 'NeededBy', type: 'number'},
			{name: 'Supported', type: 'string'}, 
			{name: 'Assigned', type: 'boolean'},
			{name: 'Edited', type: 'boolean'}
		]
	});	

	/************************* USED FOR RISKS/DEPS AND SWIMLANE(RISKS ONLY) VIEW *********************************************/
	Ext.define('IntelPredecessorDependencyForTracking', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'DependencyID', type:'string'},
			{name: 'UserStoryObjectID', type: 'number'},
			{name: 'UserStoryFormattedID',  type: 'string'}, 
			{name: 'UserStoryName',  type: 'string'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'ProjectObjectID', type:'number'},
			{name: 'Description', type: 'string'},
			{name: 'NeededBy', type: 'number'},
			{name: 'Plan', type:'string'},
			{name: 'Status', type:'string'},
			{name: 'PredecessorItems', type: 'auto'}, 
			{name: 'Edited', type: 'boolean'}
		]
	});		

	/************************* USED FOR TEAMCOMMITS VIEW *********************************************/
	Ext.define('CommitsMatrixPortfolioItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'PortfolioItemObjectID', type: 'number'},
			{name: 'PortfolioItemRank', type: 'number'},
			{name: 'PortfolioItemName', type: 'string'},
			{name: 'PortfolioItemFormattedID', type:'string'},
			{name: 'PortfolioItemPlannedEnd', type:'number'},
			{name: 'TopPortfolioItemName', type:'string'},
			{name: 'MoSCoW', type: 'string'}
		]
	});
	
	/************************* USED FOR CUSTOM-FIELD EDITOR *********************************************/
	Ext.define('SAFeCustomFieldsEditorModel', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'ItemFormattedID', type:'string'},
			{name: 'ItemName', type:'string'},
			{name: 'ProjectName', type:'string'},
			{name: 'ReleaseName', type:'string'},
			{name: 'CustomFieldValue',  type: 'string'}
		]
	});
}());
                /** 
	this app will probably get buggy if you have multiple projects with the same name or portfolioItems with the same name
	Because i never tested for that.
*/
(function(){
	var Ext = window.Ext4 || window.Ext,
		COLUMN_DEFAULTS = {
			text:'',
			resizable: false,
			draggable: false,
			sortable: false,
			editor: false,
			menuDisabled: true,
			renderer: function(val){ return val || '-'; },
			layout: 'hbox'
		};
	
	Ext.define('Intel.SAFe.ArtCommitMatrix', {
		extend: 'Intel.lib.IntelRallyApp',
		mixins:[
			'Intel.lib.mixin.WindowListener',
			'Intel.lib.mixin.PrettyAlert',
			'Intel.lib.mixin.IframeResize',
			'Intel.lib.mixin.IntelWorkweek',
			'Intel.lib.mixin.AsyncQueue',
			'Intel.lib.mixin.ParallelLoader',
			'Intel.lib.mixin.UserAppsPreference',
			'Intel.lib.mixin.RallyReleaseColor',
			'Intel.lib.mixin.HorizontalTeamTypes',
			'Intel.lib.mixin.CustomAppObjectIDRegister'
		],
		
		layout: {
			type:'vbox',
			align:'stretch',
			pack:'start'
		},
		items:[{
			xtype:'container',
			itemId:'navbox',
			layout: {
				type:'hbox',
				align:'stretch',
				pack:'start'
			},
			items:[{
				xtype:'container',
				flex:3,
				itemId:'navboxLeft',
				layout: 'hbox',
				items:[{
					xtype:'container',
					flex:1,
					itemId:'navboxLeftVert',
					layout: 'vbox'
				}]
			},{
				xtype:'container',
				flex:2,
				itemId:'navboxRight',
				layout: {
					type:'hbox',
					pack:'end'
				}
			}]
		}],
		minWidth:910,
		
		userAppsPref: 'intel-SAFe-apps-preference',

		/**___________________________________ DATA STORE METHODS ___________________________________*/	
		loadPortfolioItems: function(){ 
			var me=this, deferred = Q.defer();
			me.portfolioItemFields =["Name", "ObjectID", "FormattedID", "Release", "c_TeamCommits", /* "c_MoSCoW", */ "c_Risks", "Project", "PlannedEndDate", "Parent", "Children", "PortfolioItemType", "Ordinal", "PercentDoneByStoryPlanEstimate","DragAndDropRank"];
			me.enqueue(function(done){
				Q.all(_.map(me.PortfolioItemTypes, function(type, ordinal){
					return (ordinal ? //only load lowest portfolioItems in Release (upper porfolioItems don't need to be in a release)
							me.loadPortfolioItemsOfType(me.ScrumGroupPortfolioProject, type) : 
							me.loadPortfolioItemsOfTypeInRelease(me.ReleaseRecord, me.ScrumGroupPortfolioProject, type)
						);
					}))
					.then(function(portfolioItemStores){
						if(me.PortfolioItemStore) me.PortfolioItemStore.destroyStore(); //destroy old store, so it gets GCed
						me.PortfolioItemStore = portfolioItemStores[0];
						me.PortfolioItemMap = me.createBottomPortfolioItemObjectIDToTopPortfolioItemNameMap(portfolioItemStores);
						
						//destroy the stores, so they get GCed
						portfolioItemStores.shift();
						while(portfolioItemStores.length) portfolioItemStores.shift().destroyStore();
					})
					.then(function(){ done(); deferred.resolve(); })
					.fail(function(reason){ done(); deferred.reject(reason); })
					.done();
				}, 'PortfolioItemQueue');
			return deferred.promise;
		},		
		getUserStoryQuery: function(portfolioItemRecords){
			var me=this,
				lowestPortfolioItemType = me.PortfolioItemTypes[0],
				leafFilter = Ext.create('Rally.data.wsapi.Filter', { property: 'DirectChildrenCount', value: 0 }),
				releaseFilter = Ext.create('Rally.data.wsapi.Filter', {property: 'Release.Name', value: me.ReleaseRecord.data.Name }),
				portfolioItemFilter = _.reduce(portfolioItemRecords, function(filter, portfolioItemRecord){
					var newFilter = Ext.create('Rally.data.wsapi.Filter', {
						property: lowestPortfolioItemType + '.ObjectID',
						value: portfolioItemRecord.data.ObjectID
					});
					return filter ? filter.or(newFilter) : newFilter;
				}, null);
			return portfolioItemFilter ? releaseFilter.and(leafFilter).and(portfolioItemFilter) : null;
		},
		loadUserStories: function(){
			/** note: lets say the lowest portfolioItemType is 'Feature'. If we want to get child user stories under a particular Feature,
					we must query and fetch using the Feature field on the UserStories, NOT PortfolioItem. PortfolioItem field only applies to the 
					user Stories directly under the feature
				*/
			var me = this,
				lowestPortfolioItemType = me.PortfolioItemTypes[0],
				newMatrixUserStoryBreakdown = {},
				newMatrixProjectMap = {},
				newProjectOIDNameMap = {}; //filter out teams that entered a team commit but have no user stories AND are not a scrum under the scrum-group
				
			return Q.all(_.map(_.chunk(me.PortfolioItemStore.getRange(), 20), function(portfolioItemRecords){
				var filter = me.getUserStoryQuery(portfolioItemRecords),
					config = {
						model: 'HierarchicalRequirement',
						filters: filter ? [filter] : [],
						fetch:['Name', 'ObjectID', 'Project', 'Release', 'PlanEstimate', 'FormattedID', 'ScheduleState', lowestPortfolioItemType],
						context: {
							workspace:me.getContext().getWorkspace()._ref,
							project: null
						}
					};
				return me.parallelLoadWsapiStore(config).then(function(store){
					_.each(store.getRange(), function(storyRecord){
						var portfolioItemName = storyRecord.data[lowestPortfolioItemType].Name,
							projectName = storyRecord.data.Project.Name,
							projectOID = storyRecord.data.Project.ObjectID;		
						if(!newMatrixUserStoryBreakdown[projectName]) 
							newMatrixUserStoryBreakdown[projectName] = {};
						if(!newMatrixUserStoryBreakdown[projectName][portfolioItemName]) 
							newMatrixUserStoryBreakdown[projectName][portfolioItemName] = [];
						newMatrixUserStoryBreakdown[projectName][portfolioItemName].push(storyRecord.data);						
						newMatrixProjectMap[projectName] = storyRecord.data.Project.ObjectID; //this gets called redundantly each loop
						newProjectOIDNameMap[projectOID] = projectName;
					});
					store.destroyStore();
				});
			}))
			.then(function(){
				me.MatrixUserStoryBreakdown = newMatrixUserStoryBreakdown;
				me.MatrixProjectMap = newMatrixProjectMap;
				me.ProjectOIDNameMap = newProjectOIDNameMap;
						
					//always show the teams under the scrum-group that have teamMembers > 0, even if they are not contributing this release
				_.each(me.ProjectsWithTeamMembers, function(projectRecord){
					var projectName = projectRecord.data.Name,
						projectOID = projectRecord.data.ObjectID;
					if(!me.MatrixProjectMap[projectName]) me.MatrixProjectMap[projectName] = projectRecord.data.ObjectID;
					if(!me.MatrixUserStoryBreakdown[projectName]) me.MatrixUserStoryBreakdown[projectName] = {};
					me.ProjectOIDNameMap[projectOID] = projectName;
				});
				
				// var projectOIDsToGet = [];
				// _.each(me.PortfolioItemStore.getRange(), function(portfolioItemRecord){
					// var teamCommits = me.getTeamCommits(portfolioItemRecord);
					// _.each(teamCommits, function(teamCommit, projectOID){
						// if(!me.ProjectOIDNameMap[projectOID] && !_.contains(projectOIDsToGet, projectOID)){
							// projectOIDsToGet.push(projectOID);
						// }
					// });
				// });
				// return Promise.all(_.map(projectOIDsToGet, function(oid){
					// return me.loadProject(oid).then(function(projectRecord){
						// me.ProjectOIDNameMap[projectRecord.data.ObjectID] = projectRecord.data.Name;
						// me.MatrixProjectMap[projectRecord.data.Name] = projectRecord.data.ObjectID;
						// me.MatrixUserStoryBreakdown[projectRecord.data.Name] = {};
					// });
				// }));
			});
		},		
			
		/**___________________________________ TEAM COMMITS STUFF ___________________________________**/	
		getTeamCommits: function(portfolioItemRecord){
			var me=this,
				tcString = portfolioItemRecord.data.c_TeamCommits;
			try{ return JSON.parse(atob(tcString)) || {}; }
			catch(e){ return {}; }
		},	
		getTeamCommit: function(portfolioItemRecord, projectName){	
			var me=this,
				projectID = me.MatrixProjectMap[projectName],
				teamCommits = me.getTeamCommits(portfolioItemRecord);
			return teamCommits[projectID] || {};
		},	
		setTeamCommitsField: function(portfolioItemRecord, projectName, field, value){
			var me=this,
				projectID = me.MatrixProjectMap[projectName],
				teamCommits = me.getTeamCommits(portfolioItemRecord),
				deferred = Q.defer();	
			if(!teamCommits[projectID]) teamCommits[projectID] = {};
			teamCommits[projectID][field] = value;		
			var str = btoa(JSON.stringify(teamCommits, null, '\t'));
			if(str.length >= 32768) 
				deferred.reject('TeamCommits field for ' + portfolioItemRecord.data.FormattedID + ' ran out of space! Cannot save');
			else {
				portfolioItemRecord.set('c_TeamCommits', str);
				portfolioItemRecord.save({ 
					callback:function(record, operation, success){
						if(!success) deferred.reject('Failed to modify PortfolioItem ' + portfolioItemRecord.data.FormattedID);
						else deferred.resolve(portfolioItemRecord);
					}
				});
			}
			return deferred.promise;
		},
	
		/**___________________________________ EVENT HANDLING ___________________________________*/
		getGridHeight: function(){
/* 			var me = this, 
				iframe = Ext.get(window.frameElement);
			return iframe.getHeight() - me.down('#navbox').getHeight() - 20;  */ 
			return 800;
		},
		getGridWidth: function(columnCfgs){
/* 			var me = this; 
			if(!me.MatrixGrid) return;
			else return Math.min(
				_.reduce(columnCfgs, function(item, sum){ return sum + item.width; }, 20), 
				window.innerWidth - 20
			);  */  
			return 800;
		},	
		changeGridSize: function(){
			var me=this;
			if(!me.MatrixGrid) return;
			else me.MatrixGrid.setSize(me.getGridWidth(me.MatrixGrid.config.columnCfgs), me.getGridHeight());
		},	
		initGridResize: function(){
			var me=this;
			if(me.addWindowEventListener){
				me.addWindowEventListener('resize', me.changeGridSize.bind(me));
			}
		},	

		/**___________________________________ UTILITY FUNCTIONS ___________________________________*/
		clearToolTip: function(){
			var me = this;
			if(me.tooltip){
				me.tooltip.panel.hide();
				me.tooltip.triangle.hide();
				me.tooltip.panel.destroy();
				me.tooltip.triangle.destroy();
				me.tooltip = null;
			}
		},	
		getDistanceFromBottomOfScreen: function(innerY){
			var me = this, 
				iframe = window.frameElement,
				iframeOffsetY = window.parent.getScrollY() + iframe.getBoundingClientRect().top,
				actualY = iframeOffsetY + innerY;
			return window.parent.getWindowHeight() - actualY;   
		},
			
		getIntersectingUserStoriesData: function(portfolioItemRecord, projectName){
			return (this.MatrixUserStoryBreakdown[projectName] || {})[portfolioItemRecord.data.Name] || [];
		},
		getTotalUserStoryPoints: function(userStoriesData){
			return _.reduce(userStoriesData, function(sum, userStoryData){ return sum + (userStoryData.PlanEstimate || 0); }, 0);
		},
		getCompletedUserStoryPoints: function(userStoriesData){
			return _.reduce(userStoriesData, function(sum, userStoryData){ 
				return sum + ((userStoryData.ScheduleState == 'Completed' || userStoryData.ScheduleState == 'Accepted') ? 
					(userStoryData.PlanEstimate || 0) : 0);
			}, 0);
		},
					
		getCellCls: function(config){
			var me=this,
				colorClassBase = ' intel-team-commits-',
				cls = '';

			if(me.ViewMode == 'Normal'){
				switch(config.commitment){
					case 'Undecided': cls = colorClassBase + 'WHITE'; break;
					case 'N/A': cls = colorClassBase + 'GREY'; break;
					case 'Committed': cls = colorClassBase + 'GREEN'; break;
					case 'Not Committed': cls = colorClassBase + 'RED'; break;
					default: cls = colorClassBase + 'WHITE'; break;
				}
			}
			else if(me.ViewMode == '% Done') cls += '';
			
			if(config.expected && config.ceComment && config.featurestatus) cls += ' manager-expected-feature-comment-cell-small';
			else if (config.expected && config.ceComment) cls += ' manager-expected-comment-cell-small';
			else if (config.ceComment && config.featurestatus) cls += ' manager-comment-feature-cell-small';
			else if(config.expected && config.featurestatus) cls += ' manager-expected-feature-cell-small';
			else if(config.expected) cls += ' manager-expected-cell-small';
			else if(config.featurestatus) cls += ' manager-feature-cell-small';
			else if(config.ceComment) cls += ' manager-comment-cell-small';
			
			return cls;
		},
		getCellBackgroundColor: function(config){
			var me=this;		
			if(me.ViewMode == 'Normal' || config.userStoriesData.length === 0) return '';
			else if(me.ViewMode == '% Done') return me.getRallyReleaseColor(me.ReleaseRecord, config.completedPoints, config.totalPoints);
		},
		getCellInnerHTML: function(config){
			var me=this;			
			if(me.ViewMode == 'Normal') return config.userStoriesData.length;
			else if(me.ViewMode == '% Done'){
				if(config.userStoriesData.length === 0) return '-';
				var percentDone = (100*config.completedPoints/config.totalPoints>>0);
				return '<span title="' + config.completedPoints + '/' + config.totalPoints + ' Points Completed">' + 
					percentDone + '%</span>';
			}	
		},
		areColorsTheSame: function(color1, color2){
			var me=this,
				nums1 = (color1 || '').match(/\d+\.?\d*/g) || [],
				nums2 = (color2 || '').match(/\d+\.?\d*/g) || [];
			if(nums1.length != nums2.length) return false;
			if(_.some(nums1, function(num1, index){ return Math.abs(num1 - nums2[index])*100>>0 > 0; })) return false;
			return true;
		},
		updateCell: function(portfolioItemRecord, projectName, rowIndex, columnIndex){
			var me=this;
			
			var	tableRowDOM = me.MatrixGrid.view.getNode(rowIndex),
				td = tableRowDOM.childNodes[columnIndex],
				teamCommit = me.getTeamCommit(portfolioItemRecord, projectName),
				userStoriesData = me.getIntersectingUserStoriesData(portfolioItemRecord, projectName),
				config = {
					userStoriesData: userStoriesData,
					completedPoints: (100*me.getCompletedUserStoryPoints(userStoriesData)>>0)/100,
					totalPoints: (100*me.getTotalUserStoryPoints(userStoriesData)>>0)/100,
					expected: teamCommit.Expected || false,
					featurestatus: teamCommit.FeatureStatus || false,
					ceComment: !!teamCommit.CEComment || false,
					commitment: teamCommit.Commitment || 'Undecided'
				},
				
				colorClassBase = 'intel-team-commits-',
				expectedClass = 'manager-expected-cell-small',
				featureClass = 'manager-feature-cell-small',
				commentClass = 'manager-comment-cell-small',
				expectedCommentClass = 'manager-expected-comment-cell-small',
				
				newCls = me.getCellCls(config),
				newColorClass = (/intel-team-commits-[A-Z]+/.exec(newCls) || [''])[0],
				newBackgroundColor = me.getCellBackgroundColor(config),
				newInnerHTML = me.getCellInnerHTML(config),
				
				classList = td.classList,
				oldBackgroundColor = td.style.backgroundColor,
				oldInnerHTML = td.childNodes[0].innerHTML,
				oldExpected = classList.contains(expectedClass),
				oldFeatureHelp = classList.contains(featureClass),
				oldComment = classList.contains(commentClass),
				oldExpectedComment = classList.contains(expectedCommentClass),
				oldColorClass = _.find(classList, function(c){ return c.indexOf(colorClassBase) > -1; }) || '';
			
			if(((config.expected && config.featurestatus && !config.ceComment) && !(oldExpected && !oldComment && !oldExpectedComment)) ||
					((!config.expected && config.featurestatus && config.ceComment) && !(!oldExpected && oldComment && !oldExpectedComment)) ||
					((config.expected && config.featurestatus && config.ceComment) && !(!oldExpected && !oldComment && oldExpectedComment)) ||
					(!me.areColorsTheSame(newBackgroundColor, oldBackgroundColor)) ||
					(newColorClass != oldColorClass) || 
					(newInnerHTML != oldInnerHTML)){		
				//styles
				td.style.backgroundColor = newBackgroundColor;
				//classes
				if(oldColorClass) td.classList.remove(oldColorClass);
				_.each(newCls.split(' '), function(cls){ if(cls.length) td.classList.add(cls); });
				//innerHTML
				td.childNodes[0].innerHTML = newInnerHTML;
				return true;
			}
			else return false;
		},
		
		isProjectNotFullyDispositioned: function(projectName){
			var me=this;
			return _.some(me.PortfolioItemStore.getRange(), function(portfolioItemRecord){
				var teamCommit = me.getTeamCommit(portfolioItemRecord, projectName);
				return !teamCommit.Commitment || teamCommit.Commitment == 'Undecided';
			});
		},
		getProjectHeaderCls: function(projectName){
			var me=this;
			if(me.ViewMode == 'Normal'){
				return me.isProjectNotFullyDispositioned(projectName) ? ' not-dispositioned-project' : ' dispositioned-project';
			} 
			else return ''; //should these get green/red/grey/white
		},
		columnHeaderItem: function(projectName){ //the % DONE cell in the header cell when in % DONE viewing mode
			var me=this;
			var config = _.reduce(me.MatrixUserStoryBreakdown[projectName], function(sumConfig, userStoriesData){
				return {
					userStoriesData: sumConfig.userStoriesData.concat(userStoriesData),
					completedPoints: sumConfig.completedPoints + (100*me.getCompletedUserStoryPoints(userStoriesData)>>0)/100,
					totalPoints: sumConfig.totalPoints + (100*me.getTotalUserStoryPoints(userStoriesData)>>0)/100
				};
			},{
				userStoriesData: [],
				completedPoints: 0,
				totalPoints: 0
			});
			var style = 'style="background-color:' + me.getCellBackgroundColor(config) + '"',
				innerHTML = me.getCellInnerHTML(config);
			return '<div class="project-percentage-complete" ' + style + '>' + innerHTML + '</div>';
		},
		updateGridHeader: function(projectName){
			var me=this,
				column = _.find(me.MatrixGrid.view.getGridColumns(), function(column){ return column.text == projectName; }),
				possibleClasses = ['not-dispositioned-project', 'dispositioned-project'],
				shouldHaveItems = me.ViewMode === '% Done';
			_.each(possibleClasses, function(cls){ column.el.removeCls(cls); });
			while(column.el.dom.childNodes.length > 1) column.el.last().remove(); //remove % done before re-adding it.
			if(shouldHaveItems) Ext.DomHelper.append(column.el, me.columnHeaderItem(projectName));
			column.el.addCls(me.getProjectHeaderCls(projectName));
		},
	
		updateTotalPercentCell: function(matrixRecord, index){
			var me=this,
				portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(piRecord){ 
					return piRecord.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
				});
			if(me.ViewMode != '% Done' || !portfolioItemRecord) return;
			var config = _.reduce(_.sortBy(_.keys(me.MatrixUserStoryBreakdown)), function(sumConfig, projectName){
				var teamCommit = me.getTeamCommit(portfolioItemRecord, projectName),
					userStoriesData = me.getIntersectingUserStoriesData(portfolioItemRecord, projectName);
				return {
					userStoriesData: sumConfig.userStoriesData.concat(userStoriesData),
					completedPoints: sumConfig.completedPoints + (100*me.getCompletedUserStoryPoints(userStoriesData)>>0)/100,
					totalPoints: sumConfig.totalPoints + (100*me.getTotalUserStoryPoints(userStoriesData)>>0)/100
				};
			},{
				userStoriesData: [],
				completedPoints: 0,
				totalPoints: 0
			});
			var style = 'style="background-color:' + me.getCellBackgroundColor(config) + '"',
				innerHTML = me.getCellInnerHTML(config),
				td = Ext.get(me.MatrixGrid.getView().lockedView.getNode(index)).last(),
				div = td.last();
			td.dom.setAttribute('style', style);
			div.dom.innerHTML = innerHTML;
		},
		
		isPortfolioItemNotCommittedOrHasNoStories: function(portfolioItemRecord){
			var me=this,
				portfolioItemName = portfolioItemRecord.data.Name,
				teamCommits = me.getTeamCommits(portfolioItemRecord);
			return _.some(teamCommits, function(projData, projectOID){ 
				return projData.Commitment == 'Not Committed' && me.ProjectOIDNameMap[projectOID]; 
			}) || 
				!_.reduce(me.MatrixUserStoryBreakdown, function(sum, portfolioItemMap){
					return sum + (portfolioItemMap[portfolioItemName] || []).length;
				}, 0);
		},		
		
		/**___________________________________ LOADING AND RELOADING ___________________________________*/
		showGrids: function(){
			var me=this;
			if(!me.MatrixGrid) me.renderMatrixGrid();
		},	
		updateGrids: function(){
			var me=this;
			if(me.PortfolioItemStore){
				if(me.MatrixGrid && me.MatrixGrid.store) me.MatrixGrid.store.intelUpdate();
			}
		},
		clearEverything: function(){
			var me=this;
			
			me.clearToolTip();
			if(me.MatrixGrid) {
				me.MatrixGrid.up().remove(me.MatrixGrid);
				me.MatrixGrid = undefined;
			}
		},
		reloadStores: function(){
			var me = this;
			return me.loadPortfolioItems().then(function(){ return me.loadUserStories(); });
		},
		
		reloadEverything: function(){
			var me=this;

			me.setLoading('Loading Data');
			me.enqueue(function(done){
				me.reloadStores()
					.then(function(){
						me.clearEverything();
						if(!me.ReleasePicker){
							me.renderReleasePicker();
							me.renderClickModePicker();
							me.renderViewModePicker();
							me.renderClearFiltersButton();
							me.renderMatrixLegend();
						}				
					})
					.then(function(){ me.updateGrids(); })
					.then(function(){ me.showGrids(); })
					.fail(function(reason){ me.alert('ERROR', reason); })
					.then(function(){ me.setLoading(false); done(); })
					.done();
			}, 'ReloadAndRefreshQueue'); //eliminate race conditions between manual _reloadEverything and interval _refreshDataFunc
		},
		
		/**___________________________________ REFRESHING DATA ___________________________________*/	
		refreshDataFunc: function(){
			var me=this;
			me.enqueue(function(done){
				me.reloadStores()
					.then(function(){ me.updateGrids(); })
					.then(function(){ me.showGrids(); })
					.fail(function(reason){ me.alert('ERROR', reason); })
					.then(function(){ done(); })
					.done();
			}, 'ReloadAndRefreshQueue');
		},	
		clearRefreshInterval: function(){
			var me=this;
			if(me.RefreshInterval){ 
				clearInterval(me.RefreshInterval); 
				me.RefreshInterval = undefined; 
			}	
		},
		setRefreshInterval: function(){
			var me=this;
			me.clearRefreshInterval();
			me.RefreshInterval = setInterval(function(){ me.refreshDataFunc(); }, 25000);
		},
			
		/**___________________________________ LAUNCH ___________________________________*/	
		launch: function(){
			var me = this;
			me.setLoading('Loading configuration');
			me.ClickMode = 'Details';
			me.ViewMode = Ext.Object.fromQueryString(window.parent.location.href.split('?')[1] || '').viewmode === 'percent_done' ? '% Done' : 'Normal';
			me.initDisableResizeHandle();
			me.initFixRallyDashboard();
			me.initGridResize();
			if(!me.getContext().getPermissions().isProjectEditor(me.getContext().getProject())){
				me.setLoading(false);
				me.alert('ERROR', 'You do not have permissions to edit this project');
				return;
			}	
			me.configureIntelRallyApp()
				.then(function(){
					var scopeProject = me.getContext().getProject();
					return me.loadProject(scopeProject.ObjectID);
				})
				.then(function(scopeProjectRecord){
					me.ProjectRecord = scopeProjectRecord;
					return Q.all([
						me.projectInWhichScrumGroup(me.ProjectRecord)
							.then(function(scrumGroupRootRecord){
								if(scrumGroupRootRecord && me.ProjectRecord.data.ObjectID == scrumGroupRootRecord.data.ObjectID){
									me.ScrumGroupRootRecord = scrumGroupRootRecord;
									return me.loadScrumGroupPortfolioProject(me.ScrumGroupRootRecord)
										.then(function(scrumGroupPortfolioProject){
											if(!scrumGroupPortfolioProject) return Q.reject('Invalid portfolio location');
											me.ScrumGroupPortfolioProject = scrumGroupPortfolioProject;
										});
								} 
								else return Q.reject('You are not scoped to a valid project');
							}),
						me.loadAppsPreference()
							.then(function(appsPref){
								me.AppsPref = appsPref;
								var twelveWeeks = 1000*60*60*24*7*12;
								return me.loadReleasesAfterGivenDate(me.ProjectRecord, (new Date()*1 - twelveWeeks));
							})
							.then(function(releaseRecords){
								me.ReleaseRecords = releaseRecords;
								var currentRelease = me.getScopedRelease(releaseRecords, me.ProjectRecord.data.ObjectID, me.AppsPref);
								if(currentRelease) me.ReleaseRecord = currentRelease;
								else return Q.reject('This project has no releases.');
							}),
						me.loadProjectsWithTeamMembers(me.ProjectRecord)
							.then(function(projectsWithTeamMembers){ 
								me.ProjectsWithTeamMembers = projectsWithTeamMembers; 
							}),
						me.loadAllChildrenProjects()
							.then(function(allProjects){ 
								me.AllProjects = allProjects; 
							}),
						me.setCustomAppObjectID('Intel.SAFe.ArtCommitMatrix')
					]);
				})
				.then(function(){ 
					me.setRefreshInterval(); 
					return me.reloadEverything(); 
				})
				.fail(function(reason){
					me.setLoading(false);
					me.alert('ERROR', reason);
				})
				.done();
		},
		
		/**___________________________________ NAVIGATION AND STATE ___________________________________*/
		releasePickerSelected: function(combo, records){
			var me=this, pid = me.ProjectRecord.data.ObjectID;
			if(me.ReleaseRecord.data.Name === records[0].data.Name) return;
			me.setLoading("Saving Preference");
			me.ReleaseRecord = _.find(me.ReleaseRecords, function(rr){ return rr.data.Name == records[0].data.Name; });
			if(typeof me.AppsPref.projs[pid] !== 'object') me.AppsPref.projs[pid] = {};
			me.AppsPref.projs[pid].Release = me.ReleaseRecord.data.ObjectID;
			me.saveAppsPreference(me.AppsPref)
				.then(function(){ me.reloadEverything(); })
				.done();
		},				
		renderReleasePicker: function(){
			var me=this;
			me.ReleasePicker = me.down('#navboxLeftVert').add({
				xtype:'intelreleasepicker',
				id: 'releasePicker',
				labelWidth: 70,
				width: 250,
				releases: me.ReleaseRecords,
				currentRelease: me.ReleaseRecord,
				listeners: { select: me.releasePickerSelected.bind(me) }
			});
		},	
		clickModePickerSelected: function(combo, records){
			var me=this, value = records[0].data.ClickMode;
			if(value === me.ClickMode) return;
			else me.ClickMode = value;
			me.clearToolTip();
		},				
		renderClickModePicker: function(){
			var me=this;
			me.ClickModePicker = me.down('#navboxLeftVert').add({
				xtype:'intelfixedcombo',
				fieldLabel:'Click Mode',
				id:'modePicker',
				labelWidth: 70,
				width: 250,
				store: Ext.create('Ext.data.Store', {
					fields:['ClickMode'],
					data: [
						{ClickMode:'Flag'},
						{ClickMode:'Comment'},
						{ClickMode:'Details'},
						{ClickMode:'Feature Help Needed'}
					]
				}),
				displayField: 'ClickMode',
				value:me.ClickMode,
				listeners: { select: me.clickModePickerSelected.bind(me) }
			});
		},	
		viewModePickerSelected: function(combo, records){
			var me=this, value = records[0].data.ViewMode;
			if(value === me.ViewMode) return;
			else me.ViewMode = value;
			me.clearToolTip();
			me.setLoading('Please Wait');
			setTimeout(function(){
				if(me.MatrixGrid){
					if(me.ViewMode == '% Done') me.MatrixGrid.columns[5].show();
					else me.MatrixGrid.columns[5].hide();
					if(me.MatrixGrid.store) me.MatrixGrid.store.intelUpdate();
				}
				me.setLoading(false);
			}, 0);
		},				
		renderViewModePicker: function(){
			var me=this;
			me.ViewModePicker = me.down('#navboxLeftVert').add({
				xtype:'intelfixedcombo',
				fieldLabel:'View Mode',
				id:'viewPicker',
				labelWidth: 70,
				width: 250,
				store: Ext.create('Ext.data.Store', {
					fields:['ViewMode'],
					data: [
						{ViewMode:'Normal'},
						{ViewMode:'% Done'}
					]
				}),
				displayField: 'ViewMode',
				value: me.ViewMode,
				listeners: { select: me.viewModePickerSelected.bind(me) }
			});
		},	
		clearFiltersButtonClicked: function(){
			var me=this;
			if(me.MatrixGrid){
				me.clearToolTip();
				_.invoke(Ext.ComponentQuery.query('intelgridcolumnfilter', me.MatrixGrid), 'clearFilters');
				me.MatrixGrid.store.fireEvent('refresh', me.MatrixGrid.store);
			}
		},
		renderClearFiltersButton: function(){
			var me=this;
			me.ClearFiltersButton = me.down('#navboxLeftVert').add({
				xtype:'button',
				text:'Remove Filters',
				id: 'manualRefreshButton',
				cls: 'intel-button',
				width:110,
				listeners:{ click: me.clearFiltersButtonClicked.bind(me) }
			});
		},
		renderMatrixLegend: function(){
			var me=this;
			me.MatrixLegend = me.down('#navboxRight').add({
				xtype:'container',
				width:150,	
				layout: {
					type:'vbox',
					align:'stretch',
					pack:'start'
				},
				border:true,
				frame:false,
				items: _.map(['Committed', 'Not Committed', 'N/A', 'Undefined', 'Expected', 'CE Comment','Feature Help Needed'], function(name){
					var color;
					if(name === 'Undecided') color='white';
					if(name === 'N/A') color='rgba(224, 224, 224, 0.50)'; //grey
					if(name === 'Committed') color='rgba(0, 255, 0, 0.50)';//green
					if(name === 'Not Committed') color='rgba(255, 0, 0, 0.50)';//red
					if(name === 'Expected') color='rgba(251, 255, 0, 0.50)'; //yellow
					if(name === 'CE Comment') color='rgba(76, 76, 255, 0.50)'; //blue
					if(name === 'Feature Help Needed') color='rgba(170, 92, 183, 0.50)'; //purple
					return {
						xtype: 'container',
						width: 150,
						border:false,
						frame:false,
						html:'<div class="intel-legend-item">' + name + 
							': <div style="background-color:' + color + '" class="intel-legend-dot"></div></div>'
					};
				})
			});
		},

		/************************************************************* RENDER ********************************************************************/
		renderMatrixGrid: function(){
			var me = this,
				/* MoSCoWRanks = ['Must Have', 'Should Have', 'Could Have', 'Won\'t Have', 'Undefined', ''], */
				sortedPortfolioItems = _.sortBy(me.PortfolioItemStore.getRange(), function(p){ return p.data.DragAndDropRank; }),
				matrixRecords = _.map(sortedPortfolioItems, function(portfolioItemRecord, index){
					return {
						PortfolioItemObjectID: portfolioItemRecord.data.ObjectID,
						PortfolioItemRank: index + 1,
						PortfolioItemName: portfolioItemRecord.data.Name,
						PortfolioItemFormattedID: portfolioItemRecord.data.FormattedID,
						PortfolioItemPlannedEnd: portfolioItemRecord.data.PlannedEndDate*1,
						TopPortfolioItemName: me.PortfolioItemMap[portfolioItemRecord.data.ObjectID]/* ,
						MoSCoW: portfolioItemRecord.data.c_MoSCoW || 'Undefined' */
					};
				}),
				makeDoSortFn = function(fn){
					return function(direction){
						me.MatrixGrid.store.sort({
							sorterFn: function(r1, r2){
								var val1 = fn(r1), val2 = fn(r2);
								return (direction=='ASC' ? 1 : -1) * ((val1 < val2) ? -1 : (val1 === val2 ? 0 : 1));
							}
						});
					};
				};		

			var matrixStore = Ext.create('Intel.lib.component.Store', {
				data: matrixRecords,
				model: 'CommitsMatrixPortfolioItem',
				autoSync:true,
				limit:Infinity,
				proxy: {
					type:'intelsessionstorage',
					id: 'Session-proxy-' + Math.random()
				},
				disableMetaChangeEvent: true,
				intelUpdate: function(){			
					var projectNames = _.sortBy(_.keys(me.MatrixUserStoryBreakdown));
					_.each(projectNames, function(projectName){ me.updateGridHeader(projectName); });
					_.each(matrixStore.getRange(), function(matrixRecord, rowIndex){
						me.updateTotalPercentCell(matrixRecord, rowIndex);
						var refreshWholeRow = false,
							portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(portfolioItemRecord){
								return portfolioItemRecord.data.ObjectID == matrixRecord.data.PortfolioItemObjectID;
							});
							// if(matrixRecord.data.MoSCoW != portfolioItemRecord.data.c_MoSCoW)
							// matrixRecord.set('MoSCoW', portfolioItemRecord.data.c_MoSCoW || 'Undefined'); 
						_.each(projectNames, function(projectName, colIndex){
							var changedContents = me.updateCell(portfolioItemRecord, projectName, rowIndex, colIndex);
							if(changedContents) refreshWholeRow = true;
						});
						if(refreshWholeRow) me.MatrixGrid.view.refreshNode(rowIndex);
					});
					matrixStore.fireEvent('refresh', matrixStore);
				}
			});

			var lockedColumns = [/* {
				text:'MoSCoW', 
				dataIndex:'MoSCoW',
				tdCls: 'moscow-cell intel-editor-cell',	
				width:100,
				tooltip:'Must Have, Should Have, Could Have, Won\'t Have',
				tooltipType:'title',
				editor:{
					xtype:'intelfixedcombo',
					store: ['Must Have', 'Should Have', 'Could Have', 'Won\'t Have', 'Undefined']
				},
				sortable:true,
				locked:true,			
				doSort: makeDoSortFn(function(record){ return MoSCoWRanks.indexOf(record.data.MoSCoW); }),
				renderer:function(val, meta){
					if(val == 'Must Have') meta.tdCls += ' must-have';
					if(val == 'Should Have') meta.tdCls += ' should-have';
					if(val == 'Could Have') meta.tdCls += ' could-have';
					if(val == 'Won\'t Have') meta.tdCls += ' wont-have';
					return val || 'Undefined'; 
				},	
				items:[{ 
					xtype:'intelgridcolumnfilter',
					sortFn: function(MoSCoW){ return MoSCoWRanks.indexOf(MoSCoW); }
				}]	
			}, */{
				text: 'Rank',
				dataIndex: 'PortfolioItemRank',
				width: 50,
				sortable:true,
				locked:true
			},{
				text:'#', 
				dataIndex:'PortfolioItemFormattedID',
				width:50,
				sortable:true,
				locked:true,
				renderer:function(formattedID, meta, matrixRecord){
					var portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ return item.data.FormattedID == formattedID; });
					var totalFeatureHelp = _.filter(me.getTeamCommits(portfolioItemRecord), function(val,key){return val.FeatureStatus === true; });
					var featureHelpCount = totalFeatureHelp.length > 0 ? totalFeatureHelp.length : "";
					if(me.ViewMode == 'Normal'){
						if(me.isPortfolioItemNotCommittedOrHasNoStories(portfolioItemRecord)) meta.tdCls += ' not-committed-portfolio-item';
						if(totalFeatureHelp.length > 0 ) meta.tdCls += ' manager-feature-cell';
					}
					if(portfolioItemRecord.data.Project){
						return '<div class="feature-porfolio-items"><div class="feature-help">'+ featureHelpCount + '</div>' + '<div class="porfolio-items"><a href=' + me.BaseUrl + '/#/' + portfolioItemRecord.data.Project.ObjectID + 'd/detail/portfolioitem/' + 
							me.PortfolioItemTypes[0] + '/' + portfolioItemRecord.data.ObjectID + ' target="_blank">' + formattedID + '</a></div></div>';
					}
					else return name;
				}
			},{
				text:me.PortfolioItemTypes[0], 
				dataIndex:'PortfolioItemName',
				width:200,
				locked:true,
				sortable:true,
				renderer: function(value, metaData) {
					metaData.tdAttr = 'title="' + value + '"';
					return value;
				}
			},{
				text: me.PortfolioItemTypes.slice(-1)[0], 
				dataIndex:'TopPortfolioItemName',
				width:90,
				sortable:true,
				locked:true,
				items:[{ xtype:'intelgridcolumnfilter' }]
			},{
				text:'Planned End',
				dataIndex:'PortfolioItemPlannedEnd',
				width:60,
				locked:true,
				sortable:true,
				renderer: function(date){ return (date ? 'ww' + me.getWorkweek(date) : '-'); },
				items:[{ 
					xtype:'intelgridcolumnfilter', 
					convertDisplayFn: function(dateVal){ return dateVal ? 'ww' + me.getWorkweek(dateVal) : undefined; }
				}]
			},{
				text:'Total % Done',
				dataIndex:'PortfolioItemObjectID',
				width:50,
				locked:true,
				sortable:true,
				hidden: me.ViewMode !== '% Done',
				doSort: makeDoSortFn(function(record){
					var lockedView = me.MatrixGrid.getView().lockedView,
						store = this.up('grid').getStore();
					return parseInt(Ext.get(lockedView.getNode(store.indexOf(item1))).last().dom.innerText, 10) || 0;
				}),
				renderer: function(obejctID, metaData, matrixRecord, row, col){
					if(me.ViewMode != '% Done') return;
					var portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ return item.data.ObjectID == obejctID; });
					if(!portfolioItemRecord) return;
					var config = _.reduce(_.sortBy(_.keys(me.MatrixUserStoryBreakdown)), function(sumConfig, projectName){
						var teamCommit = me.getTeamCommit(portfolioItemRecord, projectName),
							userStoriesData = me.getIntersectingUserStoriesData(portfolioItemRecord, projectName);
						return {
							userStoriesData: sumConfig.userStoriesData.concat(userStoriesData),
							completedPoints: sumConfig.completedPoints + (100*me.getCompletedUserStoryPoints(userStoriesData)>>0)/100,
							totalPoints: sumConfig.totalPoints + (100*me.getTotalUserStoryPoints(userStoriesData)>>0)/100
						};
					},{
						userStoriesData: [],
						completedPoints: 0,
						totalPoints: 0
					});
					metaData.tdAttr += 'style="background-color:' + me.getCellBackgroundColor(config) + '"';
					return me.getCellInnerHTML(config);
				}
			}];
		
			var teamColumnCfgs = [];
			_.each(_.sortBy(_.keys(me.MatrixUserStoryBreakdown)), function(projectName){
				teamColumnCfgs.push({
					text: projectName,
					dataIndex:'PortfolioItemObjectID',
					tdCls: 'intel-editor-cell',
					cls: ' matrix-subheader-cell ' + me.getProjectHeaderCls(projectName),
					width:50,
					maxHeight:80,
					tooltip:projectName,
					tooltipType:'title',
					editor:'textfield',
					align:'center',
					draggable:false,
					menuDisabled:true,
					sortable:false,
					resizable:false,
					renderer: function(obejctID, metaData, matrixRecord, row, col){
						var portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ return item.data.ObjectID == obejctID; });
						if(!portfolioItemRecord) return;
						var teamCommit = me.getTeamCommit(portfolioItemRecord, projectName),
							userStoriesData = me.getIntersectingUserStoriesData(portfolioItemRecord, projectName),
							config = {
								userStoriesData: userStoriesData,
								completedPoints: (100*me.getCompletedUserStoryPoints(userStoriesData)>>0)/100,
								totalPoints: (100*me.getTotalUserStoryPoints(userStoriesData)>>0)/100,
								expected: teamCommit.Expected || false,
								featurestatus: teamCommit.FeatureStatus || false,
								ceComment: !!teamCommit.CEComment || false,
								commitment: teamCommit.Commitment || 'Undecided'
							};
						metaData.tdCls += me.getCellCls(config);
						metaData.tdAttr += 'style="background-color:' + me.getCellBackgroundColor(config) + '"';
						return me.getCellInnerHTML(config);
					}
				});
			});
			if(me.HorizontalGroupingConfig.enabled){
				var allTeamTypeInfos = me.getAllHorizontalTeamTypeInfos(me.AllProjects);
				teamColumnCfgs = _.map(_.groupBy(_.sortBy(_.map(teamColumnCfgs, 
					function(teamColumnCfg){
						return {
							teamTypeInfo: _.find(allTeamTypeInfos, function(tti){ return tti.projectRecord.data.Name === teamColumnCfg.text; }),
							columnCfg: teamColumnCfg
						};
					}),
					function(item){ 
						var horizontal = item.teamTypeInfo ? item.teamTypeInfo.horizontal : 'null';
						return (horizontal === 'null' ? '~~~' : horizontal) + item.columnCfg.text; 
					}),
					function(item){ return item.teamTypeInfo ? item.teamTypeInfo.horizontal : 'null'; }),
					function(items, horizontal){
						return {
							text: horizontal === 'null' ? 'OTHER' : horizontal,
							draggable:false,
							menuDisabled:true,
							sortable:false,
							resizable:false,
							columns: _.pluck(items, 'columnCfg')
						};
					});
			}
			var columns = _.map(lockedColumns.concat(teamColumnCfgs), function(colDef){ return _.merge({}, COLUMN_DEFAULTS, colDef); });
			
			me.MatrixGrid = me.add({
				xtype: 'grid',
				width: me.getGridWidth(columns),
				height: me.getGridHeight(),
				scroll:'both',
				resizable:false,
				columns: columns,
				disableSelection: true,
				plugins: [ 'intelcellediting' ],
				viewConfig: {
					xtype:'inteltableview',
					preserveScrollOnRefresh:true
				},
				listeners: {
					sortchange: function(){ me.clearToolTip(); },
					beforeedit: function(editor, e){
						var projectName = e.column.text,
							matrixRecord = e.record;
							
						//if(projectName == 'MoSCoW') return;
						if(me.ClickMode == 'Flag'){
							me.MatrixGrid.setLoading('Saving');
							me.enqueue(function(done){
								me.loadPortfolioItemByOrdinal(matrixRecord.data.PortfolioItemObjectID, 0)
									.then(function(portfolioItemRecord){
										var tcae = me.getTeamCommit(portfolioItemRecord, projectName);
										return me.setTeamCommitsField(portfolioItemRecord, projectName, 'Expected', !tcae.Expected);
									})
									.then(function(portfolioItemRecord){
										var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
											return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
										});
										storePortfolioItemRecord.data.c_TeamCommits = portfolioItemRecord.data.c_TeamCommits;
										me.MatrixGrid.view.refreshNode(matrixStore.indexOf(matrixRecord));
									})
									.fail(function(reason){ me.alert('ERROR', reason); })
									.then(function(){
										me.MatrixGrid.setLoading(false);
										done();
									})
									.done();
							}, 'PortfolioItemQueue'); //Race condition avoided between me.PortfolioItemStore and the User's actions
						}
						if(me.ClickMode == 'Feature Help Needed'){
							me.MatrixGrid.setLoading('Saving');
							me.enqueue(function(done){
								me.loadPortfolioItemByOrdinal(matrixRecord.data.PortfolioItemObjectID, 0)
									.then(function(portfolioItemRecord){
										var tcae = me.getTeamCommit(portfolioItemRecord, projectName);
										return me.setTeamCommitsField(portfolioItemRecord, projectName, 'FeatureStatus', !tcae.FeatureStatus);
									})
									.then(function(portfolioItemRecord){
										var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
											return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
										});
										storePortfolioItemRecord.data.c_TeamCommits = portfolioItemRecord.data.c_TeamCommits;
										me.MatrixGrid.view.refreshNode(matrixStore.indexOf(matrixRecord));
									})
									.fail(function(reason){ me.alert('ERROR', reason); })
									.then(function(){
										me.MatrixGrid.setLoading(false);
										done();
									})
									.done();
							}, 'PortfolioItemQueue'); //Race condition avoided between me.PortfolioItemStore and the User's actions
						}						
						return false;
					}, 
					edit: function(editor, e){
						var field = e.field,
							matrixRecord = e.record,
							value = e.value,
							originalValue = e.originalValue;
						
						//if(field != 'MoSCoW') return;
						if(value == originalValue) return;
						if(!value){
							matrixRecord.set(field, originalValue);
							return;
						}
						me.MatrixGrid.setLoading('Saving');
					
						// _.find(me.PortfolioItemStore.getRange(), function(item){ //set this here temporarily in case intelUpdate gets called while in queue
							// return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
						// }).data.c_MoSCoW = value; 
						
						me.enqueue(function(done){
							me.loadPortfolioItemByOrdinal(matrixRecord.data.PortfolioItemObjectID, 0)
								.then(function(portfolioItemRecord){
									var deferred = Q.defer();
									portfolioItemRecord.set('c_MoSCoW', value);
									portfolioItemRecord.save({ 
										callback:function(record, operation, success){
											if(!success) deferred.reject('Failed to modify PortfolioItem: ' + portfolioItemRecord.data.FormattedID);					
											else {
												var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
													return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
												});
												storePortfolioItemRecord.data.c_MoSCoW = portfolioItemRecord.data.c_MoSCoW;
											//	matrixRecord.data.MoSCoW = portfolioItemRecord.data.c_MoSCoW; //need this in case intelUpdate gets called while in queue
												me.MatrixGrid.view.refreshNode(matrixStore.indexOf(matrixRecord));
												deferred.resolve();
											}
										}
									});
									return deferred.promise;
								})
								.fail(function(reason){ me.alert('ERROR', reason); })
								.then(function(){
									me.MatrixGrid.setLoading(false);
									done();
								})
								.done();
							}, 'PortfolioItemQueue'); //Race condition avoided between me.PortfolioItemStore and the User's actions
					},
					afterrender: function (grid) {
						
						var view = grid.view.normalView; //lockedView and normalView		
						
						view.getEl().on('scroll', function(){ me.clearToolTip(); });
						
						grid.mon(view, {
							uievent: function (type, view, cell, row, col, e){
								var moveAndResizePanel;
								if((me.ClickMode === 'Details' || me.ClickMode === 'Comment') && type === 'mousedown') {
									var matrixRecord = matrixStore.getAt(row),
										projectName = view.getGridColumns()[col].text,
										portfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
											return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
										}),
										teamCommit = me.getTeamCommit(portfolioItemRecord, projectName),
										oldTooltip = me.tooltip,
										pos = cell.getBoundingClientRect(),
										dbs = me.getDistanceFromBottomOfScreen(pos.top),
										panelWidth = 400;
									if(oldTooltip) me.clearToolTip();
									if(oldTooltip && (oldTooltip.row == row && oldTooltip.col == col)) return;
									
									/* jshint -W082 */
									moveAndResizePanel = function(panel){
										var upsideDown = (dbs < panel.getHeight() + 80);
										panel.setPosition(pos.left-panelWidth, (upsideDown ? pos.bottom - panel.getHeight() : pos.top));
									};
									
									if(me.ClickMode === 'Details'){
										var panelHTML = [
											'<p><b>CE Comment:</b> ' + (teamCommit.CEComment || '') + '</p>',
											'<p><b>Objective:</b> ' + (teamCommit.Objective || '') + '</p>',
											'<p><b>PlanEstimate: </b>',
												_.reduce(me.MatrixUserStoryBreakdown[projectName][portfolioItemRecord.data.Name] || [], function(sum, storyData){
													return sum + (storyData.PlanEstimate || 0); 
												}, 0),
											'<p><b>UserStories: </b><div style="max-height:100px;overflow-y:auto;"><ol>'].join('');
										(me.MatrixUserStoryBreakdown[projectName][portfolioItemRecord.data.Name] || []).forEach(function(storyData){
											panelHTML += '<li><a href="' + me.BaseUrl + '/#/' + storyData.Project.ObjectID + 
												'd/detail/userstory/' + storyData.ObjectID + '" target="_blank">' + storyData.FormattedID + '</a>:' +
												'<span title="' + storyData.Name + '">' + 
												storyData.Name.substring(0, 40) + (storyData.Name.length > 40 ? '...' : '') + '</span></li>';
										});
										panelHTML += '</ol></div>';
									
										me.tooltip = {
											row:row,
											col:col,
											panel: Ext.widget('container', {
												floating:true,
												width: panelWidth,
												autoScroll:false,
												id:'MatrixTooltipPanel',
												cls: 'intel-tooltip',
												focusOnToFront:false,
												shadow:false,
												renderTo:Ext.getBody(),
												items: [{
													xtype:'container',
													layout:'hbox',
													cls: 'intel-tooltip-inner-container',
													items:[{
														xtype:'container',
														cls: 'intel-tooltip-inner-left-container',
														flex:1,
														items:[{
															xtype:'container',
															html:panelHTML
														}]
													},{
														xtype:'button',
														cls:'intel-tooltip-close',
														text:'X',
														width:20,
														handler: function(){ me.clearToolTip(); }
													}]
												}],
												listeners:{
													afterrender: moveAndResizePanel,
													afterlayout: moveAndResizePanel
												}
											})	
										};
									}
									else {
										me.tooltip = {
											row:row,
											col:col,
											panel: Ext.widget('container', {
												floating:true,
												width: panelWidth,
												autoScroll:false,
												id:'MatrixTooltipPanel',
												cls: 'intel-tooltip',
												focusOnToFront:false,
												shadow:false,
												renderTo:Ext.getBody(),
												items: [{
													xtype:'container',
													layout:'hbox',
													cls: 'intel-tooltip-inner-container',
													items:[{
														xtype:'container',
														cls: 'intel-tooltip-inner-left-container',
														flex:1,
														items:[{
															xtype:'container',
															layout:'hbox',
															items:[{
																xtype:'text',
																flex:1,
																text: 'CE Comment:',
																style:'font-weight:bold;'
															},{
																xtype:'checkbox',
																width:140,
																boxLabel:'CE Expected',
																checked:teamCommit.Expected,
																handler:function(checkbox, checked){
																	me.tooltip.panel.setLoading('Saving');
																	me.enqueue(function(done){
																		me.loadPortfolioItemByOrdinal(portfolioItemRecord.data.ObjectID, 0)
																			.then(function(portfolioItemRecord){
																				var tcae = me.getTeamCommit(portfolioItemRecord, projectName);
																				return me.setTeamCommitsField(portfolioItemRecord, projectName, 'Expected', !tcae.Expected);
																			})
																			.then(function(portfolioItemRecord){
																				var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
																					return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
																				});
																				storePortfolioItemRecord.data.c_TeamCommits = portfolioItemRecord.data.c_TeamCommits;
																				me.MatrixGrid.view.refreshNode(matrixStore.indexOf(matrixRecord));
																			})
																			.fail(function(reason){ me.alert('ERROR', reason); })
																			.then(function(portfolioItemRecord){
																				me.tooltip.panel.setLoading(false);
																				done();
																			})
																			.done();
																	}, 'PortfolioItemQueue');
																}
															},{
																xtype:'checkbox',
																width:140,
																boxLabel:'Feature Help Needed',
																checked:teamCommit.FeatureStatus,
																handler:function(checkbox, checked){
																	me.tooltip.panel.setLoading('Saving');
																	me.enqueue(function(done){
																		me.loadPortfolioItemByOrdinal(portfolioItemRecord.data.ObjectID, 0)
																			.then(function(portfolioItemRecord){
																				var tcae = me.getTeamCommit(portfolioItemRecord, projectName);
																				return me.setTeamCommitsField(portfolioItemRecord, projectName, 'FeatureStatus', !tcae.FeatureStatus);
																			})
																			.then(function(portfolioItemRecord){
																				var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
																					return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
																				});
																				storePortfolioItemRecord.data.c_TeamCommits = portfolioItemRecord.data.c_TeamCommits;
																				me.MatrixGrid.view.refreshNode(matrixStore.indexOf(matrixRecord));
																			})
																			.fail(function(reason){ me.alert('ERROR', reason); })
																			.then(function(portfolioItemRecord){
																				me.tooltip.panel.setLoading(false);
																				done();
																			})
																			.done();
																	}, 'PortfolioItemQueue');
																}																
															}]
														},{
															xtype:'textarea',
															value: teamCommit.CEComment || '',
															width:330,
															id: 'MatrixTooltipPanelTextarea',
															resizable: {
																handles: 's',
																minHeight: 80,
																maxHeight: 300,
																pinned: true
															}
														},{
															xtype:'button',
															text:'Save',
															listeners:{
																click: function(){
																	me.tooltip.panel.setLoading('Saving');
																	me.enqueue(function(done){
																		me.loadPortfolioItemByOrdinal(portfolioItemRecord.data.ObjectID, 0)
																			.then(function(portfolioItemRecord){ 
																				var val = Ext.getCmp('MatrixTooltipPanelTextarea').getValue();
																				return me.setTeamCommitsField(portfolioItemRecord, projectName, 'CEComment', val);
																			})
																			.then(function(portfolioItemRecord){
																				var storePortfolioItemRecord = _.find(me.PortfolioItemStore.getRange(), function(item){ 
																					return item.data.ObjectID == matrixRecord.data.PortfolioItemObjectID; 
																				});
																				storePortfolioItemRecord.data.c_TeamCommits = portfolioItemRecord.data.c_TeamCommits;
																				me.MatrixGrid.view.refreshNode(row);
																			})
																			.fail(function(reason){ me.alert('ERROR', reason); })
																			.then(function(portfolioItemRecord){
																				me.tooltip.panel.setLoading(false);
																				done();
																			})
																			.done();
																	}, 'PortfolioItemQueue');
																}
															}
														}]
													},{
														xtype:'button',
														cls:'intel-tooltip-close',
														text:'X',
														width:20,
														handler: function(){ me.clearToolTip(); }
													}]
												}],
												listeners:{
													afterrender: moveAndResizePanel,
													afterlayout: moveAndResizePanel
												}
											})
										};
									}									
									me.tooltip.triangle = Ext.widget('container', {
										floating:true,
										width:0, height:0,
										focusOnToFront:false,
										shadow:false,
										renderTo:Ext.getBody(),
										listeners:{
											afterrender: function(panel){
												setTimeout(function(){
													var upsideDown = (dbs < Ext.get('MatrixTooltipPanel').getHeight() + 80);
													if(upsideDown) {
														panel.removeCls('intel-tooltip-triangle');
														panel.addCls('intel-tooltip-triangle-up');
														panel.setPosition(pos.left -10, pos.bottom -10);
													} else {
														panel.removeCls('intel-tooltip-triangle-up');
														panel.addCls('intel-tooltip-triangle');
														panel.setPosition(pos.left -10, pos.top);
													}
												}, 10);
											}
										}
									});
								}
							}
						});
					}
				},
				enableEditing:false,
				store: matrixStore
			});	
			setTimeout(function(){ _.each(_.keys(me.MatrixUserStoryBreakdown), function(projectName){ me.updateGridHeader(projectName); }); }, 50);
		}
	});
}());

            Rally.launchApp('Intel.SAFe.ArtCommitMatrix', {
                name:"ART Commit Matrix",
	            parentRepos:""
            });

        });
    </script>


    <link rel="stylesheet" type="text/css" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css"/>

    <style type="text/css">
        .x-grid-cell.intel-editor-cell *,
.x4-grid-cell.intel-editor-cell *,
.intel-editor-cell {
  cursor: pointer !important;
}
.fa.fa-md {
  font-size: 1.05rem;
  line-height: .75em;
  vertical-align: -15%;
}
/************************************************ RALLY BUTTON STYLE *****************************************/
.intel-button {
  border-radius: 2px;
  background-color: #00a9e0;
  border-color: #00a9e0;
}
.intel-button:hover {
  background-color: #29beff;
  border-color: #29beff;
}
.intel-button * {
  font-size: 12px;
}

    </style>

    <style type="text/css">
        .intel-tooltip {
  padding: 10px;
  background-color: #C0D9FA;
  border-radius: 8px;
  z-index: 500;
  box-shadow: -3px 3px 3px;
}
.intel-tooltip p {
  margin: 2px 0 2px 0;
}
.intel-tooltip ol {
  margin: 2px 0 2px 0;
  padding-left: 20px;
}
.intel-tooltip-triangle {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-top: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-triangle-up {
  border-left: 10px solid transparent;
  border-right: 10px solid transparent;
  border-bottom: 10px solid #C0D9FA;
  height: 0px;
  width: 0px;
  z-index: 500;
}
.intel-tooltip-close {
  padding: 0 0 2px 0;
  font-weight: bold;
  margin-left: 5px;
  margin-top: -5px;
  border-radius: 10px;
}
.intel-tooltip-inner-container,
.intel-tooltip-inner-container * {
  overflow: visible;
}
.intel-tooltip-inner-left-container {
  overflow: hidden;
}

    </style>

    <style type="text/css">
        /************************************************ RISKS GRID *****************************************/
.x-grid-body .x-grid-row .risks-grid-error-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
/*red*/
/************************************************ DEPENDENCIES GRIDS *****************************************/
.predecessor-items-grid .x-grid-body {
  background-color: rgba(0, 0, 0, 0) !important;
  border-top: 0 !important;
}
.predecessor-items-grid-header {
  display: inline-block !important;
  line-height: 100% !important;
  font-weight: 500 !important;
}
.x-grid-body .x-grid-row .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-not-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-not-supported-cell.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.25) !important;
}
.x-grid-body .x-grid-row .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.15) !important;
}
.x-grid-body .x-grid-row-selected .predecessor-item-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .predecessor-supported-cell.x-grid-cell,
.x-grid-body .x-grid-row-selected .successor-supported-cell.x-grid-cell {
  background-color: rgba(0, 255, 0, 0.25) !important;
}
/************************************************ DUPLICATE RESOLVING MODAL *****************************************/
.duplicates-modal .grid-group-header {
  text-decoration: underline;
  padding-left: 10px;
  font-size: 1.25rem;
}
.duplicates-modal .done-button {
  margin: 10px 0 10px 10px;
}
.duplicates-modal .x-grid-row-selected .x-grid-cell,
.duplicates-modal .x-grid-row-over .x-grid-cell {
  background-color: rgba(0, 0, 0, 0) !important;
}
.duplicates-modal .duplicate-risks-grid,
.duplicates-modal .duplicate-predecessors-grid,
.duplicates-modal .duplicate-successors-grid {
  margin: 10px 20px 10px 20px;
}
.duplicates-modal .x-grid-row-checker {
  background-image: url(https://rally1.rallydev.com/apps/2.0rc3/rui/resources/css/images/form/radio.gif) !important;
}

    </style>

    <style type="text/css">
        .x-grid-cell.manager-expected-cell {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-feature-cell {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 30px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-feature-cell {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 70%, #9c0eb5 70%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-cell-small {
  background-image: -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-feature-cell-small {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-feature-cell-small {
  background-image: -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-comment-feature-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.manager-expected-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.manager-expected-feature-comment-cell-small {
  background-image: -o-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), /* comment blue */ -o-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), /* expected yellow */ -o-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  /* feature purple */
  background-image: -moz-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -moz-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -moz-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -webkit-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -webkit-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -webkit-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: -ms-linear-gradient(left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), -ms-linear-gradient(right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), -ms-linear-gradient(left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-image: linear-gradient(to left top, rgba(0, 0, 0, 0) 75%, #4c4cff 75%), linear-gradient(to right top, rgba(0, 0, 0, 0) 75%, #fbff00 75%), linear-gradient(to left bottom, rgba(0, 0, 0, 0) 75%, #9c0eb5 75%) !important;
  background-size: 100% 20px;
  background-repeat: no-repeat;
}
.x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-RED,
.x-grid-row-over .x-grid-cell.intel-team-commits-RED {
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREEN,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREEN {
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.5) !important;
}
.x-grid-row-selected .x-grid-cell.intel-team-commits-GREY,
.x-grid-row-over .x-grid-cell.intel-team-commits-GREY {
  background-color: rgba(183, 183, 183, 0.7) !important;
}

    </style>

    <style type="text/css">
        .moscow-cell {
  padding-left: 20px;
}
.must-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #ffdb99 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.should-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #ffa500 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.could-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, #cc8400 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}
.wont-have {
  background-image: -o-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -moz-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -webkit-linear-gradient(left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: -ms-linear-gradient(rleft, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 85%, rgba(255, 0, 0, 0.5) 85%) !important;
  background-size: 100% 20px;
  background-repeat: repeat-y;
}

    </style>

    <style type="text/css">
        /************************************************ NAVBAR/CONTAINERS *****************************************/
#navbar {
  padding: 0 10px 0 10px;
}
#releasePicker {
  margin: 4px 0 0 0;
}
#modePicker {
  margin: 0;
}
#viewPicker {
  margin: 0;
}
#manualRefreshButton {
  margin: 5px 0 5px 0;
}
.intel-legend-dot {
  width: 12px;
  height: 12px;
  border-radius: 6px;
  border: 1px solid black;
  display: inline-block;
  vertical-align: middle;
}
.intel-legend-item {
  font-size: 1em;
  text-align: right;
}
/************************************************ TEAM COMMITS MATRIX STUFF *****************************************/
.x-grid-header-ct .matrix-subheader-cell {
  display: flex;
  flex-direction: column;
}
.x-grid-header-ct .matrix-subheader-cell .x-column-header-inner {
  flex: 1;
}
.x-grid-header-ct .matrix-subheader-cell > .project-percentage-complete {
  display: block !important;
  font-size: 0.7rem;
  border-bottom: 1px solid black;
  line-height: 20px !important;
  height: 20px !important;
}
.x-grid-header-ct .not-dispositioned-project .x-column-header-inner,
.x-grid-body .x-grid-row .not-committed-portfolio-item.x-grid-cell {
  background-color: rgba(255, 0, 0, 0.5) !important;
}
.x-grid-header-ct .not-dispositioned-project .x-column-header-inner.x-column-header-over,
.x-grid-body .x-grid-row-selected .not-committed-portfolio-item.x-grid-cell,
.x-grid-body .x-grid-row-over .not-committed-portfolio-item.x-grid-cell {
  /* background-image:none !important; commented it for purple traingle: Revisit*/
  background-image: none !important;
  background-color: rgba(255, 0, 0, 0.7) !important;
}
.x-grid-header-ct .dispositioned-project .x-column-header-inner {
  background-color: rgba(0, 255, 0, 0.5) !important;
}
.x-grid-header-ct .dispositioned-project .x-column-header-inner.x-column-header-over {
  background-image: none !important;
  background-color: rgba(0, 255, 0, 0.7) !important;
}
.matrix-hidden-grid-row {
  display: none !important;
}
.x-column-header-inner .x-column-header-text {
  white-space: normal !important;
  line-height: 15px;
}
.x-column-header-inner {
  text-align: center;
  height: 100 !important;
}
.feature-porfolio-items {
  position: relative;
}
.feature-help {
  color: white;
  font-size: 0.6rem;
  position: absolute;
  left: -3px;
  top: 6px;
}
.porfolio-items {
  float: right;
}

    </style>
</head>
<body>
</body>
</html>
