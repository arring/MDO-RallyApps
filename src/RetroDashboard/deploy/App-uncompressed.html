<!DOCTYPE html>
<html>
<head>
    <title>RetroDashboard</title>

    <script type="text/javascript" src="/apps/2.0rc3/sdk.js"></script>
    <script type="text/javascript" src="https://code.jquery.com/jquery-2.1.3.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js"></script>
    <script type="text/javascript" src="https://code.highcharts.com/highcharts.js"></script>

    <script type="text/javascript">
        Rally.onReady(function () {
                /** this extends Rally.app.app. if you want to use it's utility functions, just
		extend IntelRallyApp instead of Rally.app.App
	*/
(function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('IntelRallyApp', {
		alias: 'widget.intelrallyapp',
		extend: 'Rally.app.App',
		
		/** these are the necessary models to load for the apps. you should call this */
		_loadModels: function(){
			var me=this, 
				promises = [],
				models = {
					Project: 'Project',
					UserStory: 'HierarchicalRequirement',
					Feature:'PortfolioItem/Feature',
					Milestone:'PortfolioItem/Milestone'
				};
			_.each(models, function(modelType, modelName){
				var deferred = Q.defer();
				Rally.data.WsapiModelFactory.getModel({ //load project
					type:modelType, 
					success: function(loadedModel){ 
						me[modelName] = loadedModel;
						deferred.resolve();
					}
				});
				promises.push(deferred.promise);
			});
			return Q.all(promises);
		},	
		_loadProject: function(oid){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.resolve();
			else if(!me.Project){ 
				return me._loadModels().then(function(){ 
					return me._loadProject(oid); 
				});
			}
			else {
				me.Project.load(oid, {
					fetch: ['ObjectID', 'Releases', 'Children', 'Parent', 'Name'],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadFeature: function(oid, projectRef){ //projectRef is optional
			var me = this, deferred = Q.defer();
			if(!oid) return Q.resolve();
			else if(!me.Feature){ 
				return me._loadModels().then(function(){ 
					return me._loadFeature(oid, projectRef); 
				});
			}
			else {
				me.Feature.load(oid, {
					fetch: ['Name', 'ObjectID', 'FormattedID', 'c_TeamCommits', 'c_Risks', 'Project', 'PlannedEndDate', 'Parent'],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: projectRef
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadUserStory: function(oid, projectRef){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.resolve();
			else if(!me.UserStory){ 
				return me._loadModels().then(function(){ 
					return me._loadUserStory(oid, projectRef); 
				});
			}
			else {
				me.UserStory.load(oid, {
					fetch: ['Name', 'ObjectID', 'Release', 'Project', 'Feature',
						'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies', 'Iteration', 'PlanEstimate'],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: projectRef
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},	
		_loadMilestone: function(oid, projectRef){ 
			var me = this, deferred = Q.defer();
			if(!oid) return Q.resolve();
			else if(!me.Milestone){ 
				return me._loadModels().then(function(){ 
					return me._loadMilestone(oid); 
				});
			}
			else {
				me.Milestone.load(oid, {
					fetch: ['ObjectID', 'Parent', 'Name'],
					context: {
						workspace: me.getContext().getWorkspace()._ref,
						project: projectRef
					},
					callback: deferred.resolve
				});
				return deferred.promise;
			}
		},
		
		/**************************************** SOME UTIL FUNCS ***************************************************/
		_loadRootProject: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LRP');
			var me=this, 
				n = projectRecord.data.Name;
			if(n === 'All Scrums' || n === 'All Scrums Sandbox') return Q(projectRecord);
			else if(!projectRecord.data.Parent) return Q.reject('You do not have viewer access to "All Scrums"!');
			else {
				return me._loadProject(projectRecord.data.Parent.ObjectID).then(function(parentRecord){
					return me._loadRootProject(parentRecord);
				});
			}
		},	
		_loadTopProject: function(projectRecord){
			if(!projectRecord) return Q.reject('Invalid arguments: LTP');
			var me=this, 
				n = projectRecord.data.Name;
			if(!projectRecord.data.Parent) return Q(projectRecord);
			else {
				return me._loadProject(projectRecord.data.Parent.ObjectID).then(function(parentRecord){
					return me._loadTopProject(parentRecord);
				});
			}
		},	
		_projectInWhichTrain: function(projectRecord){ // returns train the projectRecord is in, otherwise null.
			if(!projectRecord) return Q.reject('Invalid arguments: PIWT');
			else {
				var me=this, split = projectRecord.data.Name.split(' ART');
				if(split.length>1) return Q(projectRecord);
				else { 
					var parent = projectRecord.data.Parent;
					if(!parent) return Q.reject('Project not in a train');
					else {
						return me._loadProject(parent.ObjectID).then(function(parentRecord){
							return me._projectInWhichTrain(parentRecord);
						});
					}
				}
			}
		},	
		_loadAllTrains: function(rootProjectRecord){
			if(!rootProjectRecord) return Q.reject('Invalid arguments: LAT');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					remoteSort:false,
					limit:Infinity,
					fetch: ['Name', 'ObjectID'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[{
							property:'Name',
							operator: 'contains',
							value: ' ART'
						},{
							property: 'Name',
							operator: (rootProjectRecord.data.Name === 'All Scrums Sandbox' ? 'contains' : '!contains'),
							value: 'Test'
						}
					]
				});
			return me._reloadStore(store).then(function(store){
				console.log('AllTrainRecords loaded', store.data.items);
				return Q(store);
			});
		},			
		_loadRandomUserStory: function(projectRef){ //get the most recent 5 in the project!!
			if(!projectRef) return Q.reject('Invalid arguments: LRUS');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					fetch: ['Name', 'CreationDate', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[{
						property:'Project',
						value: projectRef
					}]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		
		_getUserStoryInReleaseTimeFrameFilter: function(releaseRecord){ //only pull look at Feature Release if US relese == null
			/************************* NOTE ***********************************************
				for Q215 we need to uncomment the below lines for a better user story filter!
				
				from: (US.Release == X || (US.Feature.Release ==X))
				to: (US.Release ==X || (US.Release ==null && US .Feature.Release==X))
			******************************************************************************/
			var me=this,
				twoWeeks = 1000*60*60*24*7*2,
				releaseStartPadding = new Date(new Date(releaseRecord.data.ReleaseStartDate)*1 + twoWeeks).toISOString(),
				releaseEndPadding = new Date(new Date(releaseRecord.data.ReleaseDate)*1 - twoWeeks).toISOString();
			return Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseStartDate',
				operator: '<',
				value: releaseStartPadding
			}).and(Ext.create('Rally.data.wsapi.Filter', {
				property:'Release.ReleaseDate',
				operator: '>',
				value: releaseEndPadding
			})).or(
				// Ext.create('Rally.data.wsapi.Filter', {
					// property:'Release.ObjectID',
					// value: null
				// }).and(
					Ext.create('Rally.data.wsapi.Filter', {
						property:'Feature.Release.ReleaseStartDate',
						operator: '<',
						value: releaseStartPadding
					}).and(Ext.create('Rally.data.wsapi.Filter', { 
						property:'Feature.Release.ReleaseDate',
						operator: '>',
						value: releaseEndPadding
					}))
				// )
			);
		},
		_loadRandomUserStoryFromRelease: function(projectRef, releaseName){ //get the most recent 5 in the project for a given releaseName!!
			if(!projectRef || !releaseName) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					fetch: ['Name', 'CreationDate', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property: 'Project', value: projectRef }).and(
							Ext.create('Rally.data.wsapi.Filter', { property: 'Release.Name', value: releaseName }).or(
							Ext.create('Rally.data.wsapi.Filter', { property: 'Feature.Release.Name', value: releaseName }))
						)
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadRandomUserStoryFromReleaseTimeframe: function(projectRef, releaseRecord){ //get the most recent 5 in the project!!
			/**this function load the 5 newest user stories that are attached to a release that is 'around the time' of the
				passed in release record. there is a 2 week shift maximum for the releases to be considered 'around the same time'.
				Then 1 of the 5 user stories is randomly selected and returned */
			if(!projectRef || !releaseRecord) return Q.reject('Invalid arguments: LRUSFR');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:5,
					pageSize:5,
					fetch: ['Name', 'CreationDate', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					sorters: [{
						property: 'CreationDate', 
						direction:'DESC'
					}],
					filters:[
						Ext.create('Rally.data.wsapi.Filter', { property:'Project', value: projectRef }).and(
						me._getUserStoryInReleaseTimeFrameFilter(releaseRecord))
					]
				});
			return me._reloadStore(store).then(function(store){
				var records = store.data.items;
				if(records.length) return Q(records[Math.floor(Math.random()*records.length)]);
				else return Q(undefined);
			});
		},
		_loadUserStoryByFID: function(formattedID, projectRef){ //must supply both argument
			if(!formattedID || !projectRef) return Q.reject('Invalid arguments: LUSBFID');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'HierarchicalRequirement',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'Project', 'ObjectID', 'FormattedID', 'Predecessors', 'Successors', 'c_Dependencies'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: undefined
					},
					filters: [{
						property:'FormattedID',
						value:formattedID
					},{
						property:'Project',
						value: projectRef
					}]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},	
		_loadProjectByName: function(name){
			if(!name) return Q.reject('Invalid arguments: LPBN');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'Project',
					limit:1,
					pageSize:1,
					fetch: ['Name', 'ObjectID'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters: [
						{
							property:'Name',
							value:name
						}
					]
				});
			return me._reloadStore(store).then(function(store){
				return Q(store.data.items.pop());
			});
		},
		
		/********************************************** FEATURES  ********************************************/
		_getFeatureFilter: function(trainRecord, releaseRecord){
			if(!trainRecord || !releaseRecord) throw 'invalid arguments: GFF';
			var me=this,
				trainName = trainRecord.data.Name.split(' ART')[0],
				relSplit = releaseRecord.data.Name.split(' '),
				coreFilter = Ext.create('Rally.data.wsapi.Filter', {
					property:'Release.Name',
					value: releaseRecord.data.Name
				});
			trainName = relSplit.length == 2 ? relSplit[1] : trainName; //switches where features are if release is "Qxxx TrainName"
			if(trainRecord.data.Name == 'Test ART (P&E)'){
				return Ext.create('Rally.data.wsapi.Filter', {
					property:'Project.Name',
					value: 'Test ART (P&E)'
				}).and(coreFilter);
			}
			else {
				return Ext.create('Rally.data.wsapi.Filter', { //NOTE: they should NOT be in the POWG portfolio level, but we will cover that just in case
					property:'Project.Parent.Name',
					value: trainName + ' POWG Portfolios'
				}).or(Ext.create('Rally.data.wsapi.Filter', {
					property:'Project.Name',
					value: trainName + ' POWG Portfolios'
				})).and(coreFilter);
			}
		},
		
		/*************************************************** Products ********************************************/
		_getProductFilter: function(trainRecord){ //products can be in 2 different levels of the portfolio hierarchy
			if(!trainRecord) throw 'invalid arguments: GPF';
			var me=this,
				trainName = trainRecord.data.Name.split(' ART')[0];
			if(trainName === 'Test'){
				return Ext.create('Rally.data.wsapi.Filter', {
					property:'Project.Name',
					value: 'Test ART (P&E)'
				});
			}
			else {
				return Ext.create('Rally.data.wsapi.Filter', {//NOTE: they should NOT be in the POWG portfolio level, but we will cover that just in case
					property:'Project.Parent.Name',
					value: trainName + ' POWG Portfolios'
				}).or(Ext.create('Rally.data.wsapi.Filter', {
					property:'Project.Name',
					value: trainName + ' POWG Portfolios'
				}));
			}
		},	
		_loadProducts: function(trainRecord){
			if(!trainRecord) return Q.reject('Invalid arguments: LPROD');
			var me=this,
				store = Ext.create('Rally.data.wsapi.Store',{
					model: 'PortfolioItem/Product',
					limit:Infinity,
					remoteSort:false,
					fetch: ['Name'],
					context:{
						workspace: me.getContext().getWorkspace()._ref,
						project: null
					},
					filters:[me._getProductFilter(trainRecord)]
				});
			return me._reloadStore(store).then(function(store){
				console.log('Products loaded', store.data.items);
				return Q(store);
			});
		},
		
		/********************************************** Load Valid Projects ********************************************/	
		_addValidProjectsToList: function(projTree, hash){
			var me=this, 
				curProj = projTree.ProjectRecord;
			if(curProj.data.TeamMembers.Count >0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._addValidProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadValidProjects: function(rootProjectRecord){ //all projects under root that have team Members
			if(!rootProjectRecord) return Q.reject('Invalid arguments: LVP');
			var me=this,
				validProjects = {}, 
				projTree = {};
			var store = Ext.create('Rally.data.wsapi.Store', {
				model: "Project",
				fetch: ['Name', 'Parent', 'ObjectID', 'TeamMembers'],
				limit:Infinity,
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project:null
				}
			});
			return me._reloadStore(store).then(function(store){
				var projects = store.data.items;
				for(var i=0, len=projects.length; i<len; ++i){
					var project = projects[i],
						thisRef = project.data.ObjectID, 
						parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
					if(!projTree[thisRef]) projTree[thisRef] = {};
					projTree[thisRef].ProjectRecord = project;
					if(parentRef){
						if(!projTree[parentRef]) projTree[parentRef] = {};
						projTree[parentRef][thisRef] = projTree[thisRef];
					}
				}
				me._addValidProjectsToList(projTree[rootProjectRecord.data.ObjectID], validProjects);
				console.log('valid projects', validProjects);
				return Q(validProjects);
			});	
		},	
		_allChildProjectToList: function(projTree, hash){
			var me=this, 
				curProj = projTree.ProjectRecord;
			hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allChildProjectToList(projTree[childProjRef], hash);
			}
		},
		_loadAllChildrenProjects: function(rootProjectRecord){
			if(!rootProjectRecord) return Q.reject('Invalid arguments: LACP');
			var me=this,
				childrenProjects = {}, 
				projTree = {};
			var store = Ext.create('Rally.data.wsapi.Store', {
				model: "Project",
				fetch: ['Name', 'Parent', 'ObjectID'],
				limit:Infinity,
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project:null
				}
			});
			return me._reloadStore(store).then(function(store){
				var projects = store.data.items;
				for(var i=0, len=projects.length; i<len; ++i){
					var project = projects[i],
						thisRef = project.data.ObjectID, 
						parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
					if(!projTree[thisRef]) projTree[thisRef] = {};
					projTree[thisRef].ProjectRecord = project;
					if(parentRef){
						if(!projTree[parentRef]) projTree[parentRef] = {};
						projTree[parentRef][thisRef] = projTree[thisRef];
					}
				}
				me._allChildProjectToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
				console.log('childrenProjects', childrenProjects);
				return Q(childrenProjects);
			});	
		},	
		_allLeafProjectsToList: function(projTree, hash){
			var me=this, 
				curProj = projTree.ProjectRecord;
			if(curProj.data.Children.Count === 0) 
				hash[curProj.data.ObjectID] = curProj;
			for(var childProjRef in projTree){
				if(childProjRef !== 'ProjectRecord')
					me._allLeafProjectsToList(projTree[childProjRef], hash);
			}
		},	
		_loadAllLeafProjects: function(rootProjectRecord){
			if(!rootProjectRecord) return Q.reject('Invalid arguments: LALP');
			var me=this,
				childrenProjects = {}, 
				projTree = {};
			var store = Ext.create('Rally.data.wsapi.Store', {
				model: "Project",
				fetch: ['Name', 'Parent', 'ObjectID', 'Children'],
				limit:Infinity,
				context: {
					workspace: me.getContext().getWorkspace()._ref,
					project:null
				}
			});
			return me._reloadStore(store).then(function(store){
				var projects = store.data.items;
				for(var i=0, len=projects.length; i<len; ++i){
					var project = projects[i],
						thisRef = project.data.ObjectID, 
						parentRef = project.data.Parent ? project.data.Parent.ObjectID : undefined;
					if(!projTree[thisRef]) projTree[thisRef] = {};
					projTree[thisRef].ProjectRecord = project;
					if(parentRef){
						if(!projTree[parentRef]) projTree[parentRef] = {};
						projTree[parentRef][thisRef] = projTree[thisRef];
					}
				}
				me._allLeafProjectsToList(projTree[rootProjectRecord.data.ObjectID], childrenProjects);
				return Q(childrenProjects);
			});	
		},
		
		/********************************************** Generic store loading, returns promise ********************************************/
		
		_reloadStore: function(store){
			var deferred = Q.defer();
			store.load({
				callback: function(records, operation, success){
					if(!success) deferred.reject(operation.getError() || 'Could not load data');
					else deferred.resolve(store);
				}
			});
			return deferred.promise;
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
		/************************* MODEL FOR WORKWEEK DROPDOWNS *********************************************/
	Ext.define('WorkweekDropdown', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'Workweek', type:'string'},
			{name: 'DateVal', type:'number'}
		]
	});
		
	/************************* USED FOR WORKSPACE CONFIG *********************************************/
	Ext.define('TrainConfigItem', {
		extend: 'Ext.data.Model',
		fields: [
			{name: 'TrainProjectOID', type: 'number'},
			{name: 'TrainName', type: 'string'},
			{name: 'TrainAndPortfolioLocationTheSame', type:'boolean'},
			{name: 'PortfolioProjectOID', type:'number'}
		]
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
		
		/** this is used if you want to listen to events in the parent window (e.g. useful for rally apps that resize with browser screen
			vertically or things that need to know browser scroll position) 
		You also can artificially fire the events and have the listeners run
	*/
	Ext.define('WindowListener', {

		__initWindowEventListener: function(eventName){
			var me=this;
			if(!me._windowListeners) me._windowListeners = {};
			me._windowListeners[eventName] = [];
			
			window.parent['on' + eventName] = function(event){ 
				var listeners = me._windowListeners[eventName];
				for(var i=0, len=listeners.length; i<len; ++i)
					listeners[i](event);
			};
		},
		
		_addWindowEventListener: function(eventName, fn){
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) 
				me.__initWindowEventListener(eventName);
			me._windowListeners[eventName].push(fn);
		},
		
		_fireParentWindowEvent: function(eventName){ //eg: resize or scroll
			var me=this;
			if(!me._windowListeners || !me._windowListeners[eventName]) return;
			var listeners = me._windowListeners[eventName];
			for(var i=0, len=listeners.length; i<len; ++i) listeners[i]();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** resizes the iframe to be a little bigger than the inner contents, so theres no ugly double vertical scroll bar **/

	Ext.define('IframeResize', {
		requires: ['WindowListener'],
		
		/***************** ************* ********* DONT USE THIS STUFF ********************* ************* *********************/
		
		/** resizes the iframe to be the height of all the items in it */
		_applyIframeResizeToContents: function(){ 
			var w = window, p = w.parent, pd = w.parent.document, l = w.location,
				iframe = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ip1 = iframe.parentNode,
				ip2 = iframe.parentNode.parentNode.parentNode.parentNode.parentNode.parentNode, //this is apparently the one that matters
				height = 0, next = this.down();
			while(next){
				height += next.getHeight() + next.getEl().getMargin('tb')*1 + next.getEl().getPadding('tb')*1;
				next = next.next();
			}
			height += 150;
			ip1.style.height = height + 'px';
			ip2.style.height = height + 'px';
			iframe.style.height = height + 'px';
		},
		
		/** 
			This attaches a listener to the parent window resize event. When the parent window resizes, this resets the iframe height
			to that of the contents! Call this if you want the scrollbar to be on the outsize of the app (the window scrollbar)
		*/
		_initIframeResizeToContents: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._applyIframeResizeToContents(); });
			}
		},
			
		/** 
			resizes the iframe to be the height of the window. its like rally autoheight app but better 
		*/
		_applyIframeResizeToWindow: function(){ 
			var iframe = window.frameElement ? Ext.get(window.frameElement) : me.el,
				i = iframe.dom,
				portlet = iframe.up('.x-portlet'),
				portalColumn = portlet.up('.x-portal-column'),
				dashboard = portlet.up('#mydash_portlet');
			height = window.parent.innerHeight - 70;
			height -= 200; //~120 on top and 60 on bottom and
			iframe.style.height = height + 'px';
			ip1.style.height = height + 'px';
			height += 30;
			ip2.style.height = height + 'px';
		},
		
			/** 
			This attaches a listener to the parent window resize event. When the parent window resizes, this resets the iframe height
			to that of the window! Call this if you want the scrollbar to be on the inside of the app (NOT the window scrollbar)
		*/
		_initIframeResizeToWindow: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._applyIframeResizeToWindow(); });
			}
			me._applyIframeResizeToWindow();
		},
		
		/***************** ************* ********* GOOD STUFF BELOW ********************* ************* *********************/		
		_fixRallyDashboard: function(){ //makes app as large as screen, without the stupid padding/margin
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				portlet = bottomEl.up('.x-portlet'), 
				portalColumn = portlet.up('.x-portal-column'), //has huge right margin (we don't explicitly need it here)
				dashboard = portlet.up('#mydash_portlet'), //has huge padding values
				titleBar = dashboard.down('.titlebar'), //redundant with app header bar
				domNodeW = bottomEl.dom, domNodeH = bottomEl.dom,
				innerHeight = window.parent.innerHeight,
				innerWidth = window.parent.innerWidth;
				
			titleBar.dom.style.display = 'none';
			
			//adjust widths
			while(true){
				domNodeW.style.width = (innerWidth - 4) + 'px';
				domNodeW.style.padding = '0';
				domNodeW.style.margin = '0';
				if(domNodeW.id === 'mydash_portlet') break;
				domNodeW = domNodeW.parentNode;
			}
			
			//adjust heights
			while(true){
				domNodeH.style.height = (innerHeight - 105) + 'px';
				if(domNodeH.classList.contains('x-portlet')) break;
				domNodeH = domNodeH.parentNode;
			}
			dashboard.dom.style.height = (innerHeight - 65) + 'px';
			portlet.dom.style.height = (innerHeight - 75) + 'px';
			
			//final touches LOL
			dashboard.dom.style.padding = "0 2px 0 2px";
		},		
		_initFixRallyDashboard: function(){ 
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._fixRallyDashboard(); });
			}
			me._fixRallyDashboard();
		},

		_disableResizeHandle: function(){ //hides the draggable resize handle from under the app
			var me=this, handle;
			if(window.frameElement) handle = Ext.get(window.frameElement).up('.x-portlet').down('.x-resizable-handle');
			else handle = me.el.up('.x-portlet').down('.x-resizable-handle');
			if(handle){
				handle.hide();
				handle.dom.onshow = function(){ if(handle) handle.hide(); };
			}
		},
			
		_initDisableResizeHandle: function(){
			var me=this;
			if(me._addWindowEventListener){
				me._addWindowEventListener('resize', function(){ me._disableResizeHandle(); });
			}
			me._disableResizeHandle();
		}
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

	/**
		THIS IS ONLY USEFUL AS A RALLYAPP MIXIN
		gives a window-centered alert or confirm dialog box that isn't ugly.
	*/
	Ext.define('PrettyAlert', {

		__getMessageBoxY: function(){
			var me=this,
				bottomEl = window.frameElement ? Ext.get(window.frameElement) : me.el,
				ph = window.parent.getWindowHeight ? window.parent.getWindowHeight()  : window.innerHeight,
				ps = window.parent.getScrollY ? window.parent.getScrollY() : window.scrollY, 
				ofy = ps + bottomEl.dom.getBoundingClientRect().top, //offset of top of the iframe ==== constant!!!
				iyOffset = Math.floor(ph/2 - ofy + ps - 50);
			return iyOffset<0 ? 0 : iyOffset;
		},

		_alert: function(title, str){
			if(arguments.length<1) return;
			if(arguments.length===1){
				str = title;
				title = '';
			}
			Ext.MessageBox.alert(title, str).setY(this.__getMessageBoxY());
			setTimeout(function(){ //give some time to give the 'ok' or 'yes' button focus
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		},

		_confirm: function(title, str, fn){
			if(arguments.length<2) return;
			if(arguments.length===2){
				fn = str;
				str = title;
				title = '';
			}
			if(typeof fn !== 'function') fn = function(){};
			Ext.MessageBox.confirm(title, str, fn).setY(this.__getMessageBoxY());
			setTimeout(function(){
				var x = Ext.MessageBox.down('button');
				while(x.isHidden()) x = x.nextSibling();
				x.focus();
			}, 20);
		}
	});
}());

                (function(){
	var Ext = window.Ext4 || window.Ext;

	var intel_ww = {},
		SECOND = 1000,
		MINUTE = 60*SECOND,
		HOUR = 60*MINUTE,
		DAY = 24*HOUR,
		WEEK = 7*DAY;
		
	Ext.define('IntelWorkweek', {
		/** 
			intel workweek utility module. you can pass in Date objects, strings, or numbers.
			do not pass in Unix UTC millis though, or you will get wrong answer (eg: dont use Date.UTC(...))
		**/
		
		/** calculates intel workweek, returns integer */
		_getWorkweek: function(_date){  //ww1 always contains jan 1st
			var date = new Date(_date),
				yearStart = new Date(date.getFullYear(), 0, 1),
				dayIndex = yearStart.getDay(),
				ww01Start = new Date(yearStart - dayIndex*DAY),
				utcDateMillis = Date.UTC(date.getFullYear(), date.getMonth(), date.getDate()),
				ww01Millis = Date.UTC(ww01Start.getFullYear(), ww01Start.getMonth(), ww01Start.getDate()),
				timeDiff = utcDateMillis - ww01Millis,
				ww = Math.floor(timeDiff/WEEK) + 1,
				leap = (date.getFullYear() % 4 === 0),
				weekCount = ((leap && dayIndex >= 5) || (!leap && dayIndex === 6 )) ? 53 : 52; //weeks in this year
			return weekCount < ww ? 1 : ww;
		},
		
		/** returns the number of intel workweeks in the year the date is in */
		_getWeekCount: function(_date){  // # of intel workweeks in the year the date is in
			var date = new Date(_date),
				leap = (date.getFullYear() % 4 === 0),
				day = new Date(date.getFullYear(), 0, 1).getDay();
			return ((leap && day >= 5) || (!leap && day === 6 )) ? 53 : 52;
		},
		
		_roundDateDownToWeekStart: function(_date){
			var date = new Date(_date),
				day = date.getDay(),
				monthDate = date.getDate(),
				month = date.getMonth(),
				year = date.getFullYear(),
				sundayMidday = new Date(new Date(year, month, monthDate)*1 - (day*DAY - 0.5*DAY)); //daylight savings ._.
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		/**  gets list of date numbers for each week start between start and end date*/
		_getWorkweekDates: function(startDate, endDate){ //gets list of dates for each week. INCLUSIVE
			var startWeekDate = this._roundDateDownToWeekStart(startDate),
				endWeekDate = this._roundDateDownToWeekStart(endDate),
				startMillis = Date.UTC(startWeekDate.getFullYear(), startWeekDate.getMonth(), startWeekDate.getDate()),
				endMillis = Date.UTC(endWeekDate.getFullYear(), endWeekDate.getMonth(), endWeekDate.getDate()),
				totalWeeks = Math.floor((endMillis - startMillis) / WEEK)+1,
				weeks = new Array(totalWeeks);
			for(var i=0; i<totalWeeks; ++i) {
				var sundayMidday = new Date(startWeekDate*1 + (WEEK*i + HOUR*12));
				weeks[i] = new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
			}
			return weeks;
		},
		
		_workweekToDate: function(ww, year){ //gets the Date() object of this ww and year
			var yearStart = new Date(year, 0, 1),
				dayIndex = yearStart.getDay(),
				ww01StartMidday = new Date(yearStart - (dayIndex*DAY - 0.5*DAY)),
				sundayMidday = new Date(ww01StartMidday*1 + (ww-1)*WEEK);
			return new Date(sundayMidday.getFullYear(), sundayMidday.getMonth(), sundayMidday.getDate());
		},
		
		_getWorkWeeksForDropdown: function(releaseStartDate, releaseEndDate){ //assumes DropDown uses WorkweekDropdown model
			var workweeks = this._getWorkweekDates(releaseStartDate, releaseEndDate),
				data = new Array(workweeks.length);
			for(var i=0, len=workweeks.length; i<len; ++i){
				data[i] = { 
					Workweek: 'ww' + this._getWorkweek(workweeks[i]),
					DateVal: workweeks[i]*1
				};
			}
			return data;
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;

		/** Mixin functions related to queries, you need to require Q as a dependency in your rally app
		Q can be found here: https://cdnjs.cloudflare.com/ajax/libs/q.js/1.0.1/q.js
		most functions return promises that resolve to stores
	*/

	Ext.define('ReleaseQuery', {

		_loadAllReleases: function(projectRecord){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[
					{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					}
				],
				listeners: {
					load: {
						fn: function(releaseStore, releaseRecords){
							console.log('releases loaded:', releaseRecords);
							deferred.resolve(releaseStore);
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},

		/** gets releases for this project that have release date >= now. returns promise that resolves to the releaseStore */
		_loadReleasesInTheFuture: function(projectRecord){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[
					{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date().toISOString()
					}
				],
				listeners: {
					load: {
						fn: function(releaseStore, releaseRecords){
							console.log('releases loaded:', releaseRecords);
							deferred.resolve(releaseStore);
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},

		/** loads this release for each scrum whose name contains the second parament. returns promise with the release Store
			the scrums that the releases belong to will have at least 1 team member, and the train's release is not included
			in the results.
		**/
		_loadReleasesWithName: function(releaseName, nameContains){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project', 'TeamMembers'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[
					{
						property:'Name', //match the release
						value: releaseName
					},{
						property:'Project.Name',
						operator:'contains',
						value:nameContains
					},{
						property:'Project.Children.Name', //has children
						operator:'=',
						value:''
					},{
						property:'Project.Name', //but not the train release itsself
						operator:'!contains',
						value:' ART'
					}
				],
				listeners: {
					load: {
						fn: function(store, records){
							console.log('releasesWithName loaded:', records);
							deferred.resolve(store);
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},

		_loadReleaseByNameForProject: function(releaseName, projectRecord){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[{
					property:'Name',
					value: releaseName
				},{
					property:'Project',
					value:projectRecord.data._ref
				}],
				listeners: {
					load: {
						fn: function(store, records){
							deferred.resolve(records.pop());
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},

		_loadReleasesByNameContainsForProject: function(releaseName, projectRecord){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[{
					property:'Name',
					operator:'contains',
					value: releaseName
				},{
					property:'Project',
					value:projectRecord.data._ref
				}],
				listeners: {
					load: {
						fn: function(store, records){
							deferred.resolve(records);
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},
		/** gets releases for this project that have release date >= givenDate. returns promise that resolves to the releaseStore */
		_loadReleasesAfterGivenDate: function(projectRecord, givenDate){
			var deferred = Q.defer();
			Ext.create('Rally.data.wsapi.Store',{
				model: 'Release',
				limit:Infinity,
				autoLoad:true,
				fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
				context:{
					workspace: this.getContext().getWorkspace()._ref,
					project: null
				},
				filters:[
					{
						property:'Project.ObjectID',
						value: projectRecord.data.ObjectID
					},{
						property:'ReleaseDate',
						operator:'>=',
						value: new Date(givenDate).toISOString()
					}
				],
				listeners: {
					load: {
						fn: function(releaseStore, releaseRecords){
							console.log('releases loaded:', releaseRecords);
							deferred.resolve(releaseStore);
						},
						single:true
					}
				}
			});
			return deferred.promise;
		},
	/** gets releases for this project that have release within the given dates. returns promise that resolves to the releaseStore */
	_loadReleasesBetweenDates: function(projectRecord, startDate, endDate){
		var deferred = Q.defer();
		Ext.create('Rally.data.wsapi.Store',{
			model: 'Release',
			limit:Infinity,
			autoLoad:true,
			fetch: ['Name', 'ObjectID', 'ReleaseDate', 'ReleaseStartDate', 'Project'],
			context:{
				workspace: this.getContext().getWorkspace()._ref,
				project: null
			},
			filters:[
				{
					property:'Project.ObjectID',
					value: projectRecord.data.ObjectID
				},{
					property:'ReleaseDate',
					operator:'<=',
					value: new Date(endDate).toISOString()
				},{
					property:'ReleaseDate',
					operator:'>=',
					value: new Date(startDate).toISOString()
				}
			],
			listeners: {
				load: {
					fn: function(releaseStore, releaseRecords){
						console.log('releases loaded:', releaseRecords);
						deferred.resolve(releaseStore);
					},
					single:true
				}
			}
		});
		return deferred.promise;
	},
		/** gets the most likely release to scope to base on the following order:
			1) if this.AppPrefs.projs[pid] is set to a release ObjectID, and the ReleaseStore has that release (you need
							to use preferences for this one)
			2) if we are in a release
			3) the closest release planning date to the current date
		*/
		_getScopedRelease: function(releaseRecords, projectOID, appPrefs){
			var me=this,
				d = new Date(),
				rs = releaseRecords,
				prefOID = appPrefs && appPrefs.projs && appPrefs.projs[projectOID] && appPrefs.projs[projectOID].Release;
			return (prefOID && _.find(rs, function(r){ return r.data.ObjectID == prefOID; })) ||
				_.find(rs, function(r){
					return (new Date(r.data.ReleaseDate) >= d) && (new Date(r.data.ReleaseStartDate) <= d);
				}) ||
				_.reduce(rs, function(best, r){
					if(best===null) return r;
					else {
						var d1 = new Date(best.data.ReleaseStartDate), d2 = new Date(r.data.ReleaseStartDate), now = new Date();
						return (Math.abs(d1-now) < Math.abs(d2-now)) ? best : r;
					}
				}, null);
		}
	});
}());

                /** This is a mixin that updates highchart data after it is run through the lookback calculator
	it specifically: (optionally) adds trendlines, zeros out the future numbers, and
	adds a datemap from workweeks to actual dates
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('ChartUpdater', {
		requires:['IntelWorkweek'],

		_updateChartData: function(data, hideTrends){
			var me = this,
				now = new Date(),
				datemap = [];

			//get ideal trendline if release has started
			var totalPoints = (new Date(data.categories[0]) > now ? 0 :
					_.reduce(data.series, function(sum, s){return sum + (s.data[s.data.length-1] || 0);
				}, 0) || 0),
				idealTrend, ratio;

			if(!hideTrends){
				idealTrend = {type:'spline', dashStyle:'Solid', name:'Ideal', data:new Array(data.categories.length)};
				ratio = (totalPoints/(data.categories.length-1)) || 0; //for NaN
				idealTrend.data = _.map(idealTrend.data, function(e, i){ return Math.round(100*(0 + i*ratio))/100; });
			}

			//zero future points, convert to workweeks, and set datemap
			_.each(data.categories, function(c, i, a){
				var d = new Date(c);
				a[i] = 'ww' + me._getWorkweek(d);
				datemap[i] = c;
				if(d>now){
					_.each(data.series, function(s, j){
						s.data = s.data.slice(0, i).concat(_.map(new Array(a.length - i), function(){ return 0; }));
					});
				}
			});

			if(!hideTrends){
				//get projected trendline
				var s = _.find(data.series, function(s){ return s.name === 'Accepted'; }), i, len,
					projectedTrend = {type:'spline', dashStyle:'Solid', name:'Projected', data:s.data.slice()},
					begin=0,
					end=projectedTrend.data.length-1;
				for(i=1;i<projectedTrend.data.length;++i)
					if(projectedTrend.data[i]!==null && projectedTrend.data[i] !==0){
						begin = i-1; break; }
				for(i=end;i>=begin;--i) //start at the END, not at begin+1 (remember ISSG_binsplit bug)
					if(projectedTrend.data[i]!==0){
						end = i; break; }
				ratio = (end===begin) ? 0 : (projectedTrend.data[end] - 0)/(end-begin);
				projectedTrend.data = _.map(projectedTrend.data, function(p, j){
					if(j>=begin) return Math.round(100*(0 + (j-begin)*ratio))/100;
					else return p;
				});

				//apply label to correct point if needed IGNORE FIRST POINT!
				for(i=1,len=projectedTrend.data.length; i<len;++i){
					if(projectedTrend.data[i] >= totalPoints){
						projectedTrend.data[i] = {
							color:'red',
							marker:{
								enabled:true,
								lineWidth:4,
								symbol:'circle',
								fillColor:'red',
								lineColor:'red'
							},
							y: projectedTrend.data[i]
						};
						break;
					}
				}
				data.series.push(projectedTrend);
				data.series.push(idealTrend);
			}
			data.datemap = datemap;

			return data;
		}
	});
}());

                /** This class is used to save user preferences per project, that can follow the user from app to app **/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define('UserAppsPreference', {
		
		_userAppsPref: 'intel-user-apps-preference', //this preference can be overridden, unless you want all apps to share prefs
		
		_loadAppsPreference: function(){
			var me=this, deferred = Q.defer();
			Rally.data.PreferenceManager.load({
				filterByUser:true,
				filterByName:me._userAppsPref,
				success: function(prefs) {
					var appPrefs = prefs[me._userAppsPref];
					try{ appPrefs = JSON.parse(appPrefs); }
					catch(e){ appPrefs = { projs:{}, refresh:30};}
					console.log('loaded prefs', appPrefs);
					deferred.resolve(appPrefs);
				},
				failure: deferred.reject
			});
			return deferred.promise;
		},
		_saveAppsPreference: function(prefs){
			var me=this, s = {}, deferred = Q.defer();
			prefs = {projs:prefs.projs, refresh:prefs.refresh};
			s[me._userAppsPref] = JSON.stringify(prefs); 
			console.log('saving prefs', prefs);
			Rally.data.PreferenceManager.update({
				filterByUser: true,
				filterByName:me._userAppsPref,
				settings: s,
				success: deferred.resolve,
				failure: deferred.reject
			});
			return deferred.promise;
		}
	});
}());
                /** use this to load stores that have lots of records. it will load them in parallel instead of serially.
what it does is loads 1 page and then based on the totalResultCount it loads the rest of the pages in parallel.
for wsapiStore, the config needs to be: {
pagesize: <defaults to 200>
url:<host:port/path>
params: query parameter object with keys and vals
model: the instantiated wsapi model (need to load this first)
}
for lookbackStore, the config needs to be: {
pagesize: <defaults to 20000>
url:<host:port/path defaults to standard analytics url. host is window.location.host>
params: query parameter object with keys and vals
}
*/
(function(){
var Ext = window.Ext4 || window.Ext;
Ext.define('ParallelLoader', {
    __parallelLoadData: function(config){

        var me=this,
        pagesize = config.pagesize,
        url = config.url,
        params = config.params,
        promises = [],
        outputItems = [];
        totalRequestsSent = 1; //1 is the minimum number of requests sent
        _.times(totalRequestsSent, function(pageNum){
            var thisDeferred = Q.defer(),
            thisParams = Ext.merge({}, params);
            promises.push(thisDeferred.promise);
            thisParams.start = config.itemOffset + pagesize*pageNum;
            Ext.Ajax.request({
            url:url,
            method:'GET',
            params: thisParams,
            success: function(response){
                var resJSON  = JSON.parse(response.responseText),
                items = resJSON.QueryResult ? resJSON.QueryResult.Results : resJSON.Results,
                totalCount = resJSON.QueryResult ? resJSON.QueryResult.TotalResultCount : resJSON.TotalResultCount,
                totalPages = (totalCount/pagesize>>0)+(totalCount%pagesize ? 1 : 0);
                outputItems = outputItems.concat(items);
                if(totalRequestsSent < totalPages){
                    var additionalPromises = [];
                    _.times(totalPages - totalRequestsSent, function(){
                        var nextDeferred = Q.defer(),
                        thisParams = Ext.merge({}, params);
                        additionalPromises.push(nextDeferred.promise);
                        thisParams.start = config.itemOffset + pagesize*totalRequestsSent;
                        ++totalRequestsSent;
                        Ext.Ajax.request({
                        url:url,
                        method:'GET',
                        params: thisParams,
                        success: function(response){
                            var resJSON  = JSON.parse(response.responseText),
                            items = resJSON.QueryResult ? resJSON.QueryResult.Results : resJSON.Results;
                            outputItems = outputItems.concat(items);
                            nextDeferred.resolve();
                        },
                        failure: function(response){
							console.log("error",response);
							nextDeferred.reject(response); }
                        });
                    });
                    Q.all(additionalPromises).then(function(){ thisDeferred.resolve(); });
                }
                else thisDeferred.resolve();
            },
            failure: function(response){ thisDeferred.reject(response); }
            });
        });
        return Q.all(promises).then(function(){ return outputItems; });
    },
    _parallelLoadWsapiStore: function(config){
        var me=this;
        config.itemOffset = 1; //page index starts at 1 for wsapi
        config.pagesize = (config.pagesize > 0 && config.pagesize <= 200) ? config.pagesize : 200;
        return me.__parallelLoadData(config).then(function(items){

        var featureStore = Ext.create('Rally.data.wsapi.Store', {
            model: config.model,//model has to be an object type 
            totalCount: items.length,
            data: items,
            load: function(){}
            });
		
		return featureStore;
        });
    },
    _parallelLoadLookbackStore: function(config){
        var me=this;
        config.itemOffset = 0; //page index starts at 0 for lookback
        config.pagesize = (config.pagesize > 0 && config.pagesize <= 20000) ? config.pagesize : 20000;
        return me.__parallelLoadData(config).then(function(items){
            return Ext.create('Rally.data.lookback.SnapshotStore', {
                totalCount: items.length,
                data: items,
                model: Ext.define('Rally.data.lookback.SnapshotModel-' + Ext.id(), {
                extend: 'Rally.data.lookback.SnapshotModel',
                fields:items.length ? Object.keys(items[0]) : []
                }),
                load: function(){}
            });
        });
    }
    });
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	Ext.define('Intel.form.field.FixedComboBox', {
		extend:'Ext.form.field.ComboBox',
		alias: ['widget.intelfixedcombo', 'widget.intelfixedcombobox'],
		
		constructor: function(options) {
			options = options || {};
			options = Ext.merge({
				editable: false,	
				allowBlank:false,
				queryMode:'local',
				listeners: {
					focus: function(combo) {
						combo.setValue('');
						combo.expand();
					}
				}
			}, options);
			this.callParent([options]);
		}	
	});
}());
                (function(){
	var Ext = window.Ext4 || window.Ext;
	
	/** YOU MUST PASS IT 2 THINGS IN THE CONFIG
		1: releases (array of release records)
		2: currentRelease (what to show as initial value
	*/
	Ext.define('Intel.form.field.ReleasePicker', {
		extend: 'Intel.form.field.FixedComboBox',
		alias: ['widget.intelreleasepicker'],
		
		constructor: function(options){
			if(!options.releases || !options.currentRelease) return;
			
			options.displayField = 'Name';
			options.value = options.currentRelease.data.Name;
			options.store = Ext.create('Ext.data.Store', {
				fields: ['Name'],
				sorters: [function(o1, o2){ return o1.data.Name > o2.data.Name ? -1 : 1; }],
				data: _.map(options.releases, function(r){ return {Name: r.data.Name }; })
			});
			
			options.fieldLabel = options.fieldLabel || 'Release:';
			options.editable = options.editable || false;
			options.width = options.width || 240;
			options.labelWidth = options.labelWidth || 50;
			
			this.callParent([options]); //now that we have the extra stuff added
		}
	});
}());

                /** Fast CFD Calculator is like 1000x faster than the rally build in calculators because this is not a generic
	calculator. it specifically is used to aggregate items with PlanEstimate and ScheduleState fields in an area chart
	between two dates. Example app using this is Train CFD Charts.

	NOTE: you MUST give this calculator startDate, and endDate in the config. ONLY.
*/
(function(){
	var Ext = window.Ext4 || window.Ext;

	Ext.define("FastCfdCalculator", {
		extend:'Rally.data.lookback.SnapshotStore',
		scheduleStates: ['Undefined', 'Defined', 'In-Progress', 'Completed', 'Accepted'],

		_getDates:function(){
			var dates = [], curDay = this.startDate, day=1000*60*60*24;
			while(curDay<=this.endDate){
				var n = curDay.getDay();
				if(n!==0 && n!==6) dates.push(curDay); //dont get weekends
				curDay = new Date(curDay*1 + day);
			}
			return dates;
		},

		_dateToStringDisplay: function (date) {
			return Ext.Date.format(date, 'm/d/Y');
		},

		_getIndexHelper:function(d,ds){ //binsearches for the closest date to d
			var curVal = (ds.length/2), curInt = (curVal>>0), div=(curVal/2), lastInt=-1;
			while(curInt !== lastInt){
				if(ds[curInt]===d) return curInt;
				else if(ds[curInt]>d) curVal-=div;
				else curVal+=div;
				div/=2;
				lastInt = curInt;
				curInt = curVal>>0;
			}
			return curInt;
		},

		_getIndexOnOrBefore: function(d, ds){
			if(ds.length===0) return -1;
			var pos = this._getIndexHelper(d,ds);
			if(pos===0) { if(ds[pos] <= d) return pos; else return -1; } //either start of list or everything is after d
			else if(ds[pos] <= d) return pos;
			else return pos-1;
		},

		_getIndexOnOrAfter: function(d, ds){
			if(ds.length===0) return -1;
			var pos = this._getIndexHelper(d,ds);
			if(pos===ds.length-1) { if(ds[pos] >= d) return pos; else return -1; } //either start of list or everything is after d
			else if(ds[pos] >= d) return pos;
			else return pos+1;
		},

		runCalculation:function(items){
			if(!this.scheduleStates || !this.startDate || !this.endDate) {
				console.log('invalid constructor config', this); return; }
			var dates = this._getDates(), day=1000*3600*24,
				dateMapTemplate = _.map(new Array(dates.length), function(){ return 0;});
			var totals = _.reduce(this.scheduleStates, function(map, ss){
				map[ss] = dateMapTemplate.slice();
				return map;
			}, {});
			for(var itemIndex=0, len=items.length; itemIndex<len; ++itemIndex){
				var item = items[itemIndex].raw, //dont work with records;
					iStart = new Date(item._ValidFrom),
					iEnd = new Date(item._ValidTo),
					state = item.ScheduleState,
					pe = item.PlanEstimate;
				if(!pe || ((iStart/day>>0) === (iEnd/day>>0))) continue; //no need to continue with this one
				var startIndex = this._getIndexOnOrAfter(iStart, dates),
					endIndex = this._getIndexOnOrBefore(iEnd, dates);
				if(startIndex===-1 || endIndex===-1) continue; //no need to continue here
				for(var i=startIndex;i<=endIndex;++i)
					totals[state][i]+=pe;
			}
			return {
				categories:_.map(dates, function(d){ return this._dateToStringDisplay(d); }, this),
				series: _.reduce(this.scheduleStates, function(ar, ss){
					return ar.concat([{name:ss, type:'area', dashStyle:'Solid', data:totals[ss]}]);
				}, [])
			};
		}
	});
}());

                    Ext.define('RetroDashboard', {
        extend: 'IntelRallyApp',
        componentCls: 'app',
        requires: [
            'FastCfdCalculator'
        ],
        mixins: [
            'PrettyAlert',
            'UserAppsPreference',
            'IntelWorkweek',
            'ReleaseQuery',
            'ChartUpdater',
            'ParallelLoader'
        ],
        items:[{
        xtype: 'container', //outside container has dropdown and the donut container
        id: 'retroWrapper',
        cls: 'chart-wrapper',
        items:[{
              xtype:'container',
              id: 'retroReleasePicker',
              marginTop: 40,
              marginBottom: 240
            },{
             xtype: 'container',//donut container divided later into three donut containers
             id: 'retroDonutWrapper',
             cls: 'donut-wrapper',
             layout: {
                 type: 'hbox',
                 align:'left'
                 },
             renderTo: document.body,
             items:[{
                    xtype:'container',//Scope container Wrapper
                    id : 'retroDonutScopeWrapper',
                    layout: {
                            type: 'hbox'
                            },
                   flex: 1,//it tries to give all the elements equal width but if not enough it overlaps which we want
                   items:[{
                        xtype:'container',
                        id: 'retroDonutScope',
                        //cls: 'chart-with-border3',
                        height: 210
                        },{
                        xtype:'container',
                        id: 'retroDonutScopeArrow'/* ,
                        cls: 'chart-with-border2', */
                        },
                        {
                        xtype:'container',
                        id: 'retroDonutScopeFooter'/* ,
                        cls: 'chart-with-border2' */
                        }]
                },{
                    xtype:'container',// CA original wrapper 
                    id: 'retroDonutCaOriginalWrapper',
                    layout: {
                            type: 'hbox'
                            },
                   flex: 1,//it tries to give all the elements equal width but if not enough it overlaps which we want
                   items:[{
                        xtype:'container',
                        id: 'retroDonutCaOriginal',
                        //cls: 'chart-with-border3',
                        height: 210
                        },{
                        xtype:'container',
                        id: 'retroDonutCaOriginalArrow'
                        //cls: 'chart-with-border2'
                        },{
                        xtype:'container',
                        id: 'retroDonutCaOriginalFooter'
                        //cls: 'chart-with-border2'
                        }]
                },{ xtype:'container',
                    id: 'retroDonutCaFinalWrapper',//CA final container
                    layout: {
                            type: 'hbox'
                            },
                   flex: 1,//it tries to give all the elements equal width but if not enough it overlaps which we want
                   items:[{
                        xtype:'container',
                        id: 'retroDonutCaFinal',//donut container
                        //cls: 'chart-with-border3',
                        height: 210
                        },{
                        xtype:'container',
                        id: 'retroDonutCaFinalArrow'//arrow container
                        //cls: 'chart-with-border2'
                        },{
                        xtype:'container',
                        id: 'retroDonutCaFinalFooter'
                        //cls: 'chart-with-border2'
                        }]
                }]
            },{
                xtype:'container',
                id: 'retroChart',
                marginTop: 40,
                marginBottom: 240
            }]
        }],
            /********************************************** SOME CONFIG CONSTANTS *******************************************/
        _chartColors: [
            '#ABABAB',
            '#E57E3A',
            '#E5D038',
            '#0080FF',
            '#3A874F',
            '#000000',
            '#26FF00'
        ],
        _defaultChartConfig: {
            chart: {
                defaultSeriesType: "area",
                zoomType: "xy"
            },
            xAxis: {
                tickmarkPlacement: "on",
                title: {
                    text: "Days",
                    margin: 10
                },
                labels: {
                    y: 20
                }
            },
            yAxis: {
                title: {
                    text: "Points"
                },
                labels: {
                    x: -5,
                    y: 4
                }
            },
            tooltip: {
                formatter: function () {
                    var sum = 0;
                    for(var i=4; i>= this.series.index; --i)
                        sum += this.series.chart.series[i].data[this.point.x].y;
                    return "<b>" + this.x + '</b> (' + datemap[this.point.x] + ')' +
                        "<br /><b>" + this.series.name + "</b>: " + this.y +
                        (this.series.index <=4 ? "<br /><b>Total</b>: " + sum : '');
                }
            },
            plotOptions: {
                series: {
                    marker: {
                        enabled: false,
                        states: {
                            hover: {
                                enabled: true
                            }
                        }
                    },
                    groupPadding: 0.01
                },
                area: {
                    stacking: 'normal',
                    lineColor: '#666666',
                    lineWidth: 2,
                    marker: {
                        enabled: false
                    }
                }
            }
        },
        _buildReleasePicker: function(){
            var me = this;
            //the intel release component takes the array of release and the current selected release
            me.ReleasePicker = Ext.getCmp('retroReleasePicker').add({
                    xtype: 'intelreleasepicker',//this is a intel component in intel-release-picker.js
                    labelWidth: 80,
                    width: 240,
                    releases: me.ReleaseStore.data.items,//input 1
                    currentRelease: me.ReleaseRecord,//input 2
                    listeners: {
                        change: me._onChangeReleasePicker,
                        select: me._onSelectReleasePicker,
                        scope: me
                    }
            });
        },
        _onChangeReleasePicker: function(combo, newval, oldval){
            var me = this;
            if(newval.length===0) combo.setValue(oldval); 
            //console.log("Release Change",combo,newval,oldval);
        },
        _onSelectReleasePicker: function(combo, records){
            var me = this;
            me.ReleaseRecord = me.ReleaseStore.findExactRecord('Name', records[0].data.Name);
            me._loadChart();
        },
        _loadAllChildReleases: function(){
            //debugger;
            var me = this,
                releaseName = me.ReleaseRecord.data.Name,
                //get the name of the train as the name is shared between all the child scrums
                trainName = me.TrainRecord.data.Name.split(' ART')[0];
                //mixin release-query.js _loadReleasesWithName
                return me._loadReleasesWithName(releaseName, trainName)
                .then(function(releaseStore){
                    return me.ReleaseWithName = releaseStore;
                });
        },
        //load all the child releases for 
        //https://rally1.rallydev.com/analytics/doc/#/manual
        //Rally lookback API provides the history of the data 
        //getting the history of user stories for the release selected
        _loadSnapshotStores: function(){
            //debugger;
            var me = this,
                promises = [];
                me.AllSnapshots = [];
                //releaseOid = [];
            me.ReleaseWithName.each(function(f,key){
                //releaseOid.push(f.data.ObjectID);
                var deferred = Q.defer();
                promises.push(deferred.promise);
            Ext.create('Rally.data.lookback.SnapshotStore', {
                    autoLoad:true,
                    limit: Infinity,
                    context:{
                        workspace: me.getContext().getWorkspace()._ref,
                        project: null
                    },
                    sort:{_ValidFrom:1},
                    compress:true,
                    find: {
                        _TypeHierarchy: "HierarchicalRequirement",
                        Children: null,                         //Release: {$in: releaseOid}
                        Release: f.data.ObjectID 
                    },
                    fetch:['ScheduleState', 'PlanEstimate'],
                    hydrate:['ScheduleState', 'PlanEstimate'],
                    listeners: {
                        load: function(store, records,success){
                            // console.log(key,f.data.ObjectID,success,records.length);
                            if(records.length > 0 && success){
                                me.AllSnapshots = me.AllSnapshots.concat(records);
                            } 
                            //TODO revisit this again
/*                          if(!success){
                                //sometimes the query fails
                                //this will reload again when it fails 
                                var reload = false;
                                do {
                                    console.log(reload,"reload");
                                    reload = me._onloadSnapshotStoresFailure(f.data.ObjectID);
                                }
                                while(reload);
                            } */
                            deferred.resolve();
                        },
                        single:true
                    }
                }); 
        });
        return Q.all(promises).then(function(){
                console.log('all snapshots done');
            });
        },
        _buildCharts: function(){
            var me = this,
            //with the release start and end date the calculator will calculate the work week
            calc = Ext.create('FastCfdCalculator',{
              startDate: me.ReleaseRecord.data.ReleaseStartDate,
              endDate: me.ReleaseRecord.data.ReleaseDate
            });
            if(me.AllSnapshots.length === 0 ){
                me._alert('ERROR', me.TrainRecord.data.Name + ' has no data for release: ' + me.ReleaseRecord.data.Name);
                return;     
            } 
            //chart config setting 
            //using jquery to use the high charts
            //uses ChartUpdater mixin
            //uses IntelWorkweek mixin
            var aggregateChartData = me._updateChartData(calc.runCalculation(me.AllSnapshots));
            datemap = aggregateChartData.datemap;
            //debugger;
            //retro dashboard calculation for the doughnut
            //taking sample 7 days before and after the release
            //data for calculating scope change
            //commit to accept original and final calculation
                total = {};
                total.initialCommit = 0;
                total.finalCommit = 0;
                total.finalAccepted = 0;
                total.projected = 0;
            _.each(aggregateChartData.series,function(f){
                if(f.name==="Accepted"){
                    total.finalAccepted = total.finalAccepted + f.data[aggregateChartData.categories.length - 6];
                }
                //we want to ignore the ideal and the projected from the aggregateChartData
                if(f.name !="Ideal" && f.name != "Projected"){
                    //taking sample after 7 days and before 7 days 
                    total.initialCommit = total.initialCommit + f.data[6];
                    total.finalCommit = total.finalCommit + f.data[aggregateChartData.categories.length - 6];
                }
                //if the release is still on going we would like to use the projected data for the final commit
                if(f.name === "Projected"){
                    total.projected = total.projected + f.data[aggregateChartData.categories.length - 6];
                }
            });
            if(total.finalCommit === 0){
                total.finalCommit = total.projected;
                total.finalAccepted = total.projected;
            }
            var commitDataPlus =[];
               // commitDataMinus = [];
            //adding a line for the initial Commitment projection
            _.each(aggregateChartData.categories,function(f,key){
                    commitDataPlus.push(total.initialCommit);
                    //commitDataMinus.push(total.initialCommit - 10);
            });
            //console.log(commitDataPlus,commitDataMinus);
            aggregateChartData.series.push({
                colorIndex: 1,
                symbolIndex: 1,
                dashStyle: "Solid",
                color: "red",
                data:commitDataPlus,
                name: "Commitment",
                type: "spline"
            });
/*          aggregateChartData.series.push({
                colorIndex: 1,
                symbolIndex: 1,
                dashStyle: "Solid",
                color: "red",
                data:commitDataMinus,
                name: "Commitment",
                type: "spline"
            }) */
/*                  //get ideal trendline if release has started
            _.reduce(aggregateChartData.series, function(sum, s){
                console.log(sum,s);
                return sum + (s.data[s.data.length-1] || 0);
                }, 0) 
                 */
            console.log("Aggregate data series",aggregateChartData.series,total.initialCommit);
            me.total = total;
            //setting the color of the chart
            Highcharts.setOptions({ colors: me._chartColors });
            var highchartsConfig = {
                chart: {
                    height:400,
                    events:{
                        load: function(){  }
                    }
                },
                legend:{
                    borderWidth:0,
                    width:500,
                    itemWidth:100
                },
                title: {
                    text: me.TrainRecord.data.Name 
                },
                subtitle:{
                    text: me.ReleaseRecord.data.Name.split(' ')[0]
                },
                xAxis:{
                    categories: aggregateChartData.categories,
                    tickInterval: me._getConfiguredChartTicks(
                        me.ReleaseRecord.data.ReleaseStartDate, me.ReleaseRecord.data.ReleaseDate, me.getWidth()*0.66)
                },
                series: aggregateChartData.series
            };   
            //to use this for update
            //me.highchartsConfig  = highchartsConfig;
            $("#retroChart").highcharts(Ext.Object.merge(me._defaultChartConfig,highchartsConfig));
        },  
        _getConfiguredChartTicks: function(startDate, endDate, width){
            var pixelTickWidth = 40,
                ticks = width/pixelTickWidth>>0,
                oneDay = 1000*60*60*24,//this calculation is equivalent to one day 
                days = (endDate*1 - startDate*1)/(oneDay*5/7)>>0, //only workdays
                interval = ((days/ticks>>0)/5>>0)*5;
            return (interval < 5) ? 5 : interval; //make it weekly at the minimum
        },
        _loadChart: function(){
            var me = this;
            me.setLoading('Loading Charts');
            return me._loadAllChildReleases()
            .then(function() { return me._loadSnapshotStores(); })
            .then(function(){ 
                me._buildCharts(); 
                me.setLoading(false);})
            .then (function(){ 
                me.setLoading(false);
                me.setLoading('Loading Pie Charts');
                me._loadDonutChart(); 
                me._hideHighchartsLinks();
                me.setLoading(false);
                me._loadPortfolioItem();
           })
           .fail(function(reason){
                me.setLoading(false);
                me._alert('ERROR', reason || '');
                 })
            .done();            
        },
        _loadDonutChart: function(){
        
             var me = this;
             Ext.getCmp('retroDonutWrapper').show();
             //console.log("highchart config",me.highchartsConfig);
             //arrow inside the donut
             //debugger;
             //destroy the arrow items
             Ext.getCmp('retroDonutScopeArrow').removeAll();
             Ext.getCmp('retroDonutCaOriginalArrow').removeAll();
             Ext.getCmp('retroDonutCaFinalArrow').removeAll();
             
            if (me.total.initialCommit === 0 || me.total.finalCommit === 0 ){
                 $("#retroDonutScope").html(''); 
                 $("#retroDonutCaOriginal").html('');
                 $("#retroDonutCaFinal").html('');
                 me._alert('Note', 'The initial PlanEstimate is zero');
                 Ext.getCmp('retroDonutWrapper').hide();
                return;
            }
            /******************************************************* Donut settings ********************************************************/
            var scope = 0,
                originalCommitRatio = 0,
                finalCommitRatio = 0;
            //calculate difference between two data V1 and V2 
            //Percent difference = ( | V |/ ( V/2) ) * 100 = ( | (V1 - V2) | / ((V1 + V2)/2) ) * 100
            scopeDeltaPerc = ((me.total.finalCommit - me.total.initialCommit)/((me.total.initialCommit + me.total.finalCommit )/2)) * 100 ;
            originalCommitRatio = (me.total.finalAccepted/me.total.initialCommit)* 100 ;
            finalCommitRatio = (me.total.finalAccepted /me.total.finalCommit)* 100 ;
            //scope data 
            var drawComponentScope = Ext.create('Ext.draw.Component', {
                    width: 50,
                    height:50,
                    items: [{
                        type: "path",
                        path: "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z", //up arrow
                        //path: "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z",//down arrow 
                        fill: "green"
                    }]
                });
            //fixing the numbers to be 20 and 80 so that the donut always looks the same
            //for a static UI
            var dataseries = [];
            dataseries.push(new Array('ScopeDelta',20));
            dataseries.push(new Array('In Scope',80));
            //center of the donut for 1st pie 
            //var center =
            var donutConfig = {
            chart: {
                height:200,
                plotBackgroundColor: '#FFFFFF',
                plotShadow: false
            },
            title: {
                align: 'left',
                verticalAlign: 'left',
                x: 300,
                y: 20
            },
            tooltip: {
                //pointFormat: '{series.name}: <b>{point.percentage:.1f}%</b>'
                formatter: function () {
                        //console.log(this.series.data[this.point.x].x);
                        //console.log(this.series.data[this.point.x].name);
                        return  this.series.data[this.point.x].name;
                        //return this.series.data.dataseries.name;
                    }
            },
            plotOptions: {
                pie: {
                    dataLabels: {
                        enabled: false,//enable true if you want anything in it 
                        distance: - 20,
                        formatter: function(){
                            return Math.round(this.percentage * 100)/100 + '%';//if you want the labels to be in percentage
                        },
                        style: {
                            fontWeight: 'bold',
                            color: 'black',
                            textShadow: '0px 1px 2px white'
                        }
                    },
                    showInLegend: false,//show legend true if you want to show the legend
                    startAngle: 0,
                    endAngle: 360,
                    center: ['40%', '60%']//center of the circle, left top of the screen is the origin 
                }
            },
            series: [{
                type: 'pie',
                name: 'scope',
                innerSize: '80%',
                data: dataseries
            }]
        };
        /******************************************************* Donut 1 ********************************************************/
        //debugger;
        //#808080 Initial Commit
        //#7cb5ec Final Commit 
        //#3A874F Final Accepted        
        //scope config
        donutConfig.title.text = 'Scope <br/>' + scopeDeltaPerc.toFixed(2) + '% <br/>'; //+ me.total.finalCommit.toFixed(2) + ' of ' + me.total.initialCommit.toFixed(2);
        //debugger;
        $("#retroDonutScopeFooter").html(me.total.finalCommit.toFixed(2) + ' of ' + me.total.initialCommit.toFixed(2));
        //Ext.getCmp('retroDonutScopeFooter').add(me.total.finalCommit.toFixed(2) + ' of ' + me.total.initialCommit.toFixed(2));
        if(scopeDeltaPerc >=0 && scopeDeltaPerc <= 10.99){
            Highcharts.setOptions({ colors: ['#3A874F','#7cb5ec'] });
            drawComponentScope.items[0].path = "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z";
            drawComponentScope.items[0].fill ="green";
        }else{
            Highcharts.setOptions({ colors: ['#E62E00','#7cb5ec'] });
            drawComponentScope.items[0].path = "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z";
            drawComponentScope.items[0].fill ="red";
        }
    
        $("#retroDonutScope").highcharts(donutConfig);
        Ext.getCmp('retroDonutScopeArrow').add(drawComponentScope);
        /******************************************************* Donut 2 ********************************************************/
            //C/A Ratio Original Config
         var drawComponentOri = Ext.create('Ext.draw.Component', {
                    width: 50,
                    height:50,
                    items: [{
                        type: "path",
                        path: "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z", //up arrow
                        //path: "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z",//down arrow 
                        fill: "green"
                    }]
                });
        
        donutConfig.series.data = dataseries;
        donutConfig.title.text = 'C/A Ratio Original <br/>' + originalCommitRatio.toFixed(2) + '%<br/>'; //+ me.total.finalAccepted.toFixed(2) + ' of ' + me.total.initialCommit.toFixed(2);
        $("#retroDonutCaOriginalFooter").html(me.total.finalAccepted.toFixed(2) + ' of ' + me.total.initialCommit.toFixed(2));
        if(originalCommitRatio >= 90){//100 percentage would be all the work completed so plus minus 10 is acceptable
            Highcharts.setOptions({ colors: ['#3A874F','#7cb5ec'] });
            drawComponentOri.items[0].path = "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z";
            drawComponentOri.items[0].fill ="green";
        }else{
            Highcharts.setOptions({ colors: ['#E62E00','#7cb5ec'] });
            drawComponentOri.items[0].path = "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z";
            drawComponentOri.items[0].fill ="red";
        }
        $("#retroDonutCaOriginal").highcharts(donutConfig);
        Ext.getCmp('retroDonutCaOriginalArrow').add(drawComponentOri);
    /******************************************************* Donut 3 ********************************************************/
            //C/A Ratio Original Config
         var drawComponentFinal = Ext.create('Ext.draw.Component', {
            width: 50,
            height:50,
        /*  gradients :[{
            id: 'gradientId',
            angle: 45,
            stops: {
                0: {
                    color: '#D90000'
                },
                100: {
                    color: '#FF7373'
                }
              }
            }], */
            items: [{
                type: "path",
                path: "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z", //up arrow
                //path: "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z",//down arrow 
                fill: "green"
            }]
        });
        donutConfig.series.data = dataseries;
        donutConfig.title.text = 'C/A Ratio Final <br/>' + finalCommitRatio.toFixed(2) + '%<br/>';// + me.total.finalAccepted.toFixed(2) + ' of ' + me.total.finalCommit.toFixed(2);
        $("#retroDonutCaFinalFooter").html(me.total.finalAccepted.toFixed(2) + ' of ' + me.total.finalCommit.toFixed(2));
        if(finalCommitRatio >= 90){//plus minus 10 is acceptable when 90 percentage is done, only 10% is left which is acceptable 
            Highcharts.setOptions({ colors: ['#3A874F','#7cb5ec'] });
            drawComponentFinal.items[0].path = "M150 0 L75 200 L225 200 Z" + "M110 200 h 80 v 80 h -80 Z";
            drawComponentFinal.items[0].fill ="green";
        }else{
            Highcharts.setOptions({ colors: ['#E62E00','#7cb5ec'] });
            drawComponentFinal.items[0].path = "M180 20 h 30 v 50 h -30 Z" + "M160 50 h 70 L195 100 Z";
            drawComponentFinal.items[0].fill ="red";
        }
        $("#retroDonutCaFinal").highcharts(donutConfig);
        Ext.getCmp('retroDonutCaFinalArrow').add(drawComponentFinal);

        },
        _hideHighchartsLinks: function(){
                $('.highcharts-container > svg > text:last-child').hide();
        },
        _getFeatureFilter: function(){          
            var me = this,
                releaseName = me.ReleaseRecord.data.Name,
                releaseNameFilter = Ext.create('Rally.data.wsapi.Filter', { property: 'Release.Name', value: releaseName }),
                featureProductFilter = _.reduce(me.Products, function(filter, product){
                    var thisFilter = Ext.create('Rally.data.wsapi.Filter', { property: 'Parent.Parent.ObjectID',  value:product.data.ObjectID });
                    return filter ? filter.or(thisFilter) : thisFilter;
                }, null);
            //console.log("feature product filter",releaseName,releaseNameFilter,featureProductFilter);
            return featureProductFilter ? releaseNameFilter.and(featureProductFilter) : {property:'ObjectID', value:0};
            
        },  
        _getFeatures: function(){
            var me=this,
                config = {
                    model: me.Feature,
                    url: 'https://rally1.rallydev.com/slm/webservice/v2.0/PortfolioItem/Feature',
                    params: {
                        pagesize:200,
                        query: me._getFeatureFilter().toString(),
                        fetch:['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'Release', 
                            'Description', 'FormattedID', 'UserStories'].join(','),
                        workspace:me.getContext().getWorkspace()._ref,
                        includePermissions:true
                    }
                };
            //parrallel load mixin 
            return me._parallelLoadWsapiStore(config).then(function(store){
                me.FeatureStore = store;
                return store;
            });
        
        },
        _loadPortfolioItem: function(){
            var me = this;
            
            me.setLoading('Loading PortfolioItem/Feature');
            return Q.all([
                    me._getFeatures()
                ])
                .then(function(store){ console.log(store); })
                .fail(function(reason){ 
                console.log("fail",reason);
                me.setLoading(false);
                return Q.reject(reason);  })
                .then(function(){ me.setLoading(false); });
            
/*          console.log("Release Name", me.ReleaseWithName);
            var portfolio = Ext.create('Rally.data.wsapi.Store',{
                model: 'PortfolioItem/feature',
                autoLoad: true,
                context:{
                        workspace: me.getContext().getWorkspace()._ref,
                        project: null
                    },
                params: {
                        pagesize:200,
                        query:me._getFeatureFilter().toString(),
                        fetch:['Name', 'ObjectID', 'Project', 'PlannedEndDate', 'ActualEndDate', 'Release', 
                            'Description', 'FormattedID', 'UserStories'].join(','),
                        workspace:me.getContext().getWorkspace()._ref,
                        includePermissions:true
                    }
                listeners: {
                    load: function(store,data,success){
                        console.log("here");
                        //console.log("portfolio",data);
                        
                        _.each(data,function(f){
                            /* console.log(f.data);
                            PercentDoneByStoryCount: 0
                            PercentDoneByStoryPlanEstimate: 0
                            PlannedEndDate: nullPlannedStartDate: null
                            Release: ObjectCreationDate: "2014-01-03T08:25:09.241Z"Name: "Q1_2014" 
                        });
                    }
                }
                
            }) */
        },
        _buildGrid: function(){
            
        },
        /************************************************** updating/fixing chart data *********************************************/
    /*  _updateHighchart: function(chart, chartData, dynConf){ //directly manipulate the highchart, avoid the Ext.js highchart extension
            var wrapper = chart.getChartWrapper(), wc = wrapper.chart, newSeries = chartData.series, y, x;
            wc.xAxis[0].update({categories:chartData.categories, tickInterval:dynConf.xAxis.tickInterval});
            wc.setTitle(dynConf.title, dynConf.subtitle);
            for(var i=0;i<newSeries.length;++i){
                var newData = newSeries[i].data, oldData=wc.series[i];
                var oldSerLen = oldData.points.length;
                var newSerLen = newData.length;
                oldData.setData(newData, false, true, false);
            }
            wc.redraw();
        }, */
        launch: function() {
            var me = this;
            me._loadModels()
                    .then(function(){
                        var scopeProject = me.getContext().getProject();
                        return me._loadProject(scopeProject.ObjectID);
                    })
                    .then(function(scopeProjectRecord){
                        me.ProjectRecord = scopeProjectRecord;
                        return Q.all([ //parallel loads
                        me._projectInWhichTrain(me.ProjectRecord) /********* 1 ************/
                            .fail(function(reason){
                                if(reason != 'Project not in a train') return Q(reason); //its ok if its not in the train
                            })
                            .then(function(trainRecord){
                                if(trainRecord){
                                    if(trainRecord.data.ObjectID != me.ProjectRecord.data.ObjectID) me._isScopedToTrain = false;
                                    else me._isScopedToTrain = true;
                                    me.TrainRecord = trainRecord;
                                    return me._loadAllLeafProjects(me.TrainRecord)
                                        .then(function(leftProjects){
                                            me.LeafProjects = leftProjects;
                                            if(me._isScopedToTrain) me.CurrentTeam = null;
                                            else me.CurrentTeam = me.ProjectRecord;
                                            return me._loadProducts(me.TrainRecord);
                                        })
                                        .then(function(productStore){ me.Products = productStore.getRange(); });
                                }
                                else {
                                    me.CurrentTeam = me.ProjectRecord;
                                    me._isScopedToTrain = false;
                                }
                            }),
                            me._loadAppsPreference() /******** load stream 2 *****/
                                .then(function(appsPref){
                                    me.AppsPref = appsPref;
                                    var oneYear = 1000*60*60*24*365;
                                    // to look at results within last 1 year 
                                    return me._loadReleasesBetweenDates(me.ProjectRecord, (new Date()*1 - oneYear), new Date());
                                })
                                .then(function(releaseStore){
                                    me.ReleaseStore = releaseStore;
                                    var currentRelease = me._getScopedRelease(me.ReleaseStore.data.items, me.ProjectRecord.data.ObjectID, me.AppsPref);
                                    if(currentRelease) me.ReleaseRecord = currentRelease;
                                    else return Q.reject('This train has no releases.');
                                })
                        ]);
                    })
                    .then(function() { me._buildReleasePicker(); })
                    .then (function(){ 
                        me._loadChart(); 
                        me._hideHighchartsLinks();
                        })
                    .fail(function(reason){
                        me.setLoading(false);
                        me._alert('ERROR', reason || '');
                    })
                    .done();
         }
    });

            Rally.launchApp('RetroDashboard', {
                name:"RetroDashboard",
	            parentRepos:""
            });

        });
    </script>



    <style type="text/css">
        .app {
  /* Add app styles here */
}
.chart-wrapper {
  margin: 10px;
  padding: 10px;
}
.donut-wrapper {
  /*border: solid red 1px;*/
  width: 80%;
  /*change the width percentage to change the size of the donut-wrapper*/
}
.chart-with-border {
  font-weight: bold;
  font-family: "Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif;
  z-index: -1;
}
.chart-with-border2 {
  border: solid green 1px;
}
span#retroDonutScopeArrow-outerCt,
span#retroDonutCaOriginalArrow-outerCt,
span#retroDonutCaFinalArrow-outerCt {
  margin-top: 70px;
  margin-left: 220px;
}
#retroDonutScopeFooter,
#retroDonutCaOriginalFooter,
#retroDonutCaFinalFooter {
  padding-top: 190px;
  padding-left: 140px;
  font-weight: bold;
  font-family: "Lucida Grande", "Lucida Sans Unicode", Arial, Helvetica, sans-serif;
}

    </style>
</head>
<body>
</body>
</html>
